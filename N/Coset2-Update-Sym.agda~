{-# OPTIONS  --safe #-}
{-# OPTIONS  --call-by-name #-}
--{-# OPTIONS --termination-depth=2 #-}
open import Level using (0ℓ)

open import Relation.Binary using (Rel)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Binary.Morphism.Definitions using (Homomorphic₂)
open import Relation.Binary.PropositionalEquality using (_≡_ ; _≢_ ; inspect ; setoid ; module ≡-Reasoning ; _≗_) renaming ([_] to [_]')
import Relation.Binary.Reasoning.Setoid as SR
import Relation.Binary.PropositionalEquality as Eq
open import Relation.Nullary.Decidable using (yes ; no)


open import Function using (_∘_ ; id)
open import Function.Definitions using (Injective)

open import Data.Product using (_×_ ; _,_ ; proj₁ ; proj₂ ; map₁ ; ∃ ; Σ ; Σ-syntax)
open import Data.Product.Relation.Binary.Pointwise.NonDependent as PW using (≡×≡⇒≡ ; Pointwise ; ≡⇒≡×≡)
open import Data.Nat hiding (_^_ ; _+_ ; _*_ ;  _≟_)
open import Agda.Builtin.Nat using (_-_)
import Data.Nat as Nat
open import Data.Bool hiding (_<_ ; _≤_ ; _≟_)
open import Data.List hiding ([_] ; _++_ ; last ; head ; tail ; _∷ʳ_)
open import Data.Vec hiding ([_])
import Data.Vec as Vec
open import Data.Fin hiding (_+_ ; _-_)

open import Data.Maybe
open import Data.Sum using (_⊎_ ; inj₁ ; inj₂ ; [_,_] ; [_,_]′)
open import Data.Unit using (⊤ ; tt)
open import Data.Empty using (⊥ ; ⊥-elim)

open import Word.Base as WB hiding (wfoldl ; _*)
open import Word.Properties
import Presentation.Base as PB
import Presentation.Properties as PP
open PP using (NFProperty ; NFProperty')
import Presentation.CosetNF as CA
import Presentation.Reidemeister-Schreier as RS
module RSF = RS.Star-Injective-Full.Reidemeister-Schreier-Full

open import Presentation.Construct.Base hiding (_*_ ; _⊕_)
import Presentation.Construct.Properties.SemiDirectProduct2 as SDP2
import Presentation.Construct.Properties.DirectProduct as DP
import Presentation.Groups.Cyclic as Cyclic


open import Data.Fin using (Fin ; toℕ ; suc ; zero ; fromℕ)
open import Data.Fin.Properties using (suc-injective ; toℕ-inject₁ ; toℕ-fromℕ)
import Data.Nat.Properties as NP
open import Presentation.GroupLike
open import Presentation.Tactics hiding ([_] ; inspect)
open import Data.Nat.Primality
import Data.Fin.Properties as FP



module N.Coset2-Update-Sym (p-2 : ℕ) (p-prime : Prime (2+ p-2))  where

open import Zp.ModularArithmetic
open PrimeModulus p-2 p-prime
open import N.Symplectic p-2 p-prime
open import N.Lemmas-2Qupit p-2 p-prime
open import N.NF2-Sym p-2 p-prime
--open Lemmas-2Q 2
open Symplectic
open Lemmas-Sym
open import N.NF1-Sym p-2 p-prime
open import N.Ex-Sym p-2 p-prime
open import N.Ex-Sym1 p-2 p-prime
open import N.Ex-Sym2 p-2 p-prime
open import N.Ex-Sym3 p-2 p-prime
open import N.Ex-Sym4 p-2 p-prime
open import N.Ex-Sym5 p-2 p-prime hiding (module L0)
open import N.Cosets p-2 p-prime

open import N.Lemma-Comm p-2 p-prime 0
open import N.Completeness1-Sym p-2 p-prime renaming (module Completeness to Cp1)
open Lemmas0a
open Lemmas0a1
open Lemmas0b
open Lemmas0c

open LM2
open import N.Completeness1-Sym p-2 p-prime renaming (module Completeness to CP1) using ()


module Completeness where

  open PB (2 QRel,_===_)
  open PP (2 QRel,_===_)
  open SR word-setoid
  open Pattern-Assoc
  open Sym0-Rewriting 1


  -- PrimitiveGen : Gen 2 -> Set
  -- PrimitiveGen (H-gen ₁) = ⊤
  -- PrimitiveGen (S-gen ₁) = ⊤
  -- PrimitiveGen (H-gen ₁ ↥) = ⊤
  -- PrimitiveGen (S-gen ₁ ↥) = ⊤
  -- PrimitiveGen (CZ-gen ₁) = ⊤
  -- PrimitiveGen _ = ⊥

  -- PrimitiveWord : Word(Gen 2) -> Set
  -- PrimitiveWord [ x ]ʷ = PrimitiveGen x
  -- PrimitiveWord ε = ⊤
  -- PrimitiveWord (w • w₁) = PrimitiveWord w × PrimitiveWord w₁

  -- desugar-gen :(Gen 2) -> Word(Gen 2)
  -- desugar-gen (H-gen x) = H ^ toℕ x
  -- desugar-gen (S-gen x) = S ^ toℕ x
  -- desugar-gen (H-gen x ↥) = (H ^ toℕ x) ↑
  -- desugar-gen (S-gen x ↥) = (S ^ toℕ x) ↑
  -- desugar-gen (CZ-gen x) = CZ ^ toℕ x

  -- desugar-word = desugar-gen WB.*

  -- lemma-H^-Prim : ∀ x -> PrimitiveWord (H ^ x)
  -- lemma-H^-Prim ₀ = tt
  -- lemma-H^-Prim ₁ = tt
  -- lemma-H^-Prim (₂₊ k) = tt , (lemma-H^-Prim (₁₊ k))

  -- lemma-H↑^-Prim : ∀ x -> PrimitiveWord ((H ^ x) ↑)
  -- lemma-H↑^-Prim ₀ = tt
  -- lemma-H↑^-Prim ₁ = tt
  -- lemma-H↑^-Prim (₂₊ k) = tt , (lemma-H↑^-Prim (₁₊ k))

  -- lemma-S^-Prim : ∀ x -> PrimitiveWord (S ^ x)
  -- lemma-S^-Prim ₀ = tt
  -- lemma-S^-Prim ₁ = tt
  -- lemma-S^-Prim (₂₊ k) = tt , (lemma-S^-Prim (₁₊ k))

  -- lemma-S↑^-Prim : ∀ x -> PrimitiveWord ((S ^ x) ↑)
  -- lemma-S↑^-Prim ₀ = tt
  -- lemma-S↑^-Prim ₁ = tt
  -- lemma-S↑^-Prim (₂₊ k) = tt , (lemma-S↑^-Prim (₁₊ k))

  -- lemma-CZ^-Prim : ∀ x -> PrimitiveWord (CZ ^ x)
  -- lemma-CZ^-Prim ₀ = tt
  -- lemma-CZ^-Prim ₁ = tt
  -- lemma-CZ^-Prim (₂₊ k) = tt , (lemma-CZ^-Prim (₁₊ k))
  
  -- lemma-desugar-gen : (g :(Gen 2)) -> PrimitiveWord (desugar-gen g)
  -- lemma-desugar-gen (H-gen x) = lemma-H^-Prim (toℕ x)
  -- lemma-desugar-gen (S-gen x) = lemma-S^-Prim (toℕ x)
  -- lemma-desugar-gen (H-gen x ↥) = lemma-H↑^-Prim (toℕ x)
  -- lemma-desugar-gen (S-gen x ↥) = lemma-S↑^-Prim (toℕ x)
  -- lemma-desugar-gen (CZ-gen x) = lemma-CZ^-Prim (toℕ x)

  -- lemma-desugar-word : (w : Word(Gen 2)) -> PrimitiveWord (desugar-word w)
  -- lemma-desugar-word [ x ]ʷ = lemma-desugar-gen x
  -- lemma-desugar-word ε = tt
  -- lemma-desugar-word (w • w₁) = (lemma-desugar-word w) , (lemma-desugar-word w₁)

  -- lemma-desugar-gen-≈ : (g :(Gen 2)) -> desugar-gen g ≈ [ g ]ʷ
  -- lemma-desugar-gen-≈ (H-gen x) = sym (axiom (derived-H x))
  -- lemma-desugar-gen-≈ (S-gen x) = sym (axiom (derived-S x))
  -- lemma-desugar-gen-≈ (H-gen x ↥) = sym (axiom (cong↑ (derived-H x)))
  -- lemma-desugar-gen-≈ (S-gen x ↥) = sym (axiom (cong↑ (derived-S x)))
  -- lemma-desugar-gen-≈ (CZ-gen x) = sym (axiom (derived-CZ x))

  -- lemma-desugar-word-≈ : (w : Word(Gen 2)) -> desugar-word w ≈ w
  -- lemma-desugar-word-≈ [ x ]ʷ = lemma-desugar-gen-≈ x
  -- lemma-desugar-word-≈ ε = refl
  -- lemma-desugar-word-≈ (w • w₁) = cong (lemma-desugar-word-≈ w) (lemma-desugar-word-≈ w₁)


  open import N.Proofs.P1 p-2 p-prime
  open import N.Proofs.P2 p-2 p-prime
  open import N.Proofs.P3 p-2 p-prime
  open import N.Proofs.P4 p-2 p-prime
  open import N.Proofs.P5 p-2 p-prime
  open import N.Proofs.P6 p-2 p-prime
  open import N.Proofs.P7 p-2 p-prime hiding (module L0)
  open import N.Proofs.P8 p-2 p-prime
  open import N.Proofs.P9 p-2 p-prime
  open import N.Lemmas-2Qupit-Sym p-2 p-prime as TQ
  open import N.Lemma-Postfix p-2 p-prime
  open import N.Derived p-2 p-prime
  open import N.Derived2 p-2 p-prime
--  open import N.NF1-Sym p-2 p-prime as NF1
--  open NF1.Normal-Form1 using ()
  
  open TQ.Lemmas-2Q 0
  open Duality
  import N.Duality p-2 p-prime as ND
  open Lemmas0 1
  module L0 = Lemmas0 0
  open import Algebra.Properties.Ring (+-*-ring p-2)
  open import Zp.Mod-Lemmas p-2 p-prime

  Lemma-two-qupit-completeness :

    ∀ (lm : Cosets2) (g :(Gen 2)) ->
    -------------------------------------------------------
    ∃ \ lm' -> ∃ \ w -> ⟦ lm ⟧₂ • [ g ]ʷ ≈ w ↑ • ⟦ lm' ⟧₂

  Lemma-two-qupit-completeness lm@(case-||ₐ cz pf@(sp , mc2@(m2 , c@(HS^ k)) , mc1@(m1 , ε))) (CZ-gen) = lm''' , w''' , claim''
    where
    l = cz
    w' = S^ l • H ^ 3
    pf' : Postfix
    pf' = (sp + l , mc1 , mc2)
    lm' = case-|| (₁ , λ ()) (- l) (sp + l , mc1 , mc2)

    ih = Lemma-two-qupit-completeness-||-mε-mHS^k' (₁ , λ ()) (- l) (sp + l) m1 m2 k
    ihp = ih .proj₂ .proj₂
    w'' = ih .proj₂ .proj₁
    lm'' = ih .proj₁
    
    cd = Theorem-NF2-duality lm''
    w4 = cd .proj₁
    lm''' = cd .proj₂ .proj₁
    cdp = cd .proj₂ .proj₂
    w''' = w' • w'' • w4

    claim'' : ⟦ case-||ₐ cz (sp , mc2 , mc1) ⟧₂ • CZ ≈ w''' ↑ • ⟦ lm''' ⟧₂
    claim'' = begin
      ⟦ case-||ₐ cz (sp , mc2 , mc1) ⟧₂ • CZ ≈⟨ (cright sym (trans (cleft lemma-order-Ex) left-unit)) ⟩
      ⟦ case-||ₐ cz (sp , mc2 , mc1) ⟧₂ • Ex ^ 2 • CZ ≈⟨ sym (special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto) ⟩
      (⟦ case-||ₐ cz (sp , mc2 , mc1) ⟧₂ • Ex) • Ex • CZ ≈⟨ (cong (lemma-case-||ₐ l pf) (sym lemma-comm-Ex-CZ) ) ⟩
      (w' ↑ • ⟦ lm' ⟧₂) • CZ • Ex ≈⟨ special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ⟩
      w' ↑ • (⟦ lm' ⟧₂ • CZ) • Ex ≈⟨ (cright cleft ihp) ⟩
      w' ↑ • (w'' ↑ • ⟦ lm'' ⟧₂) • Ex ≈⟨ sym (special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto) ⟩
      (w' • w'') ↑ • ⟦ lm'' ⟧₂ • Ex ≈⟨ (cright cdp) ⟩
      (w' • w'') ↑ • w4 ↑ • ⟦ lm''' ⟧₂ ≈⟨ sym (special-assoc (□ ^ 3 • □) (□ ^ 2 • □ ^ 2) auto) ⟩
      w''' ↑ • ⟦ lm''' ⟧₂ ∎



  Lemma-two-qupit-completeness lm@(case-|| cz* l (sp , mc2@(m2 , c@(HS^ k2)) , mc1@(m1 , ε))) (CZ-gen) = Lemma-two-qupit-completeness-||-mHS^k-mε cz* l sp m2 k2 m1
  Lemma-two-qupit-completeness lm@(case-|| cz* sl (s , mc@(m , c@ε) , mc''@(m'' , c''@(HS^ k')))) (CZ-gen) = Lemma-two-qupit-completeness-||-mε-mHS^k' cz* sl s m m'' k'
  Lemma-two-qupit-completeness lm@(case-|| cz* sl (s , mc@(m , c@(HS^ k)) , mc''@(m'' , c''@(HS^ k')))) (CZ-gen) = Lemma-two-qupit-completeness-||-mHS^k-mHS^k' cz* sl s m k m'' k'
  Lemma-two-qupit-completeness lm@(case-|| cz* sl (s , mc@(m , c@ε) , mc''@(m' , c''@ε))) (CZ-gen) = Lemma-two-qupit-completeness-||-mε-mε cz* sl s m m'
  Lemma-two-qupit-completeness lm@(case-||ₐ cz (s , mc@(m , c@ε) , mc''@(m' , c''@ε))) (CZ-gen) = Lemma-two-qupit-completeness-||ₐ-mε-mε cz s m m'
  Lemma-two-qupit-completeness lm@(case-||ₐ cz (s , mc@(m , c@(HS^ k)) , mc''@(m'' , c''@(HS^ k')))) (CZ-gen) = Lemma-two-qupit-completeness-||ₐ-mHS^k-mHS^k' cz s m k m'' k'
  Lemma-two-qupit-completeness lm@(case-||ₐ cz (s , mc@(m , c@ε) , mc''@(m'' , c'@(HS^ k')))) (CZ-gen) = Lemma-two-qupit-completeness-||ₐ-mε-mHS^k' cz s m m'' k'


  Lemma-two-qupit-completeness lm@(case-Ex-| nf1@(s' , m' , c'@ε) mc@(m , c@ε) ) (CZ-gen) with ((m ⁻¹) .proj₁ + m' .proj₁) | inspect (\ m -> ((m ⁻¹) .proj₁ + m' .proj₁)) m
  ... | ₀ | [ eq ]' = lm'' , w , claim
    where
    w = ⟦ m ⟧ₘ
    lm' = case-nf1 (s' , m' , ε)
    lm'' = case-Ex-nf1 (s' , m' , ε)
    claim : ⟦ lm ⟧₂ • CZ ≈ w ↑ • ⟦ lm'' ⟧₂
    claim = begin
      ⟦ lm ⟧₂ • CZ ≈⟨ (cleft case-duality mc nf1) ⟩
      (⟦ case-| mc nf1 ⟧₂ • Ex) • CZ ≈⟨ assoc ⟩
      ⟦ case-| mc nf1 ⟧₂ • Ex • CZ ≈⟨ (cright sym lemma-comm-Ex-CZ) ⟩
      ⟦ case-| mc nf1 ⟧₂ • CZ • Ex ≈⟨ sym assoc ⟩
      (⟦ case-| mc nf1 ⟧₂ • CZ) • Ex ≈⟨ (cleft step-|-CZa m s' m' eq) ⟩
      (w ↑ • ⟦ lm' ⟧₂) • Ex ≈⟨ assoc ⟩
      w ↑ • ⟦ lm' ⟧₂ • Ex ≈⟨ (cright sym (lemma-Ex-SMC (s' , m' , ε))) ⟩
      w ↑ • ⟦ lm'' ⟧₂ ∎

  ... | (₁₊ mm) | [ eq ]' = let aa = ((m ⁻¹) .proj₁ + m' .proj₁) in lm'' , ⟦ m ⟧ₘ • M (aa , neq) , claim
    where
    neq : ((m ⁻¹) .proj₁ + m' .proj₁) ≢ ₀
    neq ee with Eq.trans (Eq.sym ee) eq
    ... | ()
    aa = ((m ⁻¹) .proj₁ + m' .proj₁)
    w = ⟦ m ⟧ₘ • M (aa , neq)
    lm' = case-| ((aa , neq) ⁻¹ , ε) (s' , m' , ε)
    lm'' = case-Ex-| (s' , m' , ε) ((aa , neq) ⁻¹ , ε) 
    claim : ⟦ lm ⟧₂ • CZ ≈ (⟦ m ⟧ₘ • M (aa , neq)) ↑ • ⟦ lm'' ⟧₂
    claim = begin
      ⟦ lm ⟧₂ • CZ ≈⟨ (cleft case-duality mc nf1) ⟩
      (⟦ case-| mc nf1 ⟧₂ • Ex) • CZ ≈⟨ assoc ⟩
      ⟦ case-| mc nf1 ⟧₂ • Ex • CZ ≈⟨ (cright sym lemma-comm-Ex-CZ) ⟩
      ⟦ case-| mc nf1 ⟧₂ • CZ • Ex ≈⟨ sym assoc ⟩
      (⟦ case-| mc nf1 ⟧₂ • CZ) • Ex ≈⟨ (cleft step-|-CZb m s' m' neq) ⟩
      (w ↑ • ⟦ lm' ⟧₂) • Ex ≈⟨ assoc ⟩
      w ↑ • ⟦ lm' ⟧₂ • Ex ≈⟨ (cright sym (case-duality (((aa , neq) ⁻¹ , ε)) ((s' , m' , ε)))) ⟩
      w ↑ • ⟦ case-Ex-| (s' , m' , ε) ((aa , neq) ⁻¹ , ε) ⟧₂ ≈⟨ refl ⟩
      w ↑ • ⟦ lm'' ⟧₂ ∎



  Lemma-two-qupit-completeness lm@(case-Ex-| nf1@(s' , m' , c'@ε) mc@(m , c@(HS^ k)) ) (CZ-gen) = lm'' , w , claim

    where
    m⁻¹ = (m ⁻¹) .proj₁
    m'⁻¹ = (m' ⁻¹) .proj₁
    mf = m .proj₁
    a* = m ⁻¹
    a = a* .proj₁
    l = m' .proj₁
    -l : ℤ ₚ
    -l = - l
    l⁻¹ : ℤ ₚ
    l⁻¹ = ((m' ⁻¹) .proj₁)
    -l⁻¹ : ℤ ₚ
    -l⁻¹ = - l⁻¹


    s1' = - mf * m'⁻¹
    mc1' =  m , HS^ (- (m' *' m) .proj₁ + k)
    nf1' = (s1' , mc1')

    w = ⟦ - mf * m'⁻¹ ,  m *' m' ⁻¹ , HS^ (- mf * m'⁻¹) ⟧₁
    lm' = case-| mc1' (-l * a + s' , m' , ε)
    lm'' = case-Ex-| (-l * a + s' , m' , ε) mc1' 
    claim : ⟦ lm ⟧₂ • CZ ≈ w ↑ • ⟦ lm'' ⟧₂
    claim = begin
      ⟦ lm ⟧₂ • CZ ≈⟨ (cleft case-duality mc nf1) ⟩
      (⟦ case-| mc nf1 ⟧₂ • Ex) • CZ ≈⟨ assoc ⟩
      ⟦ case-| mc nf1 ⟧₂ • Ex • CZ ≈⟨ (cright sym lemma-comm-Ex-CZ) ⟩
      ⟦ case-| mc nf1 ⟧₂ • CZ • Ex ≈⟨ sym assoc ⟩
      (⟦ case-| mc nf1 ⟧₂ • CZ) • Ex ≈⟨ (cleft step-|-CZ m k s' m') ⟩
      (w ↑ • ⟦ lm' ⟧₂) • Ex ≈⟨ assoc ⟩
      w ↑ • ⟦ lm' ⟧₂ • Ex ≈⟨ (cright sym (case-duality mc1' ((-l * a + s' , m' , ε)))) ⟩
      w ↑ • ⟦ lm'' ⟧₂ ∎


  Lemma-two-qupit-completeness lm@(case-Ex-| nf1@(s' , m' , c'@(HS^ k')) mc@(m , c@ε) ) (CZ-gen) = lm'' , w'' , claim
    where
    m'⁻¹ = (m' ⁻¹) .proj₁
    m⁻¹ = (m ⁻¹) .proj₁

    a* = m ⁻¹
    a = a* .proj₁

    k′ : ℤ ₚ
    k′ = m'⁻¹

    m'0 = m' .proj₁
    k′⁻¹ = (((m') ⁻¹ ⁻¹) .proj₁)
    -k′⁻¹ = - k′⁻¹
    -k′ = - k′
    -m' = - m'0
    l = - ( m'0 * m⁻¹)

    w = ⟦ m *' (-' m') ⁻¹ ⟧ₘ
    lm' = case-||ₐ (- ( m'0 * m⁻¹)) (s' , (-' m' , ε) , (m' , HS^ k'))
    pf : Postfix
    pf = (s' , (-' m' , ε) , (m' , HS^ k'))
    pf' = (s' + l , (m' , HS^ k') , (-' m' , ε))
    lm'' = case-|| (₁ , λ ()) (- l) pf'
    w'' = w • (S^ l • H ^ 3)
    claim : ⟦ lm ⟧₂ • CZ ≈ w'' ↑ • ⟦ lm'' ⟧₂
    claim = begin
      ⟦ lm ⟧₂ • CZ ≈⟨ (cleft case-duality mc nf1) ⟩
      (⟦ case-| mc nf1 ⟧₂ • Ex) • CZ ≈⟨ assoc ⟩
      ⟦ case-| mc nf1 ⟧₂ • Ex • CZ ≈⟨ (cright sym lemma-comm-Ex-CZ) ⟩
      ⟦ case-| mc nf1 ⟧₂ • CZ • Ex ≈⟨ sym assoc ⟩
      (⟦ case-| mc nf1 ⟧₂ • CZ) • Ex ≈⟨ (cleft step-|-CZ' m k' s' m') ⟩
      (w ↑ • ⟦ lm' ⟧₂) • Ex ≈⟨ assoc ⟩
      w ↑ • ⟦ lm' ⟧₂ • Ex ≈⟨ (cright sym (cleft lemma-Ex-dual' ⟦ lm' ⟧₂)) ⟩
      w ↑ • (Ex • dual ⟦ lm' ⟧₂ • Ex) • Ex ≈⟨ special-assoc (□ • □ ^ 3 • □) (□ ^ 5) auto ⟩
      w ↑ • Ex • dual ⟦ lm' ⟧₂ • Ex • Ex ≈⟨ (cright cright cright lemma-order-Ex) ⟩
      w ↑ • Ex • dual ⟦ lm' ⟧₂ • ε ≈⟨ (cright cright right-unit) ⟩
      w ↑ • Ex • dual ⟦ lm' ⟧₂ ≈⟨ (cright sym (aux-NF2'' l pf)) ⟩
      w ↑ • ((S^ l • H ^ 3)) ↑ • ⟦ case-|| (₁ , λ ()) (- l) pf' ⟧₂ ≈⟨ sym assoc ⟩
      (w ↑ • (S^ l • H ^ 3) ↑) • ⟦ case-|| (₁ , λ ()) (- l) pf' ⟧₂ ≈⟨ refl ⟩
      w'' ↑ • ⟦ lm'' ⟧₂ ∎



  Lemma-two-qupit-completeness lm@(case-Ex-| nf1@(s' , m'*@(m' , nzm') , c'@(HS^ k')) mc@(m*@(m , nzm) , c@(HS^ k)) ) (CZ-gen)  with (m * m') | inspect (\ xx -> xx * m') m
  ... | ₀ | [ ieq ]' = ⊥-elim (aux-mm0 ieq)
    where
    aux-mm0 : (m* *' m'*) .proj₁ ≢ ₀
    aux-mm0 = (m* *' m'*) .proj₂


  ... | ₁ | [ ieq ]' = lm'' , (w • w'') , claim
    where
    open import Zp.Mod-Lemmas p-2 p-prime
    open import Data.Fin.Properties

    m'⁻¹ = (m'* ⁻¹) .proj₁
    m⁻¹ = (m* ⁻¹) .proj₁
    -m'⁻¹ = - m'⁻¹
    m'⁻¹⁻¹ = (m'* ⁻¹ ⁻¹) .proj₁
    -m' = - m'

    a* = m'* ⁻¹
    a = a* .proj₁
    l = m* .proj₁
    -l : ℤ ₚ
    -l = - l
    l⁻¹ : ℤ ₚ
    l⁻¹ = ((m* ⁻¹) .proj₁)
    -l⁻¹ : ℤ ₚ
    -l⁻¹ = - l⁻¹

    k′ : ℤ ₚ
    k′ = m'⁻¹
    a′ = m⁻¹
    m'0 = m'* .proj₁
    k′⁻¹ = (((m'*) ⁻¹ ⁻¹) .proj₁)
    -k′⁻¹ = - k′⁻¹
    -k′ = - k′
    -m'* = - m'0
    y = k

    w = ⟦ m* *' m'* ⟧ₘ
    lm' = case-|| ((m* *' m'*) ⁻¹) (y * (m' * m')) (s' , ((-' m'*) , ε) , (m'* , HS^ k') )

    w'' = H • S^ (y * (m' * m'))
    lm'' = case-||ₐ (- (y * (m' * m'))) (s' + (y * (m' * m')) , (m'* , HS^ k') , ((-' m'*) , ε))

    aux : (((m , nzm) *' (m' , nzm')) ⁻¹) .proj₁ ≡ ₁
    aux = Eq.trans (inv-cong ((m* *' m'*)) (₁ , (λ ())) ieq) inv-₁
    claim : ⟦ lm ⟧₂ • CZ ≈ (w • w'') ↑ • ⟦ lm'' ⟧₂
    claim = begin
      ⟦ lm ⟧₂ • CZ ≈⟨ (cleft case-duality mc nf1) ⟩
      (⟦ case-| mc nf1 ⟧₂ • Ex) • CZ ≈⟨ assoc ⟩
      ⟦ case-| mc nf1 ⟧₂ • Ex • CZ ≈⟨ (cright sym lemma-comm-Ex-CZ) ⟩
      ⟦ case-| mc nf1 ⟧₂ • CZ • Ex ≈⟨ sym assoc ⟩
      (⟦ case-| mc nf1 ⟧₂ • CZ) • Ex ≈⟨ (cleft step-|-CZʰₕ m* k k' s' m'*) ⟩
      (w ↑ • ⟦ lm' ⟧₂) • Ex ≈⟨ (cleft (cright aux-|| (((m* *' m'*) ⁻¹)) ((₁ , λ ())) (y * (m' * m')) ((s' , ((-' m'*) , ε) , (m'* , HS^ k') )) aux )) ⟩
      (w ↑ • ⟦ case-|| (₁ , λ ()) (y * (m' * m')) (s' , ((-' m'*) , ε) , (m'* , HS^ k') ) ⟧₂) • Ex ≈⟨ (cleft (cright aux-NF2′ (y * (m' * m')) ((s' , ((-' m'*) , ε) , (m'* , HS^ k') )))) ⟩
      (w ↑ • w'' ↑ • ⟦ lm'' ⟧₂ • Ex) • Ex ≈⟨ special-assoc (□ ^ 4 • □) (□ ^ 3 • □ ^ 2) auto ⟩
      (w ↑ • w'' ↑ • ⟦ lm'' ⟧₂) • Ex • Ex ≈⟨ (cright lemma-order-Ex) ⟩
      (w ↑ • w'' ↑ • ⟦ lm'' ⟧₂) • ε ≈⟨ right-unit ⟩
      w ↑ • w'' ↑ • ⟦ lm'' ⟧₂ ≈⟨ sym assoc ⟩
      (w • w'') ↑ • ⟦ lm'' ⟧₂ ∎



  ... | ₁₊ (₁₊ hyp) | [ ieq ]' = lm'' , (w • w'') , claim
    where
    open import Data.Fin.Properties
    aux-mm0 : (m* *' m'*) .proj₁ ≡ ₁₊ (₁₊ hyp)
    aux-mm0 = ieq
    aux-mm0' : (m* *' m'*) .proj₁ ≢ ₁
    aux-mm0' eq1 = 0≢1+n (suc-injective ccc)
      where
      ccc : ₁₊ ₀ ≡ ₁₊ (₁₊ hyp)
      ccc = Eq.trans (Eq.sym eq1) ieq
    nzmm : ((m* *' m'*) ⁻¹) .proj₁ ≢ ₁
    nzmm  = aux-k*≠1⇒k⁻¹≠1 (m* *' m'*) aux-mm0'

    m'⁻¹ = (m'* ⁻¹) .proj₁
    m⁻¹ = (m* ⁻¹) .proj₁
    -m'⁻¹ = - m'⁻¹
    m'⁻¹⁻¹ = (m'* ⁻¹ ⁻¹) .proj₁
    -m' = - m'

    a* = m'* ⁻¹
    a = a* .proj₁
    l = m* .proj₁
    -l : ℤ ₚ
    -l = - l
    l⁻¹ : ℤ ₚ
    l⁻¹ = ((m* ⁻¹) .proj₁)
    -l⁻¹ : ℤ ₚ
    -l⁻¹ = - l⁻¹

    k′ : ℤ ₚ
    k′ = m'⁻¹
    a′ = m⁻¹
    m'0 = m'* .proj₁
    k′⁻¹ = (((m'*) ⁻¹ ⁻¹) .proj₁)
    -k′⁻¹ = - k′⁻¹
    -k′ = - k′
    -m'* = - m'0
    y = k

    w = ⟦ m* *' m'* ⟧ₘ
    lm' = case-|| ((m* *' m'*) ⁻¹) (y * (m' * m')) (s' , ((-' m'*) , ε) , (m'* , HS^ k') )

    ||-Ex = aux-NF2-Ex ((m* *' m'*) ⁻¹) (y * (m' * m')) (s' , ((-' m'*) , ε) , (m'* , HS^ k') ) nzmm
    w'' = ||-Ex .proj₁ 
    lm'' = ||-Ex .proj₂ .proj₁ 
    claim : ⟦ lm ⟧₂ • CZ ≈ (w • w'') ↑ • ⟦ lm'' ⟧₂
    claim = begin
      ⟦ lm ⟧₂ • CZ ≈⟨ (cleft case-duality mc nf1) ⟩
      (⟦ case-| mc nf1 ⟧₂ • Ex) • CZ ≈⟨ assoc ⟩
      ⟦ case-| mc nf1 ⟧₂ • Ex • CZ ≈⟨ (cright sym lemma-comm-Ex-CZ) ⟩
      ⟦ case-| mc nf1 ⟧₂ • CZ • Ex ≈⟨ sym assoc ⟩
      (⟦ case-| mc nf1 ⟧₂ • CZ) • Ex ≈⟨ (cleft step-|-CZʰₕ m* k k' s' m'*) ⟩
      (w ↑ • ⟦ lm' ⟧₂) • Ex ≈⟨ (cleft (cright ||-Ex .proj₂ .proj₂)) ⟩
      (w ↑ • w'' ↑ • ⟦ lm'' ⟧₂ • Ex) • Ex ≈⟨ special-assoc (□ ^ 4 • □) (□ ^ 3 • □ ^ 2) auto ⟩
      (w ↑ • w'' ↑ • ⟦ lm'' ⟧₂) • Ex • Ex ≈⟨ (cright lemma-order-Ex) ⟩
      (w ↑ • w'' ↑ • ⟦ lm'' ⟧₂) • ε ≈⟨ right-unit ⟩
      w ↑ • w'' ↑ • ⟦ lm'' ⟧₂ ≈⟨ sym assoc ⟩
      (w • w'') ↑ • ⟦ lm'' ⟧₂ ∎





  Lemma-two-qupit-completeness (case-| mc@(m , c@(HS^ k)) nf1@(s' , m' , c'@ε)) (CZ-gen) = case-| mc1' (-l * a + s' , m' , ε) , w , step-|-CZ m k s' m'
    where
    m⁻¹ = (m ⁻¹) .proj₁
    m'⁻¹ = (m' ⁻¹) .proj₁
    mf = m .proj₁
    a* = m ⁻¹
    a = a* .proj₁
    l = m' .proj₁
    -l : ℤ ₚ
    -l = - l
    l⁻¹ : ℤ ₚ
    l⁻¹ = ((m' ⁻¹) .proj₁)
    -l⁻¹ : ℤ ₚ
    -l⁻¹ = - l⁻¹


    s1' = - mf * m'⁻¹
    mc1' =  m , HS^ (- (m' *' m) .proj₁ + k)
    nf1' = (s1' , mc1')

    w = ⟦ - mf * m'⁻¹ ,  m *' m' ⁻¹ , HS^ (- mf * m'⁻¹) ⟧₁
    lm' = case-| mc1' (-l * a + s' , m' , ε)



  Lemma-two-qupit-completeness (case-| mc@(m , c@ε) nf1@(s' , m' , c'@(HS^ k'))) (CZ-gen) = case-||ₐ (- ( m'0 * m⁻¹)) (s' , (-' m' , ε) , (m' , HS^ k')) , ⟦ m *' (-' m') ⁻¹ ⟧ₘ , claim
    where
    m'⁻¹ = (m' ⁻¹) .proj₁
    m⁻¹ = (m ⁻¹) .proj₁
    a* = m' ⁻¹
    a = a* .proj₁
    l = m .proj₁
    -l : ℤ ₚ
    -l = - l
    l⁻¹ : ℤ ₚ
    l⁻¹ = ((m ⁻¹) .proj₁)
    -l⁻¹ : ℤ ₚ
    -l⁻¹ = - l⁻¹

    k′ : ℤ ₚ
    k′ = m'⁻¹
    a′ = m⁻¹
    m'0 = m' .proj₁
    k′⁻¹ = (((m') ⁻¹ ⁻¹) .proj₁)
    -k′⁻¹ = - k′⁻¹
    -k′ = - k′
    -m' = - m'0

    claim : ⟦ case-| (m , ε) (s' , m' , HS^ k') ⟧₂ • CZ ≈ (⟦ m *' (-' m') ⁻¹ ⟧ₘ ) ↑ • ⟦ case-||ₐ (- ( m'0 * m⁻¹)) (s' , (-' m' , ε) , (m' , HS^ k')) ⟧₂
    claim = step-|-CZ' m k' s' m'



  Lemma-two-qupit-completeness (case-| mc@(m*@(m , nzm) , c@(HS^ k)) nf1@(s' , m'*@(m' , nzm') , c'@(HS^ k'))) (CZ-gen) = lm' , ⟦ m* *' m'* ⟧ₘ , step-|-CZʰₕ m* k k' s' m'*

    where

    m'⁻¹ = (m'* ⁻¹) .proj₁
    m⁻¹ = (m* ⁻¹) .proj₁
    -m'⁻¹ = - m'⁻¹
    m'⁻¹⁻¹ = (m'* ⁻¹ ⁻¹) .proj₁
    -m' = - m'

    a* = m'* ⁻¹
    a = a* .proj₁
    l = m* .proj₁
    -l : ℤ ₚ
    -l = - l
    l⁻¹ : ℤ ₚ
    l⁻¹ = ((m* ⁻¹) .proj₁)
    -l⁻¹ : ℤ ₚ
    -l⁻¹ = - l⁻¹

    k′ : ℤ ₚ
    k′ = m'⁻¹
    a′ = m⁻¹
    m'0 = m'* .proj₁
    k′⁻¹ = (((m'*) ⁻¹ ⁻¹) .proj₁)
    -k′⁻¹ = - k′⁻¹
    -k′ = - k′
    -m'* = - m'0
    y = k
    lm' = case-|| ((m* *' m'*) ⁻¹) (y * (m' * m')) (s' , ((-' m'*) , ε) , (m'* , HS^ k') )



  Lemma-two-qupit-completeness (case-| mc@(m , c@ε) nf1@(s' , m' , c'@ε)) (CZ-gen) with ((m ⁻¹) .proj₁ + m' .proj₁) | inspect (\ m -> ((m ⁻¹) .proj₁ + m' .proj₁)) m
  ... | ₀ | [ eq ]' = case-nf1 (s' , m' , ε) , ⟦ m ⟧ₘ , step-|-CZa m s' m' eq
  ... | (₁₊ mm) | [ eq ]' = let aa = ((m ⁻¹) .proj₁ + m' .proj₁) in case-| ((aa , neq) ⁻¹ , ε) (s' , m' , ε) , ⟦ m ⟧ₘ • M (aa , neq) , step-|-CZb m s' m' neq
    where
    neq : ((m ⁻¹) .proj₁ + m' .proj₁) ≢ ₀
    neq ee with Eq.trans (Eq.sym ee) eq
    ... | ()



  Lemma-two-qupit-completeness (case-nf1 nf1@(s , m , c@ε)) (CZ-gen) = case-| (m ⁻¹ , ε) nf1 , M m , claim
    where
    claim : ⟦ case-nf1 (s , m , ε) ⟧₂ • [ CZ-gen ]ʷ ≈ (M m ↑) • ⟦ case-| (m ⁻¹ , ε) (s , m , ε) ⟧₂
    claim = begin
       ⟦ case-nf1 (s , m , ε) ⟧₂ • [ CZ-gen ]ʷ ≈⟨ trans assoc (cong refl assoc) ⟩
       ⟦ s ⟧ₛ • ⟦ m ⟧ₘ • ⟦ c ⟧ₕₛ • CZ ≈⟨ cong refl (cong refl left-unit) ⟩
       ⟦ s ⟧ₛ • ⟦ m ⟧ₘ • CZ ≈⟨ (cright axiom (semi-M↓CZ m)) ⟩
       ⟦ s ⟧ₛ • CZ^ (m ^1) • ⟦ m ⟧ₘ ≈⟨ sym assoc ⟩
       (⟦ s ⟧ₛ • CZ^ (m ^1)) • ⟦ m ⟧ₘ ≈⟨ (cleft word-comm (toℕ s) (toℕ (m ^1)) (sym (axiom comm-CZ-S↓))) ⟩
       (CZ^ (m ^1) • ⟦ s ⟧ₛ) • ⟦ m ⟧ₘ ≈⟨ assoc ⟩
       CZ^ (m ^1) • ⟦ s ⟧ₛ • ⟦ m ⟧ₘ ≈⟨ sym left-unit ⟩
       ε ↑ • CZ^ (m ^1) • ⟦ s ⟧ₛ • ⟦ m ⟧ₘ ≈⟨ (cleft lemma-cong↑ _ _ L0.lemma-M1) ⟩
       M₁ ↑ • CZ^ (m ^1) • ⟦ s ⟧ₛ • ⟦ m ⟧ₘ ≈⟨ (cleft lemma-cong↑ _ _ (L0.aux-MM (λ ()) ((m *' (m ⁻¹)) .proj₂) (Eq.sym (lemma-⁻¹ʳ (m ^1) {{nztoℕ {y = m ^1} {neq0 = m .proj₂}}})))) ⟩
       M (m *' (m ⁻¹)) ↑ • CZ^ (m ^1) • ⟦ s ⟧ₛ • ⟦ m ⟧ₘ ≈⟨ sym (cleft lemma-cong↑ _ _ (PB1.axiom (M-mul m (m ⁻¹)))) ⟩
       (M m ↑ • M (m ⁻¹) ↑) • CZ^ (m ^1) • ⟦ s ⟧ₛ • ⟦ m ⟧ₘ ≈⟨ special-assoc (□ ^ 2 • □ ^ 3) (□ • □ ^ 2 • □ ^ 2) auto ⟩
       M m ↑ • (M (m ⁻¹) ↑ • CZ^ (m ^1)) • ⟦ s ⟧ₛ • ⟦ m ⟧ₘ ≈⟨ (cright cleft lemma-M↑CZ^k ((m ⁻¹) .proj₁) (m ^1) ((m ⁻¹) .proj₂)) ⟩
       M m ↑ • (CZ^ (m ^1 * (m ⁻¹) .proj₁) • M (m ⁻¹) ↑) • ⟦ s ⟧ₛ • ⟦ m ⟧ₘ ≈⟨ (cright cleft (cleft refl' (Eq.cong CZ^ ((lemma-⁻¹ʳ (m ^1) {{nztoℕ {y = m ^1} {neq0 = m .proj₂}}}))))) ⟩
       M m ↑ • (CZ • M (m ⁻¹) ↑) • ⟦ s ⟧ₛ • ⟦ m ⟧ₘ ≈⟨ special-assoc (□ • □ ^ 2 • □) (□ ^ 4) auto ⟩
       M m ↑ • CZ • M (m ⁻¹) ↑ • ⟦ s ⟧ₛ • ⟦ m ⟧ₘ ≈⟨ (cright cright cong (sym right-unit) (cright sym right-unit)) ⟩
       M m ↑ • CZ • (M (m ⁻¹) ↑ • ε) • ⟦ s ⟧ₛ • (⟦ m ⟧ₘ • ε) ≈⟨ refl ⟩
       M m ↑ • ⟦ case-| (m ⁻¹ , ε) (s , m , ε) ⟧₂ ∎


  Lemma-two-qupit-completeness (case-nf1 (s , m , c@(HS^ k))) (CZ-gen) = case-||ₐ ₀ (s , (-' m , ε) , (m , c)) , (M (m ⁻¹) • H ^ 2) , claim
    where
    claim : ⟦ case-nf1 (s , m , HS^ k) ⟧₂ • CZ ≈ (M (m ⁻¹) • H ^ 2) ↑ • ⟦ case-||ₐ ₀ (s , (-' m , ε) , (m , c)) ⟧₂
    claim = step-nf1-CZ s m k

  Lemma-two-qupit-completeness (case-Ex-nf1 nf1@(s , m , c@ε)) (CZ-gen) = case-Ex-| nf1 (m ⁻¹ , ε) , M m , claim
    where
    claim : ⟦ case-Ex-nf1 (s , m , ε) ⟧₂ • CZ ≈ (M m ↑) • ⟦ case-Ex-| nf1 (m ⁻¹ , ε) ⟧₂
    claim = begin
      ⟦ case-Ex-nf1 (s , m , ε) ⟧₂ • CZ ≈⟨ special-assoc (□ ^ 4 • □) (□ ^ 5) auto ⟩
      Ex • ⟦ s ⟧ₛ ↑ • ⟦ m ⟧ₘ ↑ • ⟦ c ⟧ₕₛ ↑ • CZ ≈⟨ cright cong refl (cong refl left-unit) ⟩
      Ex • ⟦ s ⟧ₛ ↑ • ⟦ m ⟧ₘ ↑ • CZ ≈⟨ cright (cright axiom (semi-M↑CZ m)) ⟩
      Ex • ⟦ s ⟧ₛ ↑ • CZ^ (m ^1) • ⟦ m ⟧ₘ ↑ ≈⟨ cright sym assoc ⟩
      Ex • (⟦ s ⟧ₛ ↑ • CZ^ (m ^1)) • ⟦ m ⟧ₘ ↑ ≈⟨ cright (cleft (cleft sym (refl' (aux-↑ S (toℕ s))))) ⟩
      Ex • (S ↑ ^ toℕ s • CZ^ (m ^1)) • ⟦ m ⟧ₘ ↑ ≈⟨ cright (cleft word-comm (toℕ s) (toℕ (m ^1)) (sym (axiom comm-CZ-S↑))) ⟩
      Ex • (CZ^ (m ^1) • S ↑ ^ toℕ s) • ⟦ m ⟧ₘ ↑ ≈⟨ cright assoc ⟩
      Ex • CZ^ (m ^1) • S ↑ ^ toℕ s • ⟦ m ⟧ₘ ↑ ≈⟨ cright sym left-unit ⟩
      Ex • ε  • CZ^ (m ^1) • S ↑ ^ toℕ s • ⟦ m ⟧ₘ ↑ ≈⟨ cright (cleft sym (aux-M-mul m)) ⟩
      Ex • (M m  • M (m ⁻¹) ) • CZ^ (m ^1) • S ↑ ^ toℕ s • ⟦ m ⟧ₘ ↑ ≈⟨ cright special-assoc (□ ^ 2 • □ ^ 3) (□ • □ ^ 2 • □ ^ 2) auto ⟩
      Ex • M m  • (M (m ⁻¹)  • CZ^ (m ^1)) • S ↑ ^ toℕ s • ⟦ m ⟧ₘ ↑ ≈⟨ cright (cright cleft lemma-M↓CZ^k ((m ⁻¹) .proj₁) (m ^1) ((m ⁻¹) .proj₂)) ⟩
      Ex • M m  • (CZ^ (m ^1 * (m ⁻¹) .proj₁) • M (m ⁻¹) ) • S ↑ ^ toℕ s • ⟦ m ⟧ₘ ↑ ≈⟨ cright (cright cleft (cleft refl' (Eq.cong CZ^ ((lemma-⁻¹ʳ (m ^1) {{nztoℕ {y = m ^1} {neq0 = m .proj₂}}}))))) ⟩
      Ex • M m  • (CZ • M (m ⁻¹) ) • S ↑ ^ toℕ s • ⟦ m ⟧ₘ ↑ ≈⟨ cright special-assoc (□ • □ ^ 2 • □) (□ ^ 4) auto ⟩
      Ex • M m  • CZ • (M (m ⁻¹) ) • S ↑ ^ toℕ s • (⟦ m ⟧ₘ ↑) ≈⟨ sym assoc ⟩
      (Ex • M m)  • CZ • (M (m ⁻¹) ) • S ↑ ^ toℕ s • (⟦ m ⟧ₘ ↑) ≈⟨ (cleft lemma-Ex-M m) ⟩
      (M m ↑ • Ex) • CZ • (M (m ⁻¹) ) • S ↑ ^ toℕ s • (⟦ m ⟧ₘ ↑) ≈⟨ special-assoc (□ ^ 2 • □ ^ 4) (□ • □ • □ • □ ^ 2 • □) auto ⟩
      M m ↑ • Ex • CZ • (M (m ⁻¹) • S ↑ ^ toℕ s) • ⟦ m ⟧ₘ ↑ ≈⟨ (cright cright cright cleft word-comm 1 (toℕ s) (aux-comm-m-S↑ (m ⁻¹))) ⟩
      M m ↑ • Ex • CZ • (S ↑ ^ toℕ s • M (m ⁻¹)) • ⟦ m ⟧ₘ ↑ ≈⟨ (cright cright cright assoc) ⟩
      M m ↑ • Ex • CZ • S ↑ ^ toℕ s • M (m ⁻¹) • ⟦ m ⟧ₘ ↑ ≈⟨ (cright cright cright cright aux-comm-MM (m ⁻¹) m) ⟩
      M m ↑ • Ex • CZ • S ↑ ^ toℕ s • ⟦ m ⟧ₘ ↑ • M (m ⁻¹) ≈⟨ (cright cright cright (cleft refl' (aux-↑ S (toℕ s)))) ⟩
      M m ↑ • Ex • CZ • S^ s ↑ • ⟦ m ⟧ₘ ↑ • M (m ⁻¹) ≈⟨ (cright cright cright sym assoc) ⟩
      M m ↑ • Ex • CZ • (S^ s ↑ • ⟦ m ⟧ₘ ↑) • M (m ⁻¹) ≈⟨ (cright cright cright (cleft cong refl (sym right-unit))) ⟩
      M m ↑ • Ex • CZ • (S^ s ↑ • ⟦ m ⟧ₘ ↑ • ε) • M (m ⁻¹) ≈⟨ (cright cright cright cright sym right-unit) ⟩
      M m ↑ • Ex • CZ • (S^ s ↑ • ⟦ m ⟧ₘ ↑ • ε) • (M (m ⁻¹) • ε) ≈⟨ refl ⟩
      M m ↑ • ⟦ case-Ex-| nf1 (m ⁻¹ , ε) ⟧₂ ∎



  Lemma-two-qupit-completeness (case-Ex-nf1 nf1@(s , m , c@(HS^ k))) (CZ-gen) = case-|| (₁ , λ ()) ₀ (s , (m , HS^ k) , (-' m , ε)) , M (m ⁻¹) • H , claim
    where
    claim : ⟦ case-Ex-nf1 (s , m , c) ⟧₂ • CZ ≈ (M (m ⁻¹) • H) ↑ • ⟦ case-|| (₁ , λ ()) ₀ (s , (m , HS^ k) , (-' m , ε))  ⟧₂
    claim = begin
      ⟦ case-Ex-nf1 (s , m , c) ⟧₂ • CZ ≈⟨ assoc ⟩
      Ex • ⟦ nf1 ⟧₁ ↑ • CZ ≈⟨ (cright refl' (lemma-double-dual (⟦ nf1 ⟧₁ ↑ • CZ))) ⟩
      Ex • dual (dual (⟦ nf1 ⟧₁ ↑ • CZ)) ≈⟨ (cright refl' (Eq.cong (\ xx -> dual (xx • CZ)) (ND.aux-dual-SMC↑ nf1))) ⟩
      Ex • dual (⟦ nf1 ⟧₁ • CZ) ≈⟨ (cright by-duality (step-nf1-CZ s m k)) ⟩
      Ex • dual ((M (m ⁻¹) • H ^ 2) ↑ • ⟦ case-||ₐ ₀ (s , (-' m , ε) , (m , HS^ k)) ⟧₂) ≈⟨ (cright (cleft (cleft refl' (ND.aux-dual-M↑ (m ⁻¹))))) ⟩
      Ex • ((M (m ⁻¹) • H ^ 2) • dual ⟦ case-||ₐ ₀ (s , (-' m , ε) , (m , HS^ k)) ⟧₂) ≈⟨ trans (by-assoc auto) assoc ⟩
      (Ex • M (m ⁻¹)) • H ^ 2 • dual ⟦ case-||ₐ ₀ (s , (-' m , ε) , (m , HS^ k)) ⟧₂ ≈⟨ (cleft lemma-Ex-M (m ⁻¹)) ⟩
      (M (m ⁻¹) ↑ • Ex) • H ^ 2 • dual ⟦ case-||ₐ ₀ (s , (-' m , ε) , (m , HS^ k)) ⟧₂ ≈⟨ special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ⟩
      M (m ⁻¹) ↑ • (Ex • H ^ 2) • dual ⟦ case-||ₐ ₀ (s , (-' m , ε) , (m , HS^ k)) ⟧₂ ≈⟨ (cright cleft lemma-Induction (sym lemma-comm-Ex-H) 2) ⟩
      M (m ⁻¹) ↑ • (H ↑ ^ 2 • Ex) • dual ⟦ case-||ₐ ₀ (s , (-' m , ε) , (m , HS^ k)) ⟧₂ ≈⟨ (cright assoc) ⟩
      M (m ⁻¹) ↑ • H ↑ ^ 2 • Ex • dual ⟦ case-||ₐ ₀ (s , (-' m , ε) , (m , HS^ k)) ⟧₂ ≈⟨ (cright cright cright sym (refl' (Eq.cong₂ (\ xx yy -> dual ⟦ case-||ₐ xx (yy , (-' m , ε) , (m , HS^ k)) ⟧₂) -0#≈0# (+-identityʳ s)))) ⟩
      M (m ⁻¹) ↑ • H ↑ ^ 2 • Ex • dual ⟦ case-||ₐ (- ₀) (s + ₀ , (-' m , ε) , (m , HS^ k)) ⟧₂ ≈⟨ (cright cright sym (aux-NF2' ₀ (s , (m , HS^ k) , (-' m , ε)))) ⟩
      M (m ⁻¹) ↑ • H ↑ ^ 2 • (S^ (- ₀) • H ^ 3) ↑ • ⟦ case-|| (₁ , λ ()) ₀ (s , (m , HS^ k) , (-' m , ε))  ⟧₂ ≈⟨ (cright cright cleft (cleft refl' (Eq.cong (\ xx -> S^ xx ↑) -0#≈0#))) ⟩
      M (m ⁻¹) ↑ • H ↑ ^ 2 • (S^ ₀ • H ^ 3) ↑ • ⟦ case-|| (₁ , λ ()) ₀ (s , (m , HS^ k) , (-' m , ε))  ⟧₂ ≈⟨ rewrite-sym0 100 auto ⟩
      M (m ⁻¹) ↑ • (H ↑ ^ 2 • (S^ ₀ • H ^ 3) ↑) • ⟦ case-|| (₁ , λ ()) ₀ (s , (m , HS^ k) , (-' m , ε))  ⟧₂ ≈⟨ (cright cleft rewrite-sym0 100 auto) ⟩
      M (m ⁻¹) ↑ • H ↑ • ⟦ case-|| (₁ , λ ()) ₀ (s , (m , HS^ k) , (-' m , ε))  ⟧₂ ≈⟨ sym assoc ⟩
      (M (m ⁻¹) • H) ↑ • ⟦ case-|| (₁ , λ ()) ₀ (s , (m , HS^ k) , (-' m , ε))  ⟧₂ ∎




  Lemma-two-qupit-completeness (case-||ₐ cz pf@(s , mc1 , mc0)) (H-gen) = lm' , S^ sk , claim
    where

    sq = Lemma-Postfix-SingleQ pf H-gen tt
    czk = sq .proj₁
    sk = sq .proj₂ .proj₁
    pf' = sq .proj₂ .proj₂ .proj₁
    cz' = cz + czk
    lm' = case-||ₐ cz' pf'
    claim : ⟦ case-||ₐ cz (s , mc1 , mc0) ⟧₂ • H ≈ (S^ sk ↑) • ⟦ lm' ⟧₂
    claim = begin
      ⟦ case-||ₐ cz pf ⟧₂ • H ≈⟨ assoc ⟩
      CZ^ cz • ⟦ pf ⟧ₚ • H ≈⟨ (cright sq .proj₂ .proj₂ .proj₂) ⟩
      CZ^ cz • CZ^ czk • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ sym assoc ⟩
      (CZ^ cz • CZ^ czk) • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ (cleft lemma-CZ^k+l cz czk) ⟩
      CZ^ (cz + czk) • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ sym assoc ⟩
      (CZ^ (cz + czk) • S^ sk ↑) • ⟦ pf' ⟧ₚ ≈⟨ (cleft aux-comm-CZ^a-S^b↑ (cz + czk) sk) ⟩
      (S^ sk ↑ • CZ^ (cz + czk)) • ⟦ pf' ⟧ₚ ≈⟨ assoc ⟩
      (S^ sk ↑) • ⟦ lm' ⟧₂ ∎

  Lemma-two-qupit-completeness (case-||ₐ cz pf) (S-gen) = lm' , S^ sk , claim
    where
    sq = Lemma-Postfix-SingleQ pf S-gen tt
    czk = sq .proj₁
    sk = sq .proj₂ .proj₁
    pf' = sq .proj₂ .proj₂ .proj₁
    cz' = cz + czk
    lm' = case-||ₐ cz' pf'
    claim : ⟦ case-||ₐ cz pf ⟧₂ • S ≈ (S^ sk ↑) • ⟦ lm' ⟧₂
    claim = begin
      ⟦ case-||ₐ cz pf ⟧₂ • S ≈⟨ assoc ⟩
      CZ^ cz • ⟦ pf ⟧ₚ • S ≈⟨ (cright sq .proj₂ .proj₂ .proj₂) ⟩
      CZ^ cz • CZ^ czk • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ sym assoc ⟩
      (CZ^ cz • CZ^ czk) • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ (cleft lemma-CZ^k+l cz czk) ⟩
      CZ^ (cz + czk) • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ sym assoc ⟩
      (CZ^ (cz + czk) • S^ sk ↑) • ⟦ pf' ⟧ₚ ≈⟨ (cleft aux-comm-CZ^a-S^b↑ (cz + czk) sk) ⟩
      (S^ sk ↑ • CZ^ (cz + czk)) • ⟦ pf' ⟧ₚ ≈⟨ assoc ⟩
      (S^ sk ↑) • ⟦ lm' ⟧₂ ∎

  Lemma-two-qupit-completeness (case-||ₐ cz pf) (H-gen ↥) = lm' , S^ sk , claim
    where
    sq = Lemma-Postfix-SingleQ pf (H-gen ↥) tt
    czk = sq .proj₁
    sk = sq .proj₂ .proj₁
    pf' = sq .proj₂ .proj₂ .proj₁
    cz' = cz + czk
    lm' = case-||ₐ cz' pf'
    claim : ⟦ case-||ₐ cz pf ⟧₂ • H ↑ ≈ (S^ sk ↑) • ⟦ lm' ⟧₂
    claim = begin
      ⟦ case-||ₐ cz pf ⟧₂ • H ↑ ≈⟨ assoc ⟩
      CZ^ cz • ⟦ pf ⟧ₚ • H ↑ ≈⟨ (cright sq .proj₂ .proj₂ .proj₂) ⟩
      CZ^ cz • CZ^ czk • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ sym assoc ⟩
      (CZ^ cz • CZ^ czk) • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ (cleft lemma-CZ^k+l cz czk) ⟩
      CZ^ (cz + czk) • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ sym assoc ⟩
      (CZ^ (cz + czk) • S^ sk ↑) • ⟦ pf' ⟧ₚ ≈⟨ (cleft aux-comm-CZ^a-S^b↑ (cz + czk) sk) ⟩
      (S^ sk ↑ • CZ^ (cz + czk)) • ⟦ pf' ⟧ₚ ≈⟨ assoc ⟩
      (S^ sk ↑) • ⟦ lm' ⟧₂ ∎

  Lemma-two-qupit-completeness (case-||ₐ cz pf) (S-gen ↥) = lm' , S^ sk , claim
    where
    sq = Lemma-Postfix-SingleQ pf (S-gen ↥) tt
    czk = sq .proj₁
    sk = sq .proj₂ .proj₁
    pf' = sq .proj₂ .proj₂ .proj₁
    cz' = cz + czk
    lm' = case-||ₐ cz' pf'
    claim : ⟦ case-||ₐ cz pf ⟧₂ • S ↑ ≈ (S^ sk ↑) • ⟦ lm' ⟧₂
    claim = begin
      ⟦ case-||ₐ cz pf ⟧₂ • S ↑ ≈⟨ assoc ⟩
      CZ^ cz • ⟦ pf ⟧ₚ • S ↑ ≈⟨ (cright sq .proj₂ .proj₂ .proj₂) ⟩
      CZ^ cz • CZ^ czk • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ sym assoc ⟩
      (CZ^ cz • CZ^ czk) • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ (cleft lemma-CZ^k+l cz czk) ⟩
      CZ^ (cz + czk) • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ sym assoc ⟩
      (CZ^ (cz + czk) • S^ sk ↑) • ⟦ pf' ⟧ₚ ≈⟨ (cleft aux-comm-CZ^a-S^b↑ (cz + czk) sk) ⟩
      (S^ sk ↑ • CZ^ (cz + czk)) • ⟦ pf' ⟧ₚ ≈⟨ assoc ⟩
      (S^ sk ↑) • ⟦ lm' ⟧₂ ∎



  Lemma-two-qupit-completeness (case-|| (cz , nz) l pf) (H-gen ↥) with Lemma-Postfix-SingleQ-H↑ pf
  ... | (sk , pf' ,  peq)  = lm' , ε , claim
    where
    lm' = case-|| (cz , nz) (l + sk) pf'
    claim : ⟦ case-|| (cz , nz) l pf ⟧₂ • H ↑ ≈ ε • ⟦ lm' ⟧₂
    claim 
      = begin
      ⟦ case-|| (cz , nz) l pf ⟧₂ • H ↑ ≈⟨ special-assoc (□ ^ 4 • □) (□ ^ 5) auto ⟩
      CZ^ cz • H^ ₃ ↑ • S^ l ↑ • ⟦ pf ⟧ₚ • H ↑ ≈⟨ (cright cright cright peq) ⟩
      CZ^ cz • H^ ₃ ↑ • S^ l ↑ • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ (cright cright  sym assoc) ⟩
      CZ^ cz • H^ ₃ ↑ • (S^ l ↑ • S^ sk ↑) • ⟦ pf' ⟧ₚ ≈⟨ (cright cright cleft lemma-cong↑ _ _ (L0.lemma-S^k+l l sk)) ⟩
      CZ^ cz • H^ ₃ ↑ • S^ (l + sk) ↑ • ⟦ pf' ⟧ₚ ≈⟨ sym left-unit ⟩
      ε • ⟦ lm' ⟧₂ ∎

  Lemma-two-qupit-completeness (case-|| (cz , nz) l pf) (S-gen ↥) with Lemma-Postfix-SingleQ-S↑ pf
  ... | (sk , pf' ,  peq)  = lm' , ε , claim
    where
    lm' = case-|| (cz , nz) (l + sk) pf'
    claim : ⟦ case-|| (cz , nz) l pf ⟧₂ • S ↑ ≈ ε • ⟦ lm' ⟧₂
    claim 
      = begin
      ⟦ case-|| (cz , nz) l pf ⟧₂ • S ↑ ≈⟨ special-assoc (□ ^ 4 • □) (□ ^ 5) auto ⟩
      CZ^ cz • H^ ₃ ↑ • S^ l ↑ • ⟦ pf ⟧ₚ • S ↑ ≈⟨ (cright cright cright peq) ⟩
      CZ^ cz • H^ ₃ ↑ • S^ l ↑ • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ (cright cright  sym assoc) ⟩
      CZ^ cz • H^ ₃ ↑ • (S^ l ↑ • S^ sk ↑) • ⟦ pf' ⟧ₚ ≈⟨ (cright cright cleft lemma-cong↑ _ _ (L0.lemma-S^k+l l sk)) ⟩
      CZ^ cz • H^ ₃ ↑ • S^ (l + sk) ↑ • ⟦ pf' ⟧ₚ ≈⟨ sym left-unit ⟩
      ε • ⟦ lm' ⟧₂ ∎


  Lemma-two-qupit-completeness (case-|| (cz , nz) l pf@(k , mc1 , (m , HS^ cc))) (S-gen) = lm' , ε , claim
    where
    mc0 : MC
    mc0 = (m , HS^ cc)
    mc0' : MC
    mc0' = (m , HS^ (1ₚ + cc))

    pf' = (k , mc1 , mc0')
    lm' = case-|| (cz , nz) l (k , mc1 , mc0')
    claim : ⟦ case-|| (cz , nz) l pf ⟧₂ • S ≈ ε • ⟦ lm' ⟧₂
    claim 
      = begin
      ⟦ case-|| (cz , nz) l pf ⟧₂ • S ≈⟨ special-assoc (□ ^ 4 • □) (□ ^ 5) auto ⟩
      CZ^ cz • H^ ₃ ↑ • S^ l ↑ • ⟦ pf ⟧ₚ • S ≈⟨ (cright cright cright Lemma-Postfix-SingleQ-S-HS k mc1 m cc) ⟩
      CZ^ cz • H^ ₃ ↑ • S^ l ↑ • ⟦ pf' ⟧ₚ ≈⟨ sym left-unit ⟩
      ε • ⟦ lm' ⟧₂ ∎

  Lemma-two-qupit-completeness (case-|| (cz , nz) l pf@(k , mc1 , (m , ε))) (H-gen) = lm' , ε , claim
    where

    mc0' = (m , HS^ ₀)

    pf' = (k , mc1 , mc0')
    lm' = case-|| (cz , nz) l (k , mc1 , mc0')
    claim : ⟦ case-|| (cz , nz) l pf ⟧₂ • H ≈ ε • ⟦ lm' ⟧₂
    claim 
      = begin
      ⟦ case-|| (cz , nz) l pf ⟧₂ • H ≈⟨ special-assoc (□ ^ 4 • □) (□ ^ 5) auto ⟩
      CZ^ cz • H^ ₃ ↑ • S^ l ↑ • ⟦ pf ⟧ₚ • H ≈⟨ (cright cright cright Lemma-Postfix-SingleQ-H-ε k mc1 m) ⟩
      CZ^ cz • H^ ₃ ↑ • S^ l ↑ • ⟦ pf' ⟧ₚ ≈⟨ sym left-unit ⟩
      ε • ⟦ lm' ⟧₂ ∎

  Lemma-two-qupit-completeness (case-|| (cz , nz) l pf@(k , mc1 , (m , HS^ ₀))) (H-gen) = lm' , ε , claim
    where

    mc0' = (m *' -'₁ , ε)

    pf' = (k , mc1 , mc0')
    lm' = case-|| (cz , nz) l (k , mc1 , mc0')
    claim : ⟦ case-|| (cz , nz) l pf ⟧₂ • H ≈ ε • ⟦ lm' ⟧₂
    claim 
      = begin
      ⟦ case-|| (cz , nz) l pf ⟧₂ • H ≈⟨ special-assoc (□ ^ 4 • □) (□ ^ 5) auto ⟩
      CZ^ cz • H^ ₃ ↑ • S^ l ↑ • ⟦ pf ⟧ₚ • H ≈⟨ (cright cright cright Lemma-Postfix-SingleQ-H-HS⁰ k mc1 m) ⟩
      CZ^ cz • H^ ₃ ↑ • S^ l ↑ • ⟦ pf' ⟧ₚ ≈⟨ sym left-unit ⟩
      ε • ⟦ lm' ⟧₂ ∎



  Lemma-two-qupit-completeness (case-|| cz*@(cz , nz) l pf@(kk , mc1 , (m , ε))) (S-gen) = lm' , (S^ (k⁻¹ * a) • H • M -b⁻¹* • S^ -b • H ^ 2) , claim
    where
    mc0' = (m , ε)

    pf' = (kk + m ^2 , mc1 , mc0')

    a* : ℤ* ₚ
    a* = (cz , nz)
    k* : ℤ* ₚ
    k* = -' (m *' m)
    k = - m ^2
    czk = k
    sk = m ^2
    k⁻¹ = (k* ⁻¹) .proj₁
    a = cz
    -k = - k
    -k⁻¹ = - k⁻¹
    b' = -' (k* ⁻¹) *' a*
    b = b' .proj₁
    -b = - b
    -b⁻¹* =  -' b' ⁻¹
    -b⁻¹ =  -b⁻¹* .proj₁
    ss = kk + m ^2
    pf'' = (k * a + (kk + m ^2) , mc1 , mc0')
    mc0 = mc0'
    lm' = case-|| (cz , nz) (-b⁻¹ + (l + sk)) pf''
    claim : ⟦ case-|| (cz , nz) l pf ⟧₂ • S ≈ (S^ (k⁻¹ * a) • H • M -b⁻¹* • S^ -b • H ^ 2) ↑ • ⟦ lm' ⟧₂
    claim = begin
      ⟦ case-|| (cz , nz) l pf ⟧₂ • S ≈⟨ refl ⟩
      ⟦ case-|| (cz , nz) l pf ⟧₂ • S ≈⟨ special-assoc (□ ^ 4 • □) (□ ^ 5) auto ⟩
      CZ^ cz • H^ ₃ ↑ • S^ l ↑ • ⟦ pf ⟧ₚ • S ≈⟨ (cright cright cright Lemma-Postfix-SingleQ-S-ε kk mc1 m) ⟩
      CZ^ cz • H^ ₃ ↑ • S^ l ↑ • CZ^ czk • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ special-assoc (□ ^ 6) (□ • □ • □ ^ 2 • □ ^ 2) auto ⟩
      CZ^ cz • H^ ₃ ↑ • (S^ l ↑ • CZ^ czk) • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ (cright cright cleft sym (aux-comm-CZ^a-S^b↑ czk l)) ⟩
      CZ^ cz • H^ ₃ ↑ • (CZ^ czk • S^ l ↑) • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ special-assoc (□ • □ • □ ^ 2 • □ ^ 2) (□ ^ 3 • □ ^ 3) auto ⟩
      (CZ^ cz • H^ ₃ ↑ • CZ^ czk) • S^ l ↑ • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ cleft (lemma-CZCZ^-aH³CZ^k'-dual' cz* k*) ⟩
      ((S^ (k⁻¹ * a) ↑ • H ↑ • M -b⁻¹* ↑ • S^ -b ↑ • H ↑ ^ 2) • CZ^ a • H ↑ ^ 3 • S^ -b⁻¹ ↑ • S^ (k * a)) • S^ l ↑ • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ (cright sym assoc) ⟩
      ((S^ (k⁻¹ * a) ↑ • H ↑ • M -b⁻¹* ↑ • S^ -b ↑ • H ↑ ^ 2) • CZ^ a • H ↑ ^ 3 • S^ -b⁻¹ ↑ • S^ (k * a)) • (S^ l ↑ • S^ sk ↑) • ⟦ pf' ⟧ₚ ≈⟨ (cright cleft lemma-cong↑ _ _ (L0.lemma-S^k+l l sk)) ⟩
      ((S^ (k⁻¹ * a) ↑ • H ↑ • M -b⁻¹* ↑ • S^ -b ↑ • H ↑ ^ 2) • CZ^ a • H ↑ ^ 3 • S^ -b⁻¹ ↑ • S^ (k * a)) • (S^ (l + sk) ↑) • ⟦ pf' ⟧ₚ ≈⟨ special-assoc ((□ ^ 5 • □ ^ 4) • □ ^ 2) ((□ ^ 5 • □ ^ 3) • □ ^ 2 • □) auto ⟩
      ((S^ (k⁻¹ * a) ↑ • H ↑ • M -b⁻¹* ↑ • S^ -b ↑ • H ↑ ^ 2) • CZ^ a • H ↑ ^ 3 • S^ -b⁻¹ ↑) • (S^ (k * a) • S^ (l + sk) ↑) • ⟦ pf' ⟧ₚ ≈⟨ (cright cleft lemma-comm-Sᵏ-w↑ (toℕ (k * a)) (S^ (l + sk))) ⟩
      ((S^ (k⁻¹ * a) ↑ • H ↑ • M -b⁻¹* ↑ • S^ -b ↑ • H ↑ ^ 2) • CZ^ a • H ↑ ^ 3 • S^ -b⁻¹ ↑) • (S^ (l + sk) ↑ • S^ (k * a)) • ⟦ pf' ⟧ₚ ≈⟨ (cright assoc) ⟩
      ((S^ (k⁻¹ * a) ↑ • H ↑ • M -b⁻¹* ↑ • S^ -b ↑ • H ↑ ^ 2) • CZ^ a • H ↑ ^ 3 • S^ -b⁻¹ ↑) • S^ (l + sk) ↑ • S^ (k * a) • ⟦ pf' ⟧ₚ ≈⟨ (cright (cright special-assoc (□ ^ 5) (□ ^ 2 • □ ^ 3) auto)) ⟩
      ((S^ (k⁻¹ * a) ↑ • H ↑ • M -b⁻¹* ↑ • S^ -b ↑ • H ↑ ^ 2) • CZ^ a • H ↑ ^ 3 • S^ -b⁻¹ ↑) • S^ (l + sk) ↑ • ((S^ (k * a) • S^ ss) • (H^ ₃ • CZ • H) • ⟦ mc1 ⟧ₘ₊ ↑ • ⟦ mc0 ⟧ₘ₊) ≈⟨ (cright cright cleft lemma-S^k+l (k * a) ss) ⟩
      ((S^ (k⁻¹ * a) ↑ • H ↑ • M -b⁻¹* ↑ • S^ -b ↑ • H ↑ ^ 2) • CZ^ a • H ↑ ^ 3 • S^ -b⁻¹ ↑) • S^ (l + sk) ↑ • (S^ (k * a + ss) • (H^ ₃ • CZ • H) • ⟦ mc1 ⟧ₘ₊ ↑ • ⟦ mc0 ⟧ₘ₊) ≈⟨ special-assoc ((□ • □ ^ 3) • □ ^ 2) (□ • □ • □ • □ ^ 2 • □) auto ⟩
      ((S^ (k⁻¹ * a) ↑ • H ↑ • M -b⁻¹* ↑ • S^ -b ↑ • H ↑ ^ 2)) • CZ^ a • H ↑ ^ 3 • (S^ -b⁻¹ ↑ • S^ (l + sk) ↑) • (S^ (k * a + ss) • (H^ ₃ • CZ • H) • ⟦ mc1 ⟧ₘ₊ ↑ • ⟦ mc0 ⟧ₘ₊) ≈⟨ (cright cright cright cleft lemma-cong↑ _ _ (L0.lemma-S^k+l -b⁻¹ (l + sk))) ⟩
      ((S^ (k⁻¹ * a) ↑ • H ↑ • M -b⁻¹* ↑ • S^ -b ↑ • H ↑ ^ 2)) • CZ^ a • H ↑ ^ 3 • S^ (-b⁻¹ + (l + sk)) ↑ • (S^ (k * a + ss) • (H^ ₃ • CZ • H) • ⟦ mc1 ⟧ₘ₊ ↑ • ⟦ mc0 ⟧ₘ₊) ≈⟨ refl ⟩
      ((S^ (k⁻¹ * a) ↑ • H ↑ • M -b⁻¹* ↑ • S^ -b ↑ • H ↑ ^ 2)) • CZ^ a • H ↑ ^ 3 • S^ (-b⁻¹ + (l + sk)) ↑ • (S^ (k * a + ss) • (H^ ₃ • CZ • H) • ⟦ mc1 ⟧ₘ₊ ↑ • ⟦ mc0 ⟧ₘ₊) ≈⟨ refl ⟩
      (S^ (k⁻¹ * a) • H • M -b⁻¹* • S^ -b • H ^ 2) ↑ • ⟦ lm' ⟧₂ ∎


  Lemma-two-qupit-completeness (case-|| cz*@(cz , nz) l pf@(kk , mc1 , (m , HS^ (₁₊ kk-1)))) (H-gen) = lm' , (S^ (k⁻¹ * a) • H • M -b⁻¹* • S^ -b • H ^ 2) , claim
    where

    kk* : ℤ* ₚ
    kk* = ((₁₊ kk-1) , λ ())
    k* = (-' (kk* ⁻¹) *' (m *' m))
    sk = k* .proj₁
    -m/kk* = ((m *' kk* ⁻¹) *' -'₁)
    -1/kk = - (kk* ⁻¹) .proj₁
    mc' = (-m/kk* , HS^ -1/kk)
    mc0' = mc'
    pf' = (kk + sk , mc1 , mc0')

    a* : ℤ* ₚ
    a* = (cz , nz)

    k = - sk
    czk = k

    k⁻¹ = ((-' k*) ⁻¹) .proj₁
    a = cz
    -k = - k
    -k⁻¹ = - k⁻¹
    b' = -' ((-' k*) ⁻¹) *' a*
    b = b' .proj₁
    -b = - b
    -b⁻¹* =  -' b' ⁻¹
    -b⁻¹ =  -b⁻¹* .proj₁
    ss = kk + sk
    pf'' = (k * a + (kk + sk) , mc1 , mc0')
    mc0 = mc0'
    lm' = case-|| (cz , nz) (-b⁻¹ + (l + sk)) pf''
    claim : ⟦ case-|| (cz , nz) l pf ⟧₂ • H ≈ (S^ (k⁻¹ * a) • H • M -b⁻¹* • S^ -b • H ^ 2) ↑ • ⟦ lm' ⟧₂
    claim = begin
      ⟦ case-|| (cz , nz) l pf ⟧₂ • H ≈⟨ refl ⟩
      ⟦ case-|| (cz , nz) l pf ⟧₂ • H ≈⟨ special-assoc (□ ^ 4 • □) (□ ^ 5) auto ⟩
      CZ^ cz • H^ ₃ ↑ • S^ l ↑ • ⟦ pf ⟧ₚ • H ≈⟨ (cright cright cright Lemma-Postfix-SingleQ-H-HS kk mc1 m kk*) ⟩
      CZ^ cz • H^ ₃ ↑ • S^ l ↑ • CZ^ czk • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ special-assoc (□ ^ 6) (□ • □ • □ ^ 2 • □ ^ 2) auto ⟩
      CZ^ cz • H^ ₃ ↑ • (S^ l ↑ • CZ^ czk) • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ (cright cright cleft sym (aux-comm-CZ^a-S^b↑ czk l)) ⟩
      CZ^ cz • H^ ₃ ↑ • (CZ^ czk • S^ l ↑) • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ special-assoc (□ • □ • □ ^ 2 • □ ^ 2) (□ ^ 3 • □ ^ 3) auto ⟩
      (CZ^ cz • H^ ₃ ↑ • CZ^ czk) • S^ l ↑ • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ cleft (lemma-CZCZ^-aH³CZ^k'-dual' cz* (-' k*) ) ⟩ 
      ((S^ (k⁻¹ * a) ↑ • H ↑ • M -b⁻¹* ↑ • S^ -b ↑ • H ↑ ^ 2) • CZ^ a • H ↑ ^ 3 • S^ -b⁻¹ ↑ • S^ (k * a)) • S^ l ↑ • S^ sk ↑ • ⟦ pf' ⟧ₚ ≈⟨ (cright sym assoc) ⟩
      ((S^ (k⁻¹ * a) ↑ • H ↑ • M -b⁻¹* ↑ • S^ -b ↑ • H ↑ ^ 2) • CZ^ a • H ↑ ^ 3 • S^ -b⁻¹ ↑ • S^ (k * a)) • (S^ l ↑ • S^ sk ↑) • ⟦ pf' ⟧ₚ ≈⟨ (cright cleft lemma-cong↑ _ _ (L0.lemma-S^k+l l sk)) ⟩
      ((S^ (k⁻¹ * a) ↑ • H ↑ • M -b⁻¹* ↑ • S^ -b ↑ • H ↑ ^ 2) • CZ^ a • H ↑ ^ 3 • S^ -b⁻¹ ↑ • S^ (k * a)) • (S^ (l + sk) ↑) • ⟦ pf' ⟧ₚ ≈⟨ special-assoc ((□ ^ 5 • □ ^ 4) • □ ^ 2) ((□ ^ 5 • □ ^ 3) • □ ^ 2 • □) auto ⟩
      ((S^ (k⁻¹ * a) ↑ • H ↑ • M -b⁻¹* ↑ • S^ -b ↑ • H ↑ ^ 2) • CZ^ a • H ↑ ^ 3 • S^ -b⁻¹ ↑) • (S^ (k * a) • S^ (l + sk) ↑) • ⟦ pf' ⟧ₚ ≈⟨ (cright cleft lemma-comm-Sᵏ-w↑ (toℕ (k * a)) (S^ (l + sk))) ⟩
      ((S^ (k⁻¹ * a) ↑ • H ↑ • M -b⁻¹* ↑ • S^ -b ↑ • H ↑ ^ 2) • CZ^ a • H ↑ ^ 3 • S^ -b⁻¹ ↑) • (S^ (l + sk) ↑ • S^ (k * a)) • ⟦ pf' ⟧ₚ ≈⟨ (cright assoc) ⟩
      ((S^ (k⁻¹ * a) ↑ • H ↑ • M -b⁻¹* ↑ • S^ -b ↑ • H ↑ ^ 2) • CZ^ a • H ↑ ^ 3 • S^ -b⁻¹ ↑) • S^ (l + sk) ↑ • S^ (k * a) • ⟦ pf' ⟧ₚ ≈⟨ (cright (cright special-assoc (□ ^ 5) (□ ^ 2 • □ ^ 3) auto)) ⟩
      ((S^ (k⁻¹ * a) ↑ • H ↑ • M -b⁻¹* ↑ • S^ -b ↑ • H ↑ ^ 2) • CZ^ a • H ↑ ^ 3 • S^ -b⁻¹ ↑) • S^ (l + sk) ↑ • ((S^ (k * a) • S^ ss) • (H^ ₃ • CZ • H) • ⟦ mc1 ⟧ₘ₊ ↑ • ⟦ mc0 ⟧ₘ₊) ≈⟨ (cright cright cleft lemma-S^k+l (k * a) ss) ⟩
      ((S^ (k⁻¹ * a) ↑ • H ↑ • M -b⁻¹* ↑ • S^ -b ↑ • H ↑ ^ 2) • CZ^ a • H ↑ ^ 3 • S^ -b⁻¹ ↑) • S^ (l + sk) ↑ • (S^ (k * a + ss) • (H^ ₃ • CZ • H) • ⟦ mc1 ⟧ₘ₊ ↑ • ⟦ mc0 ⟧ₘ₊) ≈⟨ special-assoc ((□ • □ ^ 3) • □ ^ 2) (□ • □ • □ • □ ^ 2 • □) auto ⟩
      ((S^ (k⁻¹ * a) ↑ • H ↑ • M -b⁻¹* ↑ • S^ -b ↑ • H ↑ ^ 2)) • CZ^ a • H ↑ ^ 3 • (S^ -b⁻¹ ↑ • S^ (l + sk) ↑) • (S^ (k * a + ss) • (H^ ₃ • CZ • H) • ⟦ mc1 ⟧ₘ₊ ↑ • ⟦ mc0 ⟧ₘ₊) ≈⟨ (cright cright cright cleft lemma-cong↑ _ _ (L0.lemma-S^k+l -b⁻¹ (l + sk))) ⟩
      ((S^ (k⁻¹ * a) ↑ • H ↑ • M -b⁻¹* ↑ • S^ -b ↑ • H ↑ ^ 2)) • CZ^ a • H ↑ ^ 3 • S^ (-b⁻¹ + (l + sk)) ↑ • (S^ (k * a + ss) • (H^ ₃ • CZ • H) • ⟦ mc1 ⟧ₘ₊ ↑ • ⟦ mc0 ⟧ₘ₊) ≈⟨ refl ⟩
      ((S^ (k⁻¹ * a) ↑ • H ↑ • M -b⁻¹* ↑ • S^ -b ↑ • H ↑ ^ 2)) • CZ^ a • H ↑ ^ 3 • S^ (-b⁻¹ + (l + sk)) ↑ • (S^ (k * a + ss) • (H^ ₃ • CZ • H) • ⟦ mc1 ⟧ₘ₊ ↑ • ⟦ mc0 ⟧ₘ₊) ≈⟨ refl ⟩
      (S^ (k⁻¹ * a) • H • M -b⁻¹* • S^ -b • H ^ 2) ↑ • ⟦ lm' ⟧₂ ∎




  Lemma-two-qupit-completeness (case-Ex-| nf1 mc) (H-gen) = (case-Ex-| nf1 mc') , (S^ k , claim)
    where
    mc't = CP1.Lemma-single-qupit-completeness-mc-H {1} mc
    k = mc't .proj₁
    mc' = mc't .proj₂ .proj₁
    claim : ⟦ case-Ex-| nf1 mc ⟧₂ • [ H-gen ]ʷ ≈ (S^ k ↑) • ⟦ case-Ex-| nf1 mc' ⟧₂
    claim = begin
      ⟦ case-Ex-| nf1 mc ⟧₂ • [ H-gen ]ʷ ≈⟨ special-assoc (□ ^ 4 • □) (□ ^ 5) auto ⟩
      Ex • CZ • ⟦ nf1 ⟧₁ ↑ • ⟦ mc ⟧ₘ₊ • H ≈⟨ (cright cright cright mc't .proj₂ .proj₂) ⟩
      Ex • CZ • ⟦ nf1 ⟧₁ ↑ • S^ k • ⟦ mc' ⟧ₘ₊ ≈⟨ (cright cright sym assoc) ⟩
      Ex • CZ • (⟦ nf1 ⟧₁ ↑ • S^ k) • ⟦ mc' ⟧ₘ₊ ≈⟨ cright cright cleft sym (lemma-comm-Sᵏ-w↑ (toℕ k) ⟦ nf1 ⟧₁) ⟩
      Ex • CZ • (S^ k • ⟦ nf1 ⟧₁ ↑) • ⟦ mc' ⟧ₘ₊ ≈⟨ (cright special-assoc (□ • □ ^ 2 • □) (□ ^ 2 • □ ^ 2) auto) ⟩
      Ex • (CZ • S^ k) • ⟦ nf1 ⟧₁ ↑ • ⟦ mc' ⟧ₘ₊ ≈⟨ (cright cleft word-comm 1 (toℕ k) (axiom comm-CZ-S↓)) ⟩
      Ex • (S^ k • CZ) • ⟦ nf1 ⟧₁ ↑ • ⟦ mc' ⟧ₘ₊ ≈⟨ special-assoc (□ • □ ^ 2 • □ ^ 2) (□ ^ 2 • □ ^ 3) auto ⟩
      (Ex • S^ k) • CZ • ⟦ nf1 ⟧₁ ↑ • ⟦ mc' ⟧ₘ₊ ≈⟨ (cleft lemma-Ex-Sᵏ (toℕ k)) ⟩
      (S ↑ ^ toℕ k • Ex) • CZ • ⟦ nf1 ⟧₁ ↑ • ⟦ mc' ⟧ₘ₊ ≈⟨ (cleft cleft refl' (aux-↑ S (toℕ k))) ⟩
      (S^ k ↑ • Ex) • CZ • ⟦ nf1 ⟧₁ ↑ • ⟦ mc' ⟧ₘ₊ ≈⟨ special-assoc (□ ^ 2 • □ ^ 3) (□ • □ ^ 4) auto ⟩
      (S^ k ↑) • ⟦ case-Ex-| nf1 mc' ⟧₂ ∎

  Lemma-two-qupit-completeness (case-Ex-| nf1 mc) (S-gen) = (case-Ex-| nf1 mc') , (S^ k , claim)
    where
    mc't = CP1.Lemma-single-qupit-completeness-mc-S {1} mc
    k = mc't .proj₁
    mc' = mc't .proj₂ .proj₁
    claim : ⟦ case-Ex-| nf1 mc ⟧₂ • S ≈ (S^ k ↑) • ⟦ case-Ex-| nf1 mc' ⟧₂
    claim = begin
      ⟦ case-Ex-| nf1 mc ⟧₂ • S ≈⟨ special-assoc (□ ^ 4 • □) (□ ^ 5) auto ⟩
      Ex • CZ • ⟦ nf1 ⟧₁ ↑ • ⟦ mc ⟧ₘ₊ • S ≈⟨ (cright cright cright mc't .proj₂ .proj₂) ⟩
      Ex • CZ • ⟦ nf1 ⟧₁ ↑ • S^ k • ⟦ mc' ⟧ₘ₊ ≈⟨ (cright cright sym assoc) ⟩
      Ex • CZ • (⟦ nf1 ⟧₁ ↑ • S^ k) • ⟦ mc' ⟧ₘ₊ ≈⟨ cright cright cleft sym (lemma-comm-Sᵏ-w↑ (toℕ k) ⟦ nf1 ⟧₁) ⟩
      Ex • CZ • (S^ k • ⟦ nf1 ⟧₁ ↑) • ⟦ mc' ⟧ₘ₊ ≈⟨ (cright special-assoc (□ • □ ^ 2 • □) (□ ^ 2 • □ ^ 2) auto) ⟩
      Ex • (CZ • S^ k) • ⟦ nf1 ⟧₁ ↑ • ⟦ mc' ⟧ₘ₊ ≈⟨ (cright cleft word-comm 1 (toℕ k) (axiom comm-CZ-S↓)) ⟩
      Ex • (S^ k • CZ) • ⟦ nf1 ⟧₁ ↑ • ⟦ mc' ⟧ₘ₊ ≈⟨ special-assoc (□ • □ ^ 2 • □ ^ 2) (□ ^ 2 • □ ^ 3) auto ⟩
      (Ex • S^ k) • CZ • ⟦ nf1 ⟧₁ ↑ • ⟦ mc' ⟧ₘ₊ ≈⟨ (cleft lemma-Ex-Sᵏ (toℕ k)) ⟩
      (S ↑ ^ toℕ k • Ex) • CZ • ⟦ nf1 ⟧₁ ↑ • ⟦ mc' ⟧ₘ₊ ≈⟨ (cleft cleft refl' (aux-↑ S (toℕ k))) ⟩
      (S^ k ↑ • Ex) • CZ • ⟦ nf1 ⟧₁ ↑ • ⟦ mc' ⟧ₘ₊ ≈⟨ special-assoc (□ ^ 2 • □ ^ 3) (□ • □ ^ 4) auto ⟩
      (S^ k ↑) • ⟦ case-Ex-| nf1 mc' ⟧₂ ∎


  Lemma-two-qupit-completeness (case-Ex-| nf1 mc) (H-gen ↥) = (case-Ex-| nf1' mc) , ε , claim
    where
    nf1't = CP1.Corollary-single-qupit-completeness {0} nf1 H tt
    nf1' = nf1't .proj₁
    claim : ⟦ case-Ex-| nf1 mc ⟧₂ • H ↑ ≈ (ε ↑) • ⟦ case-Ex-| nf1' mc ⟧₂
    claim = begin
      ⟦ case-Ex-| nf1 mc ⟧₂ • H ↑ ≈⟨ refl ⟩
      (Ex • CZ • ⟦ nf1 ⟧₁ ↑ • ⟦ mc ⟧ₘ₊) • H ↑ ≈⟨ trans (by-assoc auto) assoc ⟩
      (Ex • CZ • ⟦ nf1 ⟧₁ ↑) • ⟦ mc ⟧ₘ₊ • H ↑ ≈⟨ (cright aux-comm-mc-H↑ mc) ⟩
      (Ex • CZ • ⟦ nf1 ⟧₁ ↑) • H ↑ • ⟦ mc ⟧ₘ₊ ≈⟨ sym (trans (by-assoc auto) assoc) ⟩
      (Ex • CZ • ⟦ nf1 ⟧₁ ↑ • H ↑) • ⟦ mc ⟧ₘ₊ ≈⟨ (cleft cright cright lemma-cong↑ _ _ (nf1't .proj₂)) ⟩
      (Ex • CZ • ⟦ nf1' ⟧₁ ↑) • ⟦ mc ⟧ₘ₊ ≈⟨ trans assoc (cong refl assoc) ⟩
      ⟦ case-Ex-| nf1' mc ⟧₂ ≈⟨ sym left-unit ⟩
      (ε ↑) • ⟦ case-Ex-| nf1' mc ⟧₂ ∎
  Lemma-two-qupit-completeness (case-Ex-| nf1 mc) (S-gen ↥) = (case-Ex-| nf1' mc) , ε , claim
    where
    nf1't = CP1.Corollary-single-qupit-completeness {0} nf1 S tt
    nf1' = nf1't .proj₁
    claim : ⟦ case-Ex-| nf1 mc ⟧₂ • S ↑ ≈ (ε ↑) • ⟦ case-Ex-| nf1' mc ⟧₂
    claim = begin
      ⟦ case-Ex-| nf1 mc ⟧₂ • S ↑ ≈⟨ refl ⟩
      (Ex • CZ • ⟦ nf1 ⟧₁ ↑ • ⟦ mc ⟧ₘ₊) • S ↑ ≈⟨ trans (by-assoc auto) assoc ⟩
      (Ex • CZ • ⟦ nf1 ⟧₁ ↑) • ⟦ mc ⟧ₘ₊ • S ↑ ≈⟨ (cright aux-comm-mc-S↑ mc) ⟩
      (Ex • CZ • ⟦ nf1 ⟧₁ ↑) • S ↑ • ⟦ mc ⟧ₘ₊ ≈⟨ sym (trans (by-assoc auto) assoc) ⟩
      (Ex • CZ • ⟦ nf1 ⟧₁ ↑ • S ↑) • ⟦ mc ⟧ₘ₊ ≈⟨ (cleft cright cright lemma-cong↑ _ _ (nf1't .proj₂)) ⟩
      (Ex • CZ • ⟦ nf1' ⟧₁ ↑) • ⟦ mc ⟧ₘ₊ ≈⟨ trans assoc (cong refl assoc) ⟩
      ⟦ case-Ex-| nf1' mc ⟧₂ ≈⟨ sym left-unit ⟩
      (ε ↑) • ⟦ case-Ex-| nf1' mc ⟧₂ ∎
  Lemma-two-qupit-completeness (case-| mc nf1) (H-gen) = (case-| mc nf1') , ε , claim
    where
    nf1't = CP1.Corollary-single-qupit-completeness {1} nf1 H tt
    nf1' = nf1't .proj₁
    claim : ⟦ case-| mc nf1 ⟧₂ • [ H-gen ]ʷ ≈ (ε ↑) • ⟦ case-| mc nf1' ⟧₂
    claim = begin
      ⟦ case-| mc nf1 ⟧₂ • H ≈⟨ refl ⟩
      (CZ • ⟦ mc ⟧ₘ₊ ↑ • ⟦ nf1 ⟧₁) • H ≈⟨ trans (by-assoc auto) assoc ⟩
      (CZ • ⟦ mc ⟧ₘ₊ ↑) • ⟦ nf1 ⟧₁ • H ≈⟨ (cright ((nf1't .proj₂))) ⟩
      (CZ • ⟦ mc ⟧ₘ₊ ↑) • ⟦ nf1't .proj₁ ⟧₁ ≈⟨ trans assoc (cong refl refl) ⟩
      ⟦ case-| mc nf1' ⟧₂ ≈⟨ sym left-unit ⟩
      (ε ↑) • ⟦ case-| mc nf1' ⟧₂ ∎

  Lemma-two-qupit-completeness (case-| mc nf1) (S-gen) = (case-| mc nf1') , ε , claim
    where
    nf1't = CP1.Corollary-single-qupit-completeness {1} nf1 S tt
    nf1' = nf1't .proj₁
    claim : ⟦ case-| mc nf1 ⟧₂ • [ S-gen ]ʷ ≈ (ε ↑) • ⟦ case-| mc nf1' ⟧₂
    claim = begin
      ⟦ case-| mc nf1 ⟧₂ • S ≈⟨ refl ⟩
      (CZ • ⟦ mc ⟧ₘ₊ ↑ • ⟦ nf1 ⟧₁) • S ≈⟨ trans (by-assoc auto) assoc ⟩
      (CZ • ⟦ mc ⟧ₘ₊ ↑) • ⟦ nf1 ⟧₁ • S ≈⟨ (cright ((nf1't .proj₂))) ⟩
      (CZ • ⟦ mc ⟧ₘ₊ ↑) • ⟦ nf1't .proj₁ ⟧₁ ≈⟨ trans assoc (cong refl refl) ⟩
      ⟦ case-| mc nf1' ⟧₂ ≈⟨ sym left-unit ⟩
      (ε ↑) • ⟦ case-| mc nf1' ⟧₂ ∎
  Lemma-two-qupit-completeness (case-| mc nf1) (H-gen ↥) = (case-| mc'  nf1) , ((S ^ toℕ k) , claim)
    where
    mc't = CP1.Lemma-single-qupit-completeness-mc-H {0} mc
    k = mc't .proj₁
    mc' = mc't .proj₂ .proj₁
    claim : ⟦ case-| mc nf1 ⟧₂ • H ↑ ≈ (S ^ toℕ k) ↑ • ⟦ case-| mc'  nf1 ⟧₂
    claim = begin
      ⟦ case-| mc nf1 ⟧₂ • H ↑ ≈⟨ refl ⟩
      (CZ • ⟦ mc ⟧ₘ₊ ↑ • ⟦ nf1 ⟧₁) • H ↑ ≈⟨ trans (by-assoc auto) assoc ⟩
      (CZ • ⟦ mc ⟧ₘ₊ ↑) • ⟦ nf1 ⟧₁ • H ↑ ≈⟨ (cright aux-comm-nf1-H↑ nf1) ⟩
      (CZ • ⟦ mc ⟧ₘ₊ ↑) • H ↑ • ⟦ nf1 ⟧₁ ≈⟨ sym (trans (by-assoc auto) assoc) ⟩
      (CZ • ⟦ mc ⟧ₘ₊ ↑ • H ↑) • ⟦ nf1 ⟧₁ ≈⟨ (cleft cright  lemma-cong↑ _ _ (mc't .proj₂ .proj₂)) ⟩
      (CZ • S^ k ↑ • ⟦ mc' ⟧ₘ₊ ↑) • ⟦ nf1 ⟧₁ ≈⟨ (cleft cright cleft sym (refl' (aux-↑ S (toℕ k)))) ⟩
      (CZ • S ↑ ^ toℕ k • ⟦ mc' ⟧ₘ₊ ↑) • ⟦ nf1 ⟧₁ ≈⟨ (cleft sym assoc) ⟩
      ((CZ • S ↑ ^ toℕ k) • ⟦ mc' ⟧ₘ₊ ↑) • ⟦ nf1 ⟧₁ ≈⟨ (cleft cleft word-comm 1 (toℕ k) (axiom comm-CZ-S↑)) ⟩
      ((S ↑ ^ toℕ k • CZ) • ⟦ mc' ⟧ₘ₊ ↑) • ⟦ nf1 ⟧₁ ≈⟨ (cleft cleft cleft refl' (aux-↑ S (toℕ k))) ⟩
      (((S ^ toℕ k) ↑ • CZ) • ⟦ mc' ⟧ₘ₊ ↑) • ⟦ nf1 ⟧₁ ≈⟨ trans assoc assoc ⟩
      (S ^ toℕ k) ↑ • ⟦ case-| mc' nf1 ⟧₂ ∎
  Lemma-two-qupit-completeness (case-| mc nf1) (S-gen ↥) = (case-| mc'  nf1) , ((S ^ toℕ k) , claim)
    where
    mc't = CP1.Lemma-single-qupit-completeness-mc-S {0} mc
    k = mc't .proj₁
    mc' = mc't .proj₂ .proj₁
    claim : ⟦ case-| mc nf1 ⟧₂ • S ↑ ≈ (S ^ toℕ k) ↑ • ⟦ case-| mc'  nf1 ⟧₂
    claim = begin
      ⟦ case-| mc nf1 ⟧₂ • S ↑ ≈⟨ refl ⟩
      (CZ • ⟦ mc ⟧ₘ₊ ↑ • ⟦ nf1 ⟧₁) • S ↑ ≈⟨ trans (by-assoc auto) assoc ⟩
      (CZ • ⟦ mc ⟧ₘ₊ ↑) • ⟦ nf1 ⟧₁ • S ↑ ≈⟨ (cright aux-comm-nf1-S↑ nf1) ⟩
      (CZ • ⟦ mc ⟧ₘ₊ ↑) • S ↑ • ⟦ nf1 ⟧₁ ≈⟨ sym (trans (by-assoc auto) assoc) ⟩
      (CZ • ⟦ mc ⟧ₘ₊ ↑ • S ↑) • ⟦ nf1 ⟧₁ ≈⟨ (cleft cright  lemma-cong↑ _ _ (mc't .proj₂ .proj₂)) ⟩
      (CZ • S^ k ↑ • ⟦ mc' ⟧ₘ₊ ↑) • ⟦ nf1 ⟧₁ ≈⟨ (cleft cright cleft sym (refl' (aux-↑ S (toℕ k)))) ⟩
      (CZ • S ↑ ^ toℕ k • ⟦ mc' ⟧ₘ₊ ↑) • ⟦ nf1 ⟧₁ ≈⟨ (cleft sym assoc) ⟩
      ((CZ • S ↑ ^ toℕ k) • ⟦ mc' ⟧ₘ₊ ↑) • ⟦ nf1 ⟧₁ ≈⟨ (cleft cleft word-comm 1 (toℕ k) (axiom comm-CZ-S↑)) ⟩
      ((S ↑ ^ toℕ k • CZ) • ⟦ mc' ⟧ₘ₊ ↑) • ⟦ nf1 ⟧₁ ≈⟨ (cleft cleft cleft refl' (aux-↑ S (toℕ k))) ⟩
      (((S ^ toℕ k) ↑ • CZ) • ⟦ mc' ⟧ₘ₊ ↑) • ⟦ nf1 ⟧₁ ≈⟨ trans assoc assoc ⟩
      (S ^ toℕ k) ↑ • ⟦ case-| mc' nf1 ⟧₂ ∎
  Lemma-two-qupit-completeness (case-Ex-nf1 nf1) (H-gen) = (case-Ex-nf1 nf1) , H , claim
    where
    nf1't = CP1.Corollary-single-qupit-completeness {1} nf1 H tt
    claim : ⟦ case-Ex-nf1 nf1 ⟧₂ • [ H-gen ]ʷ ≈ (H ↑) • ⟦ case-Ex-nf1 nf1 ⟧₂
    claim = begin
      ⟦ case-Ex-nf1 nf1 ⟧₂ • [ H-gen ]ʷ ≈⟨ assoc ⟩
      Ex • ⟦ nf1 ⟧₁ ↑ • H ≈⟨ (cright sym (lemma-comm-H-w↑ ⟦ nf1 ⟧₁)) ⟩
      Ex • H • ⟦ nf1 ⟧₁ ↑ ≈⟨ sym assoc ⟩
      (Ex • H) • ⟦ nf1 ⟧₁ ↑ ≈⟨ (cleft sym lemma-comm-Ex-H) ⟩
      (H ↑ • Ex) • ⟦ nf1 ⟧₁ ↑ ≈⟨ assoc ⟩
      H ↑ • ⟦ case-Ex-nf1 nf1 ⟧₂ ∎

  Lemma-two-qupit-completeness (case-Ex-nf1 nf1) (S-gen) = (case-Ex-nf1 nf1) , (S , claim)
    where
    claim : ⟦ case-Ex-nf1 nf1 ⟧₂ • [ S-gen ]ʷ ≈ (S ↑) • ⟦ case-Ex-nf1 nf1 ⟧₂
    claim = begin
      ⟦ case-Ex-nf1 nf1 ⟧₂ • [ S-gen ]ʷ ≈⟨ assoc ⟩
      Ex • ⟦ nf1 ⟧₁ ↑ • [ S-gen ]ʷ ≈⟨ (cright sym (lemma-comm-S-w↑ ⟦ nf1 ⟧₁)) ⟩
      Ex • [ S-gen ]ʷ • ⟦ nf1 ⟧₁ ↑ ≈⟨ sym assoc ⟩
      (Ex • [ S-gen ]ʷ) • ⟦ nf1 ⟧₁ ↑ ≈⟨ (cleft sym lemma-comm-Ex-S) ⟩
      (S ↑ • Ex) • ⟦ nf1 ⟧₁ ↑ ≈⟨ assoc ⟩
      (S ↑) • ⟦ case-Ex-nf1 nf1 ⟧₂ ∎

  Lemma-two-qupit-completeness (case-Ex-nf1 nf1) (H-gen ↥) =  case-Ex-nf1 nf1' , ε , claim
    where
    nf1't = CP1.Corollary-single-qupit-completeness nf1 H tt
    nf1' = nf1't .proj₁
    claim : ⟦ case-Ex-nf1 nf1 ⟧₂ • H ↑ ≈ (ε ↑) • ⟦ case-Ex-nf1 (nf1't .proj₁) ⟧₂
    claim = begin
      ⟦ case-Ex-nf1 nf1 ⟧₂ • H ↑ ≈⟨ assoc ⟩
      Ex • ⟦ nf1 ⟧₁ ↑ • H ↑ ≈⟨ (cright lemma-cong↑ _ _ (nf1't .proj₂)) ⟩
      Ex • ⟦ nf1' ⟧₁ ↑ ≈⟨ sym left-unit ⟩
      (ε ↑) • ⟦ case-Ex-nf1 (nf1't .proj₁) ⟧₂ ∎

  Lemma-two-qupit-completeness (case-Ex-nf1 nf1) (S-gen ↥) = case-Ex-nf1 nf1' , ε , claim
    where
    nf1't = CP1.Corollary-single-qupit-completeness nf1 S tt
    nf1' = nf1't .proj₁
    claim : ⟦ case-Ex-nf1 nf1 ⟧₂ • S ↑ ≈ (ε ↑) • ⟦ case-Ex-nf1 (nf1't .proj₁) ⟧₂
    claim = begin
      ⟦ case-Ex-nf1 nf1 ⟧₂ • S ↑ ≈⟨ assoc ⟩
      Ex • ⟦ nf1 ⟧₁ ↑ • S ↑ ≈⟨ (cright lemma-cong↑ _ _ (nf1't .proj₂)) ⟩
      Ex • ⟦ nf1' ⟧₁ ↑ ≈⟨ sym left-unit ⟩
      (ε ↑) • ⟦ case-Ex-nf1 (nf1't .proj₁) ⟧₂ ∎

  Lemma-two-qupit-completeness (case-nf1 nf1) (H-gen) = case-nf1 nf1' , ε , claim
    where
    nf1't = CP1.Corollary-single-qupit-completeness nf1 H tt
    nf1' = nf1't .proj₁
    claim : ⟦ case-nf1 nf1 ⟧₂ • H ≈ (ε ↑) • ⟦ case-nf1 (nf1't .proj₁) ⟧₂
    claim = begin
      ⟦ case-nf1 nf1 ⟧₂ • H ≈⟨ refl ⟩
      ⟦ nf1 ⟧₁ • H ≈⟨ ( (nf1't .proj₂)) ⟩
      ⟦ nf1' ⟧₁ ≈⟨ sym left-unit ⟩
      (ε ↑) • ⟦ case-nf1 (nf1't .proj₁) ⟧₂ ∎

  Lemma-two-qupit-completeness (case-nf1 nf1) (S-gen) = case-nf1 nf1' , ε , claim
    where
    nf1't = CP1.Corollary-single-qupit-completeness nf1 S tt
    nf1' = nf1't .proj₁
    claim : ⟦ case-nf1 nf1 ⟧₂ • S ≈ (ε ↑) • ⟦ case-nf1 (nf1't .proj₁) ⟧₂
    claim = begin
      ⟦ case-nf1 nf1 ⟧₂ • S ≈⟨ refl ⟩
      ⟦ nf1 ⟧₁ • S ≈⟨ ( (nf1't .proj₂)) ⟩
      ⟦ nf1' ⟧₁ ≈⟨ sym left-unit ⟩
      (ε ↑) • ⟦ case-nf1 (nf1't .proj₁) ⟧₂ ∎

  Lemma-two-qupit-completeness (case-nf1 x) (H-gen ↥) = (case-nf1 x) , (H , aux-comm-nf1-H↑ x)
  Lemma-two-qupit-completeness (case-nf1 x) (S-gen ↥) = (case-nf1 x) , (S , aux-comm-nf1-S↑ x)

