{-# OPTIONS  --safe #-}
{-# OPTIONS --termination-depth=2 #-}
open import Level using (0ℓ)

open import Relation.Binary using (Rel)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Binary.Morphism.Definitions using (Homomorphic₂)
open import Relation.Binary.PropositionalEquality using (_≡_ ; _≢_ ; inspect ; setoid ; module ≡-Reasoning ; _≗_) renaming ([_] to [_]')
import Relation.Binary.Reasoning.Setoid as SR
import Relation.Binary.PropositionalEquality as Eq
open import Relation.Nullary.Decidable using (yes ; no)


open import Function using (_∘_ ; id)
open import Function.Definitions using (Injective)

open import Data.Product using (_×_ ; _,_ ; proj₁ ; proj₂ ; map₁ ; ∃ ; Σ ; Σ-syntax)
open import Data.Product.Relation.Binary.Pointwise.NonDependent as PW using (≡×≡⇒≡ ; Pointwise ; ≡⇒≡×≡)
open import Data.Nat hiding (_^_ ; _+_ ; _*_)
open import Agda.Builtin.Nat using (_-_)
import Data.Nat as Nat
open import Data.Bool hiding (_<_ ; _≤_)
open import Data.List hiding ([_] ; _++_ ; last ; head ; tail ; _∷ʳ_)
open import Data.Vec hiding ([_])
import Data.Vec as Vec
open import Data.Fin hiding (_+_ ; _-_)

open import Data.Maybe
open import Data.Sum using (_⊎_ ; inj₁ ; inj₂ ; [_,_] ; [_,_]′)
open import Data.Unit using (⊤ ; tt)
open import Data.Empty using (⊥ ; ⊥-elim)

open import Word.Base as WB hiding (wfoldl ; _*)
open import Word.Properties
import Presentation.Base as PB
import Presentation.Properties as PP
open PP using (NFProperty ; NFProperty')
import Presentation.CosetNF as CA
import Presentation.Reidemeister-Schreier as RS
module RSF = RS.Star-Injective-Full.Reidemeister-Schreier-Full

open import Presentation.Construct.Base hiding (_*_ ; _⊕_)
import Presentation.Construct.Properties.SemiDirectProduct2 as SDP2
import Presentation.Construct.Properties.DirectProduct as DP
import Presentation.Groups.Cyclic as Cyclic


open import Data.Fin using (Fin ; toℕ ; suc ; zero ; fromℕ)
open import Data.Fin.Properties using (suc-injective ; toℕ-inject₁ ; toℕ-fromℕ)
import Data.Nat.Properties as NP
open import Presentation.GroupLike
open import Presentation.Tactics hiding ([_])
open import Data.Nat.Primality



module N.Completeness1 (p-2 : ℕ) (p-prime : Prime (2+ p-2))  where

pattern auto = Eq.refl

pattern ₀ = zero
pattern ₁ = suc ₀
pattern ₂ = suc ₁
pattern ₃ = suc ₂
pattern ₄ = 4
pattern ₅ = 5
pattern ₆ = 6
pattern ₇ = 7
pattern ₈ = 8
pattern ₉ = 9
pattern ₁₀ = 10
pattern ₁₁ = 11
pattern ₁₂ = 12
pattern ₁₃ = 13
pattern ₁₄ = 14
pattern ₁₅ = 15

pattern ₁₊ ⱼ = suc ⱼ
pattern ₂₊ ⱼ = suc (suc ⱼ)
pattern ₃₊ ⱼ = suc (suc (suc ⱼ))


open import Zp.ModularArithmetic
open PrimeModulus p-2 p-prime
open import N.Symplectic-Derived p-2 p-prime
open import N.Lemmas-2Qupit p-2 p-prime
open import N.NF1 p-2 p-prime
open Lemmas-2Q 2
open Symplectic-Derived-Gen
open Action
open Normal-Form1

module Completeness where

  private
    variable
      n : ℕ
      

  PrimitiveGen : Gen (₁₊ n) -> Set
  PrimitiveGen (H-gen ₁) = ⊤
  PrimitiveGen (S-gen ₁) = ⊤
  PrimitiveGen _ = ⊥

  PrimitiveWord : Word(Gen (₁₊ n)) -> Set
  PrimitiveWord [ x ]ʷ = PrimitiveGen x
  PrimitiveWord ε = ⊤
  PrimitiveWord (w • w₁) = PrimitiveWord w × PrimitiveWord w₁

  desugar-gen :(Gen (₁₊ n)) -> Word(Gen (₁₊ n))
  desugar-gen (H-gen x) = H ^ toℕ x
  desugar-gen (S-gen x) = S ^ toℕ x
  desugar-gen (CZ-gen x) = CZ ^ toℕ x
  desugar-gen {₁₊ n} (x ↥) = (desugar-gen x) ↑

  desugar-word : Word (Gen (₁₊ n)) -> Word(Gen (₁₊ n))
  desugar-word = desugar-gen WB.*


  lemma-H^-Prim : ∀ x -> PrimitiveWord {n} (H ^ x)
  lemma-H^-Prim ₀ = tt
  lemma-H^-Prim ₁ = tt
  lemma-H^-Prim (₂₊ k) = tt , (lemma-H^-Prim (₁₊ k))

  lemma-S^-Prim : ∀ x -> PrimitiveWord {n} (S ^ x)
  lemma-S^-Prim ₀ = tt
  lemma-S^-Prim ₁ = tt
  lemma-S^-Prim (₂₊ k) = tt , (lemma-S^-Prim (₁₊ k))

  lemma-desugar-gen : (g :(Gen (₁₊ n))) -> PrimitiveGen g -> PrimitiveWord (desugar-gen g)
  lemma-desugar-gen (H-gen x) pg = lemma-H^-Prim (toℕ x)
  lemma-desugar-gen (S-gen x) pg = lemma-S^-Prim (toℕ x)
  
  lemma-desugar-word : (w : Word(Gen (₁₊ n))) ->  PrimitiveWord w -> PrimitiveWord (desugar-word w)
  lemma-desugar-word [ x ]ʷ pg = lemma-desugar-gen x pg
  lemma-desugar-word ε pg = tt
  lemma-desugar-word (w • w₁) (pgl , pgr)= (lemma-desugar-word w pgl) , (lemma-desugar-word w₁ pgr)


  lemma-desugar-gen-≈ : let open PB ((₁₊ n) QRel,_===_) in
    (g :(Gen (₁₊ n))) -> desugar-gen g ≈ [ g ]ʷ
  lemma-desugar-gen-≈ (H-gen x) = PB.sym (PB.axiom (derived-H x))
  lemma-desugar-gen-≈ (S-gen x) = PB.sym (PB.axiom (derived-S x))
  lemma-desugar-gen-≈ (CZ-gen x) = PB.sym (PB.axiom (derived-CZ x))
  lemma-desugar-gen-≈ {₁₊ n} (x ↥) = lemma-cong↑ _ _ (lemma-desugar-gen-≈ x)


  lemma-desugar-word-≈ : let open PB ((₁₊ n) QRel,_===_) in
    (w : Word(Gen (₁₊ n))) -> desugar-word w ≈ w
  lemma-desugar-word-≈ [ x ]ʷ = lemma-desugar-gen-≈ x
  lemma-desugar-word-≈ ε = PB.refl
  lemma-desugar-word-≈ (w • w₁) = PB.cong (lemma-desugar-word-≈ w) (lemma-desugar-word-≈ w₁)




  Lemma-single-qupit-completeness : let open PB ((₁₊ n) QRel,_===_) in
    
    ∀ (nf : NF1) (g : Gen (₁₊ n)) (pg : PrimitiveGen g) ->
    -----------------------------------------------
    ∃ \ nf' -> ⟦ nf ⟧₁ • [ g ]ʷ ≈ ⟦ nf' ⟧₁
    
  Lemma-single-qupit-completeness {n} nf@(s , m , ε) (H-gen ₁) pg = (s , m , HS^ ₀) , claim
    where
    open PB ((₁₊ n) QRel,_===_)
    open PP ((₁₊ n) QRel,_===_)
    open SR word-setoid
    open Pattern-Assoc
    claim : (⟦ s ⟧ₛ • ⟦ m ⟧ₘ • ε) • [ H-gen ₁ ]ʷ ≈ ⟦ s ⟧ₛ • ⟦ m ⟧ₘ • H • S^ ₀
    claim = begin
      (⟦ s ⟧ₛ • ⟦ m ⟧ₘ • ε) • H ≈⟨ _≈_.cong (_≈_.cong refl right-unit) refl ⟩
      (⟦ s ⟧ₛ • ⟦ m ⟧ₘ) • H ≈⟨ by-assoc auto ⟩
      (⟦ s ⟧ₛ • ⟦ m ⟧ₘ) • H • ε ≈⟨ (cright cright _≈_.sym (axiom (derived-S ₀))) ⟩
      (⟦ s ⟧ₛ • ⟦ m ⟧ₘ) • H • S^ ₀ ≈⟨ assoc ⟩
      ⟦ s ⟧ₛ • ⟦ m ⟧ₘ • H • S^ ₀ ∎


  Lemma-single-qupit-completeness {n} nf@(s , x , HS^ ₀) (H-gen ₁) pg = nf' , claim
    where
    open PB ((₁₊ n) QRel,_===_)
    open PP ((₁₊ n) QRel,_===_)
    open SR word-setoid
    open Pattern-Assoc
    open Lemmas0 n

    x'  = x *' -'₁
    nf' = s , x' , ε
    claim : ⟦ s , x , HS^ ₀ ⟧₁ • [ H-gen ₁ ]ʷ ≈ ⟦ nf' ⟧₁
    claim = begin
      ⟦ s , x , HS^ ₀ ⟧₁ • [ H-gen ₁ ]ʷ ≈⟨ (cleft (cright (cright (cright axiom (derived-S ₀))))) ⟩
      (⟦ s ⟧ₛ • M x • (H • ε)) • H ≈⟨ trans assoc (cright assoc) ⟩
      ⟦ s ⟧ₛ • M x • (H • ε) • H ≈⟨ (cright cright cong right-unit refl) ⟩
      ⟦ s ⟧ₛ • M x • HH ≈⟨ (cright cright lemma-HH-M-1) ⟩
      ⟦ s ⟧ₛ • M x • M -'₁ ≈⟨ (cright axiom (M-mul x -'₁)) ⟩
      ⟦ s ⟧ₛ • M (x *' -'₁) ≈⟨ sym (cong refl right-unit) ⟩
      ⟦ s ⟧ₛ • M (x *' -'₁) • ε ≈⟨ refl ⟩
      ⟦ nf' ⟧₁ ∎

  Lemma-single-qupit-completeness {n} nf@(l , (y , nzy) , HS^ x@(₁₊ k')) (H-gen ₁) pg = nf' , claim
    where
    open PB ((₁₊ n) QRel,_===_)
    open PP ((₁₊ n) QRel,_===_)
    open SR word-setoid
    open Pattern-Assoc
    open Lemmas0 n

    x' : ℤ* ₚ
    x' = (x , λ ())
    nz = x' .proj₂
    x⁻¹ = ((x , nz) ⁻¹) .proj₁
    x⁻¹⁻¹ = (((x , nz) ⁻¹) ⁻¹) .proj₁
    -x⁻¹ = - x⁻¹
    -y/x' = (((y , nzy) *' ((x , nz) ⁻¹)) *' -'₁)
    -y/x = -y/x' .proj₁

    nf' = (l + -x⁻¹ * (y * y)) , -y/x' , (HS^ -x⁻¹)
    claim : ⟦ l , (y , nzy) , HS^ (₁₊ k') ⟧₁ • [ H-gen ₁ ]ʷ ≈ ⟦ nf' ⟧₁
    claim = begin
      ⟦ l , (y , nzy) , HS^ (₁₊ k') ⟧₁ • [ H-gen ₁ ]ʷ ≈⟨ trans assoc (cong refl assoc) ⟩
      S^ l • M (y , nzy) • (H • S^ (₁₊ k')) • H ≈⟨ (cright cright assoc) ⟩
      S^ l • M (y , nzy) • H • S^ (₁₊ k') • H ≈⟨ (cright derived-7 x y nz nzy) ⟩
      S^ l • S^ (-x⁻¹ * (y * y)) • M -y/x' • (H • S^ -x⁻¹) ≈⟨ sym assoc ⟩
      (S^ l • S^ (-x⁻¹ * (y * y))) • M -y/x' • (H • S^ -x⁻¹) ≈⟨ (cleft lemma-S^k+l l (-x⁻¹ * (y * y))) ⟩
      ⟦ nf' ⟧₁ ∎

  Lemma-single-qupit-completeness {n} nf@(l , (y , nzy) , ε) (S-gen ₁) pg = nf' , claim
    where
    open PB ((₁₊ n) QRel,_===_)
    open PP ((₁₊ n) QRel,_===_)
    open SR word-setoid
    open Pattern-Assoc
    open Lemmas0 n

    nf' = (l + y * y) , (y , nzy) , ε
    claim : ⟦ l , (y , nzy) , ε ⟧₁ • [ S-gen ₁ ]ʷ ≈ ⟦ nf' ⟧₁
    claim = begin
      ⟦ l , (y , nzy) , ε ⟧₁ • [ S-gen ₁ ]ʷ ≈⟨ trans assoc (cong refl assoc) ⟩
      S^ l • M (y , nzy) • ε • [ S-gen ₁ ]ʷ ≈⟨ cong refl (cong refl left-unit) ⟩
      S^ l • M (y , nzy) • S ≈⟨ (cright axiom (semi-MS (y , nzy))) ⟩
      S^ l • S^ (y * y) • M (y , nzy) ≈⟨ sym assoc ⟩
      (S^ l • S^ (y * y)) • M (y , nzy) ≈⟨ (cleft lemma-S^k+l l (y * y)) ⟩
      S^ (l + (y * y)) • M (y , nzy) ≈⟨ sym (cong refl right-unit) ⟩
      ⟦ nf' ⟧₁ ∎
      
  Lemma-single-qupit-completeness {n} nf@(s , m , HS^ k) (S-gen ₁) pg = nf' , claim
    where
    open PB ((₁₊ n) QRel,_===_)
    open PP ((₁₊ n) QRel,_===_)
    open SR word-setoid
    open Pattern-Assoc
    open Lemmas0 n

    k' = k + ₁
    nf' = s , m , HS^ k'
    claim : ⟦ s , m , HS^ k ⟧₁ • [ S-gen ₁ ]ʷ ≈ ⟦ nf' ⟧₁
    claim = begin
      ⟦ s , m , HS^ k ⟧₁ • [ S-gen ₁ ]ʷ ≈⟨ trans assoc (cong refl assoc) ⟩
      ⟦ s ⟧ₛ • ⟦ m ⟧ₘ • (H • S^ k) • S ≈⟨ refl ⟩
      ⟦ s ⟧ₛ • ⟦ m ⟧ₘ • (H • S^ k) • S^ ₁ ≈⟨ (cright cright assoc) ⟩
      ⟦ s ⟧ₛ • ⟦ m ⟧ₘ • H • S^ k • S^ ₁ ≈⟨ (cright cright cright lemma-S^k+l k ₁) ⟩
      ⟦ s ⟧ₛ • ⟦ m ⟧ₘ • H • S^ (k + ₁) ≈⟨ refl ⟩
      ⟦ nf' ⟧₁ ∎

  Corollary-single-qupit-completeness : let open PB ((₁₊ n) QRel,_===_) in
    
    ∀ (nf : NF1) (w : Word (Gen (₁₊ n))) (pw : PrimitiveWord w) ->
    --------------------------------------------------------
    ∃ \ nf' -> ⟦ nf ⟧₁ • w ≈ ⟦ nf' ⟧₁

  Corollary-single-qupit-completeness nf [ x ]ʷ pw = Lemma-single-qupit-completeness nf x pw
  Corollary-single-qupit-completeness nf ε pw = nf , PB.right-unit
  Corollary-single-qupit-completeness {n} nf (w • w₁) (pwl , pwr) with Corollary-single-qupit-completeness nf w pwl
  ... | (nf' , ih) with Corollary-single-qupit-completeness nf' w₁ pwr
  ... | (nf'' , ih2) = nf'' , claim
    where
    open PB ((₁₊ n) QRel,_===_)
    open PP ((₁₊ n) QRel,_===_)
    open SR word-setoid
    open Pattern-Assoc
    open Lemmas0 n

    claim : (⟦ nf ⟧₁ • w • w₁) ≈ ⟦ nf'' ⟧₁
    claim = begin
      (⟦ nf ⟧₁ • w • w₁) ≈⟨ sym assoc ⟩
      (⟦ nf ⟧₁ • w) • w₁ ≈⟨ (cleft ih) ⟩
      (⟦ nf' ⟧₁) • w₁ ≈⟨ ih2 ⟩
      ⟦ nf'' ⟧₁ ∎


