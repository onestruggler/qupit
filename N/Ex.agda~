{-# OPTIONS  --safe #-}
{-# OPTIONS --termination-depth=2 #-}
open import Level using (0ℓ)

open import Relation.Binary using (Rel)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Binary.Morphism.Definitions using (Homomorphic₂)
open import Relation.Binary.PropositionalEquality using (_≡_ ; _≢_ ; inspect ; setoid ; module ≡-Reasoning ; _≗_) renaming ([_] to [_]')
import Relation.Binary.Reasoning.Setoid as SR
import Relation.Binary.PropositionalEquality as Eq
open import Relation.Nullary.Decidable using (yes ; no)


open import Function using (_∘_ ; id)
open import Function.Definitions using (Injective)

open import Data.Product using (_×_ ; _,_ ; proj₁ ; proj₂ ; map₁ ; ∃ ; Σ ; Σ-syntax)
open import Data.Product.Relation.Binary.Pointwise.NonDependent as PW using (≡×≡⇒≡ ; Pointwise ; ≡⇒≡×≡)
open import Data.Nat hiding (_^_ ; _+_ ; _*_)
open import Agda.Builtin.Nat using (_-_)
import Data.Nat as Nat
open import Data.Bool hiding (_<_ ; _≤_)
open import Data.List hiding ([_] ; _++_ ; last ; head ; tail ; _∷ʳ_)
open import Data.Vec hiding ([_])
import Data.Vec as Vec
open import Data.Fin hiding (_+_ ; _-_)

open import Data.Maybe
open import Data.Sum using (_⊎_ ; inj₁ ; inj₂ ; [_,_] ; [_,_]′)
open import Data.Unit using (⊤ ; tt)
open import Data.Empty using (⊥ ; ⊥-elim)

open import Word.Base as WB hiding (wfoldl ; _*)
open import Word.Properties
import Presentation.Base as PB
import Presentation.Properties as PP
open PP using (NFProperty ; NFProperty')
import Presentation.CosetNF as CA
import Presentation.Reidemeister-Schreier as RS
module RSF = RS.Star-Injective-Full.Reidemeister-Schreier-Full

open import Presentation.Construct.Base hiding (_*_ ; _⊕_)
import Presentation.Construct.Properties.SemiDirectProduct2 as SDP2
import Presentation.Construct.Properties.DirectProduct as DP
import Presentation.Groups.Cyclic as Cyclic


open import Data.Fin using (Fin ; toℕ ; suc ; zero ; fromℕ)
open import Data.Fin.Properties using (suc-injective ; toℕ-inject₁ ; toℕ-fromℕ)
import Data.Nat.Properties as NP
open import Presentation.GroupLike
open import Presentation.Tactics hiding ([_])
open import Data.Nat.Primality



module N.Symplectic-Derived (p-2 : ℕ) (p-prime : Prime (2+ p-2))  where

pattern auto = Eq.refl

pattern ₀ = zero
pattern ₁ = suc ₀
pattern ₂ = suc ₁
pattern ₃ = suc ₂
pattern ₄ = 4
pattern ₅ = 5
pattern ₆ = 6
pattern ₇ = 7
pattern ₈ = 8
pattern ₉ = 9
pattern ₁₀ = 10
pattern ₁₁ = 11
pattern ₁₂ = 12
pattern ₁₃ = 13
pattern ₁₄ = 14
pattern ₁₅ = 15

pattern ₁₊ ⱼ = suc ⱼ
pattern ₂₊ ⱼ = suc (suc ⱼ)
pattern ₃₊ ⱼ = suc (suc (suc ⱼ))


open import Zp.ModularArithmetic
open PrimeModulus p-2 p-prime

module Symplectic-Derived-Gen where

  
  data Gen : ℕ → Set where
    H-gen : ∀ {n} → ℤ ₄ -> Gen (₁₊ n)
    S-gen : ∀ {n} → ℤ ₚ -> Gen (₁₊ n)
    CZ-gen : ∀ {n} → ℤ ₚ -> Gen (₂₊ n)
    -- lift a generator from Gen n to Gen (₁₊ n). E.g., in a two
    -- qupit circut H-gen = H 0, and H-gen ₛ = H 1.
    _ₛ : ∀ {n} → Gen n → Gen (suc n)

  [_⇑] : ∀ {n} → Word (Gen n) → Word (Gen (suc n))
  [_⇑] {n} = ([_↑] ∘ _ₛ) WB.*

  [_⇑]' : ∀ {n} → Word (Gen n) → Word (Gen (suc n))
  [_⇑]' {n} = wmap _ₛ

  _↑ : ∀ {n} → Word (Gen n) → Word (Gen (suc n))
  _↑ = wmap _ₛ

  _↓-gen : ∀ {n} → Gen n → Gen (suc n)
  _↓-gen {zero} ()
  _↓-gen {₁₊ n} (H-gen k) = (H-gen k)
  _↓-gen {₁₊ n} (S-gen k) = S-gen k
  _↓-gen {₁₊ .(₁₊ _)} (CZ-gen k) = CZ-gen k
  _↓-gen {₁₊ n} (g ₛ) = (g ↓-gen) ₛ

  _↓ : ∀ {n} → Word (Gen n) → Word (Gen (suc n))
  _↓ {n} = wmap _↓-gen


  lemma-[⇑]=[⇑]' : ∀ {n} (w : Word (Gen n)) → [ w ⇑] ≡ [ w ⇑]'
  lemma-[⇑]=[⇑]' {n} [ x ↑] = Eq.refl
  lemma-[⇑]=[⇑]' {n} ε = Eq.refl
  lemma-[⇑]=[⇑]' {n} (w • w₁) = Eq.cong₂ _•_ (lemma-[⇑]=[⇑]' w) (lemma-[⇑]=[⇑]' w₁)

  S : ∀ {n} → Word (Gen (₁₊ n))
  S = [ S-gen ₁ ↑]

  S⁻¹ : ∀ {n} → Word (Gen (₁₊ n))
  S⁻¹ = S ^ p-1
  
  H : ∀ {n} → Word (Gen (₁₊ n))
  H = [ H-gen ₁ ↑]

  H⁻¹ : ∀ {n} → Word (Gen (₁₊ n))
  H⁻¹ = H ^ 3

  HH : ∀ {n} → Word (Gen (₁₊ n))
  HH = H ^ 2

  SH : ∀ {n} → Word (Gen (₁₊ n))
  SH = S • H

  CZ : ∀ {n} → Word (Gen (₂₊ n))
  CZ = [ CZ-gen ₁ ↑]

  CZ⁻¹ : ∀ {n} → Word (Gen (₂₊ n))
  CZ⁻¹ = CZ ^ p-1
  
  CX : ∀ {n} → Word (Gen (₂₊ n))
  CX = H ↓ ^ 3 • CZ • H ↓ 

  XC : ∀ {n} → Word (Gen (₂₊ n))
  XC = H ↑ ^ 3 • CZ • H ↑ 

  CX' : ∀ {n} → Word (Gen (₂₊ n))
  CX' = H ↓ • CZ • H ↓ ^ 3

  XC' : ∀ {n} → Word (Gen (₂₊ n))
  XC' = H ↑ • CZ • H ↑ ^ 3

  Ex : ∀ {n} → Word (Gen (₂₊ n))
  Ex = CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑

  ₕ|ₕ : ∀ {n} → Word (Gen (₂₊ n))
  ₕ|ₕ = H ↓ • CZ • H ↓

  ʰ|ʰ : ∀ {n} → Word (Gen (₂₊ n))
  ʰ|ʰ = H ↑ • CZ • H ↑

  ⊥⊤ : ∀ {n} → Word (Gen (₂₊ n))
  ⊥⊤ = ₕ|ₕ • ʰ|ʰ

  ⊤⊥ : ∀ {n} → Word (Gen (₂₊ n))
  ⊤⊥ = ʰ|ʰ • ₕ|ₕ

  H^ : ∀ {n} → ℤ ₄ -> Word (Gen (₁₊ n))
  H^ k = [ H-gen k ↑]

  S^ : ∀ {n} → ℤ ₚ -> Word (Gen (₁₊ n))
  S^ k = [ S-gen k ↑]

  CZ^ : ∀ {n} → ℤ ₚ -> Word (Gen (₂₊ n))
  CZ^ k = [ CZ-gen k ↑]

  M : ∀ {n} -> ℤ* ₚ -> Word (Gen (₁₊ n))
  M x' = S^ x • H • S^ x⁻¹ • H • S^ x • H
    where
    x = x' .proj₁
    x⁻¹ = ((x' ⁻¹) .proj₁ )

  M₁ : ∀ {n} -> Word (Gen (₁₊ n))
  M₁ = M (₁ , λ ())

  infixr 9 _^2
  _^2 : ℤ* ₚ -> ℤ ₚ
  _^2 x' = let x = x' .proj₁ in x * x 

  infixr 9 _^1
  _^1 : ℤ* ₚ -> ℤ ₚ
  _^1 x' = let x = x' .proj₁ in x

  infix 4 _QRel,_===_
  data _QRel,_===_ : (n : ℕ) → WRel (Gen n) where
  
    order-S :      ∀ {n} → (₁₊ n) QRel,  S ^ p === ε
    order-H :      ∀ {n} → (₁₊ n) QRel,  H ^ 4 === ε
    order-SH :     ∀ {n} → (₁₊ n) QRel,  (S • H) ^ 3 === ε
    comm-HHS :     ∀ {n} → (₁₊ n) QRel,  H • H • S === S • H • H

    M-mul :    ∀ {n} x y → (₁₊ n) QRel,  M x • M y === M (x *' y)
    semi-MS :    ∀ {n} x → (₁₊ n) QRel,  M x • S === S^ (x ^2) • M x
    semi-M↑CZ :  ∀ {n} x → (₂₊ n) QRel,  M x ↑ • CZ === CZ^ (x ^1) • M x ↑
    semi-M↓CZ :  ∀ {n} x → (₂₊ n) QRel,  M x ↓ • CZ === CZ^ (x ^1) • M x ↓

    order-CZ :     ∀ {n} → (₂₊ n) QRel,  CZ ^ p === ε

    comm-CZ-S↓ :   ∀ {n} → (₂₊ n) QRel,  CZ • S ↓ === S ↓ • CZ
    comm-CZ-S↑ :   ∀ {n} → (₂₊ n) QRel,  CZ • S ↑ === S ↑ • CZ

    -- semi-CZ-HH↓ :  ∀ {n} → (₂₊ n) QRel,  CZ • H ↓ ^ 2 === H ↓ ^ 2 • CZ ^ 2
    -- semi-CZ-HH↑ :  ∀ {n} → (₂₊ n) QRel,  CZ • H ↑ ^ 2 === H ↑ ^ 2 • CZ ^ 2

    selinger-c10 : ∀ {n} → (₂₊ n) QRel,  CZ • H ↑ • CZ === S⁻¹ ↑ • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑ • S⁻¹ ↓
    selinger-c11 : ∀ {n} → (₂₊ n) QRel,  CZ • H ↓ • CZ === S⁻¹ ↓ • H ↓ • S⁻¹ ↓ • CZ • H ↓ • S⁻¹ ↓ • S⁻¹ ↑

    selinger-c12 : ∀ {n} → (₃₊ n) QRel,  CZ ↑ • CZ === CZ • CZ ↑
    selinger-c13 : ∀ {n} → (₃₊ n) QRel,  ⊤⊥ ↑ • CZ ↓ • ⊥⊤ ↑ === ⊥⊤ ↓ • CZ ↑ • ⊤⊥ ↓
    
    selinger-c14 : ∀ {n} → (₃₊ n) QRel,  (⊤⊥ ↑ • CZ ↓) ^ 3 === ε
    selinger-c15 : ∀ {n} → (₃₊ n) QRel,  (⊥⊤ ↓ • CZ ↑) ^ 3 === ε

    comm-H :    ∀ {n}{g} → (₂₊ n) QRel,  [ g ₛ ↑] • H === H • [ g ₛ ↑]
    comm-S :    ∀ {n}{g} → (₂₊ n) QRel,  [ g ₛ ↑] • S === S • [ g ₛ ↑]
    comm-CZ :   ∀ {n}{g} → (₃₊ n) QRel,  [ g ₛ ₛ ↑] • CZ === CZ • [ g ₛ ₛ ↑]

    derived-S :  ∀ {n} k → (₁₊ n) QRel,  S^ k === S ^ toℕ k
    derived-H :  ∀ {n} k → (₁₊ n) QRel,  H^ k === H ^ toℕ k
    derived-CZ : ∀ {n} k → (₂₊ n) QRel,  CZ^ k === CZ ^ toℕ k

    cong↑ : ∀ {n w v} → n QRel,  w === v → (₁₊ n) QRel,  w ↑ === v ↑


  lemma-cong↑ : ∀ {n} w v →
    let open PB (n QRel,_===_) using (_≈_) in
    let open PB ((suc n) QRel,_===_) renaming (_≈_ to _≈↑_) using () in
    w ≈ v → w ↑ ≈↑ v ↑
  lemma-cong↑ {n} w v PB.refl = PB.refl
  lemma-cong↑ {n} w v (PB.sym eq) = PB.sym (lemma-cong↑ v w eq)
  lemma-cong↑ {n} w v (PB.trans eq eq₁) = PB.trans (lemma-cong↑ _ _ eq) (lemma-cong↑ _ _ eq₁)
  lemma-cong↑ {n} w v (PB.cong eq eq₁) = PB.cong (lemma-cong↑ _ _ eq) (lemma-cong↑ _ _ eq₁)
  lemma-cong↑ {n} w v PB.assoc = PB.assoc
  lemma-cong↑ {n} w v PB.left-unit = PB.left-unit
  lemma-cong↑ {n} w v PB.right-unit = PB.right-unit
  lemma-cong↑ {n} w v (PB.axiom x) = PB.axiom (cong↑ x)

  lemma-cong↓-S^ : ∀ {n} k -> let open PB ((₂₊ n) QRel,_===_) renaming (_≈_ to _≈↓_) using () in
    (S ^ k) ↓ ≈↓ S ^ k
  lemma-cong↓-S^ {n} ₀ = PB.refl
  lemma-cong↓-S^ {n} ₁ = PB.refl
  lemma-cong↓-S^ {n} (₂₊ k) = PB.cong PB.refl (lemma-cong↓-S^ {n} (₁₊ k))


  lemma-cong↓-S↓^ : ∀ {n} k -> let open PB ((₃₊ n) QRel,_===_) renaming (_≈_ to _≈↓_) using () in
    (S ↓ ^ k) ↓ ≈↓ S ↓ ^ k
  lemma-cong↓-S↓^ {n} ₀ = PB.refl
  lemma-cong↓-S↓^ {n} ₁ = PB.refl
  lemma-cong↓-S↓^ {n} (₂₊ k) = PB.cong PB.refl (lemma-cong↓-S↓^ {n} (₁₊ k))

  lemma-cong↓-S↑^ : ∀ {n} k -> let open PB ((₃₊ n) QRel,_===_) renaming (_≈_ to _≈↓_) using () in
    ((S ↑) ^ k) ↓ ≈↓ (S ↑) ^ k
  lemma-cong↓-S↑^ {n} ₀ = PB.refl
  lemma-cong↓-S↑^ {n} ₁ = PB.refl
  lemma-cong↓-S↑^ {n} (₂₊ k) = PB.cong PB.refl (lemma-cong↓-S↑^ {n} (₁₊ k))


  lemma-cong↓-S^↓ : ∀ {n} k -> let open PB ((₃₊ n) QRel,_===_) renaming (_≈_ to _≈↓_) using () in
    (S ^ k) ↓ ↓ ≈↓ (S ^ k) ↓
  lemma-cong↓-S^↓ {n} ₀ = PB.refl
  lemma-cong↓-S^↓ {n} ₁ = PB.refl
  lemma-cong↓-S^↓ {n} (₂₊ k) = PB.cong PB.refl (lemma-cong↓-S^↓ {n} (₁₊ k))

  lemma-cong↓-S^↑ : ∀ {n} k -> let open PB ((₃₊ n) QRel,_===_) renaming (_≈_ to _≈↓_) using () in
    (S ^ k) ↑ ↓ ≈↓ (S ^ k) ↑
  lemma-cong↓-S^↑ {n} ₀ = PB.refl
  lemma-cong↓-S^↑ {n} ₁ = PB.refl
  lemma-cong↓-S^↑ {n} (₂₊ k) = PB.cong PB.refl (lemma-cong↓-S^↑ {n} (₁₊ k))

  lemma-cong↓-H^ : ∀ {n} k -> let open PB ((₂₊ n) QRel,_===_) renaming (_≈_ to _≈↓_) using () in
    (H ^ k) ↓ ≈↓ H ^ k
  lemma-cong↓-H^ {n} ₀ = PB.refl
  lemma-cong↓-H^ {n} ₁ = PB.refl
  lemma-cong↓-H^ {n} (₂₊ k) = PB.cong PB.refl (lemma-cong↓-H^ {n} (₁₊ k))

  lemma-cong↓-CZ^ : ∀ {n} k -> let open PB ((₃₊ n) QRel,_===_) renaming (_≈_ to _≈↓_) using () in
    (CZ ^ k) ↓ ≈↓ CZ ^ k
  lemma-cong↓-CZ^ {n} ₀ = PB.refl
  lemma-cong↓-CZ^ {n} ₁ = PB.refl
  lemma-cong↓-CZ^ {n} (₂₊ k) = PB.cong PB.refl (lemma-cong↓-CZ^ {n} (₁₊ k))

  lemma-↑↓ : ∀ {n} (w : Word (Gen n)) → w ↑ ↓ ≡ w ↓ ↑
  lemma-↑↓ [ x ↑] = auto
  lemma-↑↓ ε = auto
  lemma-↑↓ (w • w₁) = Eq.cong₂ _•_ (lemma-↑↓ w) (lemma-↑↓ w₁)

  lemma-cong↓ : ∀ {n} w v →
    let open PB (n QRel,_===_) using (_≈_) in
    let open PB ((suc n) QRel,_===_) renaming (_≈_ to _≈↓_) using () in
    w ≈ v → w ↓ ≈↓ v ↓
  lemma-cong↓ {n} w v PB.refl = PB.refl
  lemma-cong↓ {n} w v (PB.sym eq) = PB.sym (lemma-cong↓ v w eq)
  lemma-cong↓ {n} w v (PB.trans eq eq₁) = PB.trans (lemma-cong↓ _ _ eq) (lemma-cong↓ _ _ eq₁)
  lemma-cong↓ {n} w v (PB.cong eq eq₁) = PB.cong (lemma-cong↓ _ _ eq) (lemma-cong↓ _ _ eq₁)
  lemma-cong↓ {n} w v PB.assoc = PB.assoc
  lemma-cong↓ {n} w v PB.left-unit = PB.left-unit
  lemma-cong↓ {n} w v PB.right-unit = PB.right-unit
  lemma-cong↓ {n} w v (PB.axiom order-S) = begin
    ((S • S ^ ₁₊ p-2) ↓) ≈⟨ cong refl (lemma-cong↓-S^ (₁₊ p-2)) ⟩
    ((S • S ^ ₁₊ p-2)) ≈⟨ axiom order-S ⟩
    (ε ↓) ∎
    where
    open PB ((suc n) QRel,_===_) renaming (_≈_ to _≈↓_)
    open PP ((suc n) QRel,_===_)
    open SR word-setoid
  lemma-cong↓ {n} w v (PB.axiom order-H) = PB.axiom order-H
  lemma-cong↓ {n} w v (PB.axiom order-SH) = PB.axiom order-SH
  lemma-cong↓ {n} w v (PB.axiom comm-HHS) = PB.axiom comm-HHS
  lemma-cong↓ {n} w v (PB.axiom (M-mul x y)) = PB.axiom (M-mul x y)
  lemma-cong↓ {n} w v (PB.axiom (semi-MS x)) = PB.axiom (semi-MS x)
  lemma-cong↓ {n} w v (PB.axiom (semi-M↑CZ x)) = PB.axiom (semi-M↑CZ x)
  lemma-cong↓ {n} w v (PB.axiom (semi-M↓CZ x)) = PB.axiom (semi-M↓CZ x)
  lemma-cong↓ {n} w v (PB.axiom order-CZ) = begin
    ((CZ • CZ ^ ₁₊ p-2) ↓) ≈⟨ cong refl (lemma-cong↓-CZ^ (₁₊ p-2)) ⟩
    ((CZ • CZ ^ ₁₊ p-2)) ≈⟨ axiom order-CZ ⟩
    (ε ↓) ∎
    where
    open PB ((suc n) QRel,_===_) renaming (_≈_ to _≈↓_)
    open PP ((suc n) QRel,_===_)
    open SR word-setoid
  lemma-cong↓ {n} w v (PB.axiom comm-CZ-S↓) = PB.axiom comm-CZ-S↓
  lemma-cong↓ {n} w v (PB.axiom comm-CZ-S↑) = PB.axiom comm-CZ-S↑
  lemma-cong↓ {n} w v (PB.axiom selinger-c10) = begin
    ((CZ • (H ↑) • CZ) ↓) ≈⟨ refl ⟩
    ((CZ • (H ↑) • CZ) ) ≈⟨ axiom selinger-c10 ⟩
    ((S⁻¹ ↑) • (H ↑) • (S⁻¹ ↑) • CZ • (H ↑) • (S⁻¹ ↑) • (S⁻¹ ↓)) ≈⟨ sym (cong (lemma-cong↓-S^↑ (₁₊ p-2)) (cright cong (lemma-cong↓-S^↑ (₁₊ p-2)) (cright (cright cong (lemma-cong↓-S^↑ (₁₊ p-2)) (lemma-cong↓-S^↓ (₁₊ p-2)))))) ⟩
    ((S⁻¹ ↑ ↓) • (H ↑) • (S⁻¹ ↑ ↓) • CZ • (H ↑) • (S⁻¹ ↑ ↓) • (S⁻¹ ↓ ↓)) ≈⟨ refl ⟩
    ((S⁻¹ ↑ ↓) • (H ↑ ↓) • (S⁻¹ ↑ ↓) • CZ ↓ • (H ↑ ↓) • (S⁻¹ ↑ ↓) • (S⁻¹ ↓ ↓)) ≈⟨ refl ⟩
    (((S⁻¹ ↑) • (H ↑) • (S⁻¹ ↑) • CZ • (H ↑) • (S⁻¹ ↑) • (S⁻¹ ↓)) ↓) ∎
    where
    open PB ((suc n) QRel,_===_) renaming (_≈_ to _≈↓_)
    open PP ((suc n) QRel,_===_)
    open SR word-setoid
  lemma-cong↓ {n} w v (PB.axiom selinger-c11) = begin
    ((CZ • (H ↓) • CZ) ↓) ≈⟨ refl ⟩
    ((CZ • (H ↓) • CZ) ) ≈⟨ axiom selinger-c11 ⟩
    ((S⁻¹ ↓) • (H ↓) • (S⁻¹ ↓) • CZ • (H ↓) • (S⁻¹ ↓) • (S⁻¹ ↑)) ≈⟨ sym (cong (lemma-cong↓-S^↓ (₁₊ p-2)) (cright cong (lemma-cong↓-S^↓ (₁₊ p-2)) (cright (cright cong (lemma-cong↓-S^↓ (₁₊ p-2)) (lemma-cong↓-S^↑ (₁₊ p-2)))))) ⟩
    ((S⁻¹ ↓ ↓) • (H ↓) • (S⁻¹ ↓ ↓) • CZ • (H ↓) • (S⁻¹ ↓ ↓) • (S⁻¹ ↑ ↓)) ≈⟨ refl ⟩
    (((S⁻¹ ↓) • (H ↓) • (S⁻¹ ↓) • CZ • (H ↓) • (S⁻¹ ↓) • (S⁻¹ ↑)) ↓) ∎
    where
    open PB ((suc n) QRel,_===_) renaming (_≈_ to _≈↓_)
    open PP ((suc n) QRel,_===_)
    open SR word-setoid
  lemma-cong↓ {n} w v (PB.axiom selinger-c12) = PB.axiom selinger-c12
  lemma-cong↓ {n} w v (PB.axiom selinger-c13) = PB.axiom selinger-c13
  lemma-cong↓ {n} w v (PB.axiom selinger-c14) = PB.axiom selinger-c14
  lemma-cong↓ {n} w v (PB.axiom selinger-c15) = PB.axiom selinger-c15
  lemma-cong↓ {n} w v (PB.axiom comm-H) = PB.axiom comm-H
  lemma-cong↓ {n} w v (PB.axiom comm-S) = PB.axiom comm-S
  lemma-cong↓ {n} w v (PB.axiom comm-CZ) = PB.axiom comm-CZ
  lemma-cong↓ {n} w v (PB.axiom (derived-S k)) = begin
    ([ S-gen k ↑] ↓) ≈⟨ refl ⟩
    ([ S-gen k ↑]) ≈⟨ axiom (derived-S k) ⟩
    ((S ^ toℕ k)) ≈⟨ sym (lemma-cong↓-S^ (toℕ k)) ⟩
    ((S ^ toℕ k) ↓) ∎
    where
    open PB ((suc n) QRel,_===_) renaming (_≈_ to _≈↓_)
    open PP ((suc n) QRel,_===_)
    open SR word-setoid
  lemma-cong↓ {n} w v (PB.axiom (derived-H k)) = begin
    ([ H-gen k ↑] ↓) ≈⟨ refl ⟩
    ([ H-gen k ↑]) ≈⟨ axiom (derived-H k) ⟩
    ((H ^ toℕ k)) ≈⟨ sym (lemma-cong↓-H^ (toℕ k)) ⟩
    ((H ^ toℕ k) ↓) ∎
    where
    open PB ((suc n) QRel,_===_) renaming (_≈_ to _≈↓_)
    open PP ((suc n) QRel,_===_)
    open SR word-setoid
  lemma-cong↓ {n} w v (PB.axiom (derived-CZ k)) =  begin
    ([ CZ-gen k ↑] ↓) ≈⟨ refl ⟩
    ([ CZ-gen k ↑]) ≈⟨ axiom (derived-CZ k) ⟩
    ((CZ ^ toℕ k)) ≈⟨ sym (lemma-cong↓-CZ^ (toℕ k)) ⟩
    ((CZ ^ toℕ k) ↓) ∎
    where
    open PB ((suc n) QRel,_===_) renaming (_≈_ to _≈↓_)
    open PP ((suc n) QRel,_===_)
    open SR word-setoid
  lemma-cong↓ {n} w v (PB.axiom (cong↑ {w = w₁} {v = v₁} x)) = begin
    ((w₁ ↑) ↓) ≡⟨  lemma-↑↓ w₁ ⟩
    ((w₁ ↓) ↑) ≈⟨ lemma-cong↑ _ _ (lemma-cong↓ _ _ (PB.axiom x)) ⟩
    ((v₁ ↓) ↑) ≡⟨ Eq.sym (lemma-↑↓ v₁) ⟩
    ((v₁ ↑) ↓) ∎
    where
    open PB ((suc n) QRel,_===_) renaming (_≈_ to _≈↓_)
    open PP ((suc n) QRel,_===_)
    open SR word-setoid


  lemma-comm-S-w↑ : ∀ {n} w → let open PB ((₂₊ n) QRel,_===_) in
    
    S • w ↑ ≈ w ↑ • S
    
  lemma-comm-S-w↑ {n} [ x ↑] = sym (axiom comm-S)
    where
    open PB ((₂₊ n) QRel,_===_)
  lemma-comm-S-w↑ {n} ε = trans right-unit (sym left-unit)
    where
    open PB ((₂₊ n) QRel,_===_)
  lemma-comm-S-w↑ {n} (w • w₁) = begin
    S • ((w • w₁) ↑) ≈⟨ refl ⟩
    S • (w ↑ • w₁ ↑) ≈⟨ sym assoc ⟩
    (S • w ↑) • w₁ ↑ ≈⟨ cong (lemma-comm-S-w↑ w) refl ⟩
    (w ↑ • S) • w₁ ↑ ≈⟨ assoc ⟩
    w ↑ • S • w₁ ↑ ≈⟨ cong refl (lemma-comm-S-w↑ w₁) ⟩
    w ↑ • w₁ ↑ • S ≈⟨ sym assoc ⟩
    ((w • w₁) ↑) • S ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid


  lemma-comm-Sᵏ-w↑ : ∀ {n} k w → let open PB ((₂₊ n) QRel,_===_) in
    
    S ^ k • w ↑ ≈ w ↑ • S ^ k
    
  lemma-comm-Sᵏ-w↑ {n} ₀ w = trans left-unit (sym right-unit)
    where
    open PB ((₂₊ n) QRel,_===_)
  lemma-comm-Sᵏ-w↑ {n} ₁ w = lemma-comm-S-w↑ w
    where
    open PB ((₂₊ n) QRel,_===_)
  lemma-comm-Sᵏ-w↑ {n} (₂₊ k) w = begin
    (S • S ^ ₁₊ k) • (w ↑) ≈⟨ assoc ⟩
    S • S ^ ₁₊ k • (w ↑) ≈⟨ cong refl (lemma-comm-Sᵏ-w↑ (₁₊ k) w) ⟩
    S • (w ↑) • S ^ ₁₊ k ≈⟨ sym assoc ⟩
    (S • w ↑) • S ^ ₁₊ k ≈⟨ cong (lemma-comm-S-w↑ w) refl ⟩
    (w ↑ • S) • S ^ ₁₊ k ≈⟨ assoc ⟩
    (w ↑) • S • S ^ ₁₊ k ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid

  lemma-comm-H-w↑ : ∀ {n} w → let open PB ((₂₊ n) QRel,_===_) in
    
    H • w ↑ ≈ w ↑ • H
    
  lemma-comm-H-w↑ {n} [ x ↑] = sym (axiom comm-H)
    where
    open PB ((₂₊ n) QRel,_===_)
  lemma-comm-H-w↑ {n} ε = trans right-unit (sym left-unit)
    where
    open PB ((₂₊ n) QRel,_===_)
  lemma-comm-H-w↑ {n} (w • w₁) = begin
    H • ((w • w₁) ↑) ≈⟨ refl ⟩
    H • (w ↑ • w₁ ↑) ≈⟨ sym assoc ⟩
    (H • w ↑) • w₁ ↑ ≈⟨ cong (lemma-comm-H-w↑ w) refl ⟩
    (w ↑ • H) • w₁ ↑ ≈⟨ assoc ⟩
    w ↑ • H • w₁ ↑ ≈⟨ cong refl (lemma-comm-H-w↑ w₁) ⟩
    w ↑ • w₁ ↑ • H ≈⟨ sym assoc ⟩
    ((w • w₁) ↑) • H ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid

  lemma-comm-CZ-w↑ : ∀ {n} w → let open PB ((₃₊ n) QRel,_===_) in
    
    CZ • w ↑ ↑ ≈ w ↑ ↑ • CZ
    
  lemma-comm-CZ-w↑ {n} [ x ↑] = sym (axiom comm-CZ)
    where
    open PB ((₃₊ n) QRel,_===_)
  lemma-comm-CZ-w↑ {n} ε = trans right-unit (sym left-unit)
    where
    open PB ((₃₊ n) QRel,_===_)
  lemma-comm-CZ-w↑ {n} (w • w₁) = begin
    CZ • ((w • w₁) ↑ ↑) ≈⟨ refl ⟩
    CZ • (w ↑ ↑ • w₁ ↑ ↑) ≈⟨ sym assoc ⟩
    (CZ • w ↑ ↑) • w₁ ↑ ↑ ≈⟨ cong (lemma-comm-CZ-w↑ w) refl ⟩
    (w ↑ ↑ • CZ) • w₁ ↑ ↑ ≈⟨ assoc ⟩
    w ↑ ↑ • CZ • w₁ ↑ ↑ ≈⟨ cong refl (lemma-comm-CZ-w↑ w₁) ⟩
    w ↑ ↑ • w₁ ↑ ↑ • CZ ≈⟨ sym assoc ⟩
    ((w • w₁) ↑ ↑) • CZ ∎
    where
    open PB ((₃₊ n) QRel,_===_)
    open PP ((₃₊ n) QRel,_===_)
    open SR word-setoid

  -- lemma-comm-H↑-M : ∀ {n} m → let open PB ((₂₊ n) QRel,_===_) in
    
  --   H ↑ • M m ≈ M m • H ↑

  -- lemma-comm-H↑-M {n} m = begin    
  --   H ↑ • M m ≈⟨ {!!} ⟩
  --   M m • H ↑ ∎
  --   where
  --   open PB ((₂₊ n) QRel,_===_)
  --   open PP ((₂₊ n) QRel,_===_)
  --   open SR word-setoid


module Symplectic-Derived-GroupLike where
  private
    variable
      n : ℕ

  open Symplectic-Derived-Gen
  
  grouplike : Grouplike ((₁₊ n) QRel,_===_)
  grouplike {n} (H-gen k) = (H ^ toℕ k) ^ 3 , claim
    where
    open PB ((₁₊ n) QRel,_===_)
    open PP ((₁₊ n) QRel,_===_)
    open SR word-setoid
    claim : (H ^ toℕ k) ^ 3 • H^ k ≈ ε
    claim = begin
      (H ^ toℕ k) ^ 3 • H^ k ≈⟨ (cright axiom (derived-H k)) ⟩
      (H ^ toℕ k) ^ 3 • H ^ toℕ k ≈⟨ sym (lemma-^-+ (H ^ toℕ k) 3 1) ⟩
      (H ^ toℕ k) ^ 4 ≈⟨ lemma-^^' H (toℕ k) 4 ⟩
      (H ^ 4) ^ toℕ k ≈⟨ lemma-^-cong (H ^ 4) ε (toℕ k) (axiom order-H) ⟩
      (ε) ^ toℕ k ≈⟨ lemma-ε^k=ε (toℕ k) ⟩
      ε ∎

  grouplike {n} (S-gen k) = (S ^ toℕ k) ^ p-1 ,  claim
    where
    open PB ((₁₊ n) QRel,_===_)
    open PP ((₁₊ n) QRel,_===_)
    open SR word-setoid
    claim : (S ^ toℕ k) ^ p-1 • S^ k ≈ ε
    claim = begin
      (S ^ toℕ k) ^ p-1 • S^ k ≈⟨ (cright axiom (derived-S k)) ⟩
      (S ^ toℕ k) ^ p-1 • S ^ toℕ k ≈⟨ sym (lemma-^-+ (S ^ toℕ k) p-1 1) ⟩
      (S ^ toℕ k) ^ (p-1 Nat.+ 1) ≈⟨ lemma-^^' S (toℕ k) (p-1 Nat.+ 1) ⟩
      (S ^ (p-1 Nat.+ 1)) ^ toℕ k ≈⟨ lemma-^-cong (S ^ (p-1 Nat.+ 1)) (S ^ p) (toℕ k) (refl' (Eq.cong (S ^_) (NP.+-comm p-1 1))) ⟩
      (S ^ p) ^ toℕ k ≈⟨ lemma-^-cong (S ^ p) ε (toℕ k) (axiom order-S) ⟩
      (ε) ^ toℕ k ≈⟨ lemma-ε^k=ε (toℕ k) ⟩
      ε ∎

  grouplike {₁₊ n} (CZ-gen k) = (CZ ^ toℕ k) ^ p-1 ,  claim
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    claim : (CZ ^ toℕ k) ^ p-1 • CZ^ k ≈ ε
    claim = begin
      (CZ ^ toℕ k) ^ p-1 • CZ^ k ≈⟨ (cright axiom (derived-CZ k)) ⟩
      (CZ ^ toℕ k) ^ p-1 • CZ ^ toℕ k ≈⟨ sym (lemma-^-+ (CZ ^ toℕ k) p-1 1) ⟩
      (CZ ^ toℕ k) ^ (p-1 Nat.+ 1) ≈⟨ lemma-^^' CZ (toℕ k) (p-1 Nat.+ 1) ⟩
      (CZ ^ (p-1 Nat.+ 1)) ^ toℕ k ≈⟨ lemma-^-cong (CZ ^ (p-1 Nat.+ 1)) (CZ ^ p) (toℕ k) (refl' (Eq.cong (CZ ^_) (NP.+-comm p-1 1))) ⟩
      (CZ ^ p) ^ toℕ k ≈⟨ lemma-^-cong (CZ ^ p) ε (toℕ k) (axiom order-CZ) ⟩
      (ε) ^ toℕ k ≈⟨ lemma-ε^k=ε (toℕ k) ⟩
      ε ∎

  grouplike {₁₊ n} (g ₛ) with grouplike g
  ... | ig , prf = (ig ↑) , lemma-cong↑ (ig • [ g ↑]) ε prf
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)


  import Data.Nat.Literals as NL
  open import Agda.Builtin.FromNat
  open import Data.Unit.Base using (⊤)
  open import Data.Fin.Literals
  import Data.Nat.Literals as NL


  instance
    Numℕ' : Number ℕ
    Numℕ' = NL.number 

  instance
    NumFin' : Number (Fin p)
    NumFin' = number p

module Action where

  open Symplectic-Derived-Gen

  Pauli1 = ℤ ₚ × ℤ ₚ

  Pauli : ℕ → Set
  Pauli n = Vec Pauli1 n

  act1 : ∀ {n} → Gen n → Pauli n → Pauli n
  act1 {₁₊ n} (H-gen ₀) ((a , b) ∷ ps) = ((a , b) ∷ ps)
  act1 {₁₊ n} (H-gen ₁) ((a , b) ∷ ps) = ((- b , a) ∷ ps)
  act1 {₁₊ n} (H-gen ₂) ((a , b) ∷ ps) = ((- a , - b) ∷ ps)
  act1 {₁₊ n} (H-gen ₃) ((a , b) ∷ ps) = ((b , - a) ∷ ps)
  act1 {₁₊ n} (S-gen k) ((a , b) ∷ ps) = ((a , b + a * k) ∷ ps)
  act1 {₂₊ n} (CZ-gen k) ((a , b) ∷ (a' , b') ∷ ps) = (a , b + a' * k) ∷ (a' , b' + a * k) ∷ ps
  act1 {₁₊ n} (g ₛ) (p ∷ ps) = p ∷ act1 {n} g ps

  act : ∀ {n} → Word (Gen n) → Pauli n → Pauli n
  act {n} = word-act act1
  -- act {n} ε p = p
  -- act {n} (w • w₁) p = act w (act w₁ p)

  lemma-act-↑ : ∀ {n} (w : Word (Gen n)) → (p : Pauli1 ) (q : Pauli n) → act (w ↑) (p ∷ q) ≡ p ∷ act w q
  lemma-act-↑ {n} [ x ↑] p q = auto
  lemma-act-↑ {n} ε p q = auto
  lemma-act-↑ {n} (w • v) p q = begin
    act ((w • v) ↑) (p ∷ q) ≡⟨ auto ⟩
    act (w ↑) (act (v ↑) (p ∷ q)) ≡⟨ Eq.cong (act (w ↑)) (lemma-act-↑ v p q) ⟩
    act (w ↑) (p ∷ act v q) ≡⟨ lemma-act-↑ w p (act v q) ⟩
    p ∷ act w (act v q) ≡⟨ auto ⟩
    p ∷ act (w • v) q ∎
    where open ≡-Reasoning

  cong₃ : ∀ {A B C D : Set}(f : A → B → C → D) {x y u v a b} → x ≡ y → u ≡ v → a ≡ b → f x u a  ≡ f y v b
  cong₃ f Eq.refl Eq.refl Eq.refl = Eq.refl


  lemma-act-↓-gen : ∀ {n} (gen : Gen n) → (p : Pauli1 ) (ps : Pauli n) → act1 (gen ↓-gen) (ps ∷ʳ p) ≡ (act1 gen ps) ∷ʳ p
  lemma-act-↓-gen {₁} (H-gen ₀) p (x ∷ []) = auto
  lemma-act-↓-gen {₁} (H-gen ₁) p (x ∷ []) = auto
  lemma-act-↓-gen {₁} (H-gen ₂) p (x ∷ []) = auto
  lemma-act-↓-gen {₁} (H-gen ₃) p (x ∷ []) = auto
  lemma-act-↓-gen {₁} (S-gen k) p (x ∷ []) = auto
  lemma-act-↓-gen {₂₊ n} (H-gen ₀) p (x ∷ x₁ ∷ ps) = auto
  lemma-act-↓-gen {₂₊ n} (H-gen ₁) p (x ∷ x₁ ∷ ps) = auto
  lemma-act-↓-gen {₂₊ n} (H-gen ₂) p (x ∷ x₁ ∷ ps) = auto
  lemma-act-↓-gen {₂₊ n} (H-gen ₃) p (x ∷ x₁ ∷ ps) = auto
  lemma-act-↓-gen {₂₊ n} (S-gen k) p (x ∷ x₁ ∷ ps) = auto
  lemma-act-↓-gen {₂₊ n} (CZ-gen k) p (x ∷ x₁ ∷ ps) = auto
  lemma-act-↓-gen {₂₊ n} (gen ₛ) p (x ∷ x₁ ∷ ps) rewrite lemma-act-↓-gen {₁₊ n} gen p (x₁ ∷ ps) = Eq.cong (x ∷_) auto

  lemma-act-↓ : ∀ {n} (w : Word (Gen n)) → (p : Pauli1 ) (ps : Pauli n) → act (w ↓) (ps ∷ʳ p) ≡ (act w ps) ∷ʳ p
  lemma-act-↓ {₁₊ n} [ x ↑] p (x₁ ∷ ps) = lemma-act-↓-gen x p (x₁ ∷ ps)
  lemma-act-↓ {n} ε p ps = auto
  lemma-act-↓ {n} (w • w₁) p ps rewrite lemma-act-↓ w₁ p ps | lemma-act-↓ w p (act w₁ ps) = auto


  pIₙ : ∀ {n} → Pauli n
  pIₙ {₀} = []
  pIₙ {₁₊ n} = (₀ , ₀) ∷ pIₙ {n}

  pZ : Pauli1
  pZ = (₀ , ₁)

  pX : Pauli1
  pX = (₁ , ₀)

  pI : Pauli1
  pI = (₀ , ₀)

  pZₙ : ∀ {n} → Pauli n
  pZₙ {₀} = []
  pZₙ {₁} = pZ ∷ []
  pZₙ {₁₊ n} = pI ∷ pZₙ

  pXₙ : ∀ {n} → Pauli n
  pXₙ {₀} = []
  pXₙ {₁} = pX ∷ []
  pXₙ {₁₊ n} = pI ∷ pXₙ

  pX₀ : ∀ {n} → Pauli n
  pX₀ {₀} = []
  pX₀ {₁} = pX ∷ []
  pX₀ {₁₊ n} = pX ∷ pIₙ

  pZ₀ : ∀ {n} → Pauli n
  pZ₀ {₀} = []
  pZ₀ {₁} = pZ ∷ []
  pZ₀ {₁₊ n} = pZ ∷ pIₙ

  pX₀Z₀ : ∀ {n} (e : ℤ ₚ) → Pauli n
  pX₀Z₀ {₀} e = []
  pX₀Z₀ {₁} e = (₁ , e) ∷ []
  pX₀Z₀ {₁₊ n} e = (₁ , e) ∷ pIₙ

  pXₙZₙ : ∀ {n} (e : ℤ ₚ) → Pauli n
  pXₙZₙ {₀} e = []
  pXₙZₙ {₁} e = (₁ , e) ∷ []
  pXₙZₙ {₁₊ n} e = pI ∷ pXₙZₙ e

  pXZ : ∀ (e : ℤ ₚ) → Pauli1
  pXZ e = (₁ , e)

  norm1 : Pauli1 → Pauli1 → ℤ ₚ
  norm1 (a , b) (c , d) = (- a) * d + c * b

  norm : ∀ {n} → Pauli n → Pauli n → ℤ ₚ
  norm {₀} [] [] = ₀
  norm {₁₊ n} (x ∷ ps) (y ∷ qs) = norm1 x y + norm ps qs

  open import Algebra.Properties.Ring (+-*-ring p-2)

  norm1-antisym : ∀ (p q : Pauli1) -> norm1 p q ≡ - norm1 q p
  norm1-antisym p@(a , b) q@(c , d) = begin
    norm1 (a , b) (c , d) ≡⟨ auto ⟩
    (- a) * d + c * b ≡⟨ +-comm (- a * d) (c * b) ⟩
    (c * b) + - a * d ≡⟨ Eq.cong (_+ - a * d) (Eq.cong (_* b) (Eq.sym (-‿involutive c))) ⟩
    (- - c * b) + - a * d ≡⟨ Eq.cong₂ _+_ (Eq.sym (-‿distribˡ-* (- c) b)) (Eq.sym (-‿distribˡ-* a d)) ⟩
    - (- c * b) + - (a * d) ≡⟨ (-‿+-comm (- c * b) (a * d)) ⟩
    - ((- c) * b + a * d) ≡⟨ auto ⟩
    - norm1 (c , d) (a , b) ∎
    where
    open import Data.Integer.Tactic.RingSolver
    open ≡-Reasoning

  norm-antisym1 : ∀ (p q : Pauli 1) -> norm p q ≡ - norm q p
  norm-antisym1 p@((a , b) ∷ []) q@((c , d) ∷ []) = begin
    norm1 (a , b) (c , d) + ₀ ≡⟨ +-identityʳ (norm1 (a , b) (c , d)) ⟩
    norm1 (a , b) (c , d) ≡⟨ norm1-antisym (a , b) (c , d) ⟩
    - norm1 (c , d) (a , b) ≡⟨ Eq.cong -_ (Eq.sym (+-identityʳ (norm1 (c , d) (a , b)))) ⟩
    - (norm1 (c , d) (a , b) + ₀) ∎
    where
    open import Data.Integer.Tactic.RingSolver
    open ≡-Reasoning

  0≢1 : 0 ≢ 1
  0≢1 ()

  0≢1+n : ∀ n -> 0 ≢ ₁₊ n
  0≢1+n n ()

{-
  A : Set
  A = Σ[ ab ∈ (Fin 3 × Fin 3) ] (ab ≢ (0 , 0))

  F : Set
  F = Fin 3 × Fin 3

  G : Set
  G = Fin 2 × Fin 3

  B : Set
  B = Fin 3 × Fin 3

  D : Set
  D = Fin 3 × Fin 3

  E : Set
  E = Fin 3
  E' = E

  L' : (j : ℕ) → Set
  L' j = Vec B j × A

  jL = Σ[ j ∈ ℕ ] L' j
  
  L : (n : ℕ) → Set
  L n = Σ[ (j , l) ∈ jL ]  j ≤ n

  M : ℕ → Set
  M n = E × Vec D n

  LM : (n : ℕ) → Set
  LM n = L n × M n

  jLM = Σ[ j ∈ ℕ ] (LM j)

  [_]ᵃ : ∀ {n} → A → Word (Gen (₁₊ n))
  [_]ᵃ {n} ((₀ , ₀) , prf) with prf auto
  ... | ()
  [_]ᵃ {n} ((₀ , ₁) , prf) = ε
  [_]ᵃ {n} ((₀ , ₂) , prf) = [ (- ₂ , ₀) , (λ ()) ]ᵃ • H
--  [_]ᵃ {n} ((₂ , ₀) , prf) = H ^ 3
  [_]ᵃ {n} ((₁ , b) , prf) = H • S ^ -b
    where
    -b = toℕ (- b)
  [_]ᵃ {n} ((a''@(₂₊ a') , b'') , prf) = H • S ^ -a • H • S ^ -a⁻¹[b+1]
    where
    -a⁻¹[b+1]' = - a'' ⁻¹ * (₁ + b'')
    -a⁻¹[b+1] = toℕ -a⁻¹[b+1]'
    -a = toℕ (- a'')

  [_]ᵇ : ∀ {n} → B → Word (Gen (₂₊ n))
  [_]ᵇ {n} (₀ , ₀) = Ex
  [_]ᵇ {n} (₀ , ₁) = H ↑ ^ 3 • CZ • H ↑ • Ex
  [_]ᵇ {n} (a@₀ , b@(₂)) = [ ₀ , ₁ ]ᵇ • [ (a , b) , (λ ()) ]ᵃ ↑
  [_]ᵇ {n} (a@(suc a') , b) = [ ₀ , ₁ ]ᵇ • [ (a , b) , (λ ()) ]ᵃ ↑


{- Sarah's B box
  [_]ᵇ : ∀ {n} → B → Word (Gen (₂₊ n))
  [_]ᵇ {n} (₀ , ₀) = Ex • CZ
  [_]ᵇ {n} (₀ , ₁) = H ↑ ^ 3 • CZ • H ↑ • CZ • CZ • Ex
  [_]ᵇ {n} (a@₀ , b@(₂)) = [ ₀ , ₁ ]ᵇ • CZ • [ (a , b) , (λ ()) ]ᵃ ↑
  [_]ᵇ {n} (a@(suc a') , b) = [ ₀ , ₁ ]ᵇ • CZ • CZ • [ (a , b) , (λ ()) ]ᵃ ↑
-}


  -- F sends XᵃZᵇ to Zᵃ if a ≠ 0, otherwise F is identity.
  [_]ᶠ : ∀ {n} → F → Word (Gen (₁₊ n))
  [_]ᶠ {n} (₀ , _) = ε
--  [_]ᶠ {n} (x@(₁₊ _) , ₀) = H
  [_]ᶠ {n} (x@(₁₊ _) , y) = H • S ^ k
    where
    k = toℕ (- y * x ⁻¹)

  -- G sends X¹⁺ᵃZᵇ to X.
  [_]ᵍ : ∀ {n} → G → Word (Gen (₁₊ n))
  [_]ᵍ {n} (a , b) = (H ^ 2) ^ h • S ^ k
    where
    h = toℕ a
    k = toℕ (- b * (₁₊ a) ⁻¹)

  -- NOTE: [ G ]ᵍ × [ F ]ᶠ ≈ Sp(1,3)

  [_]ᵈ : ∀ {n} → D → Word (Gen (₂₊ n))
  [_]ᵈ {n} (₀ , y) = CZ ^ y' • Ex
    where
    y' = toℕ (- y)
  [_]ᵈ {n} a@(x@(₁₊ _) , y) = [ ₀ , x ]ᵈ • [ a ]ᶠ


{- last used.
  [_]ᵈ : ∀ {n} → D → Word (Gen (₂₊ n))
  [_]ᵈ {n} (₀ , ₀) = Ex
  [_]ᵈ {n} a@(_ , ₁₊ _) = CZ ^ 2 • Ex • [ a , (λ ()) ]ᵃ
  [_]ᵈ {n} a@(₁₊ _ , _) = CZ ^ 2 • Ex • [ a , (λ ()) ]ᵃ 
-}

{- Another choice of dbox
  [_]ᵈ : ∀ {n} → D → Word (Gen (₂₊ n))
  [_]ᵈ {n} (₀ , ₀) = Ex
  [_]ᵈ {n} (₀ , ₂) = CZ • Ex
  [_]ᵈ {n} a@(₀ , ₁) = [ ₀ , ₂ ]ᵈ • H ^ 2 • [ a , (λ ()) ]ᵃ
  [_]ᵈ {n} a@(₁₊ _ , _) = [ ₀ , ₂ ]ᵈ • H ^ 2 • [ a , (λ ()) ]ᵃ 
-}

  [_]ᵉ : ∀ {n} → E → Word (Gen (₁₊ n))
  [_]ᵉ {n} b = S ^ toℕ b

  [_]ᵉ' : ∀ {n} → E' → Word (Gen (₂₊ n))
  [_]ᵉ' {n} b = CZ ^ toℕ b

  [_]ᵛᵇ : ∀ {n} → Vec B n → Word (Gen (₁₊ n))
  [_]ᵛᵇ {₀} [] = ε
  [_]ᵛᵇ {suc n} (x ∷ v) = [ v ]ᵛᵇ ↑ • [ x ]ᵇ

  [_]ᵛᵈ : ∀ {n} → Vec D n → Word (Gen (₁₊ n))
  [_]ᵛᵈ {₀} [] = ε
  [_]ᵛᵈ {suc n} (x ∷ v) = [ x ]ᵈ • [ v ]ᵛᵈ ↑

  [_]ᵐ : ∀ {n} → M n → Word (Gen (₁₊ n))
  [_]ᵐ {n} (e , ds) = [ e ]ᵉ • [ ds ]ᵛᵈ

  abox : ∀ {j n} → j ≤ n → A → Word (Gen (₁₊ n))
  abox {₀} {₀} z≤n a = [ a ]ᵃ
  abox {₀} {₁₊ n} z≤n a = abox {₀} {n} z≤n a ↑
  abox {₁₊ j} {₁₊ n} (s≤s j≤n) a = abox {j} {n} (j≤n) a ↓

  bbox : ∀ {j n} → j ≤ n → B → Word (Gen (₂₊ n))
  bbox {₀} {₀} z≤n b = [ b ]ᵇ
  bbox {₀} {₁₊ n} z≤n b = bbox {₀} {n} z≤n b ↑
  bbox {₁₊ j} {₁₊ n} (s≤s j≤n) b = bbox {j} {n} (j≤n) b ↓

  lemma-[]ᵇ : ∀ {n} b → ([_]ᵇ {n} b ↓) ≡ [ b ]ᵇ
  lemma-[]ᵇ {n} (₀ , ₀) = auto
  lemma-[]ᵇ {n} (₀ , ₁) = auto
  lemma-[]ᵇ {n} (₀ , ₂) = auto
  lemma-[]ᵇ {n} (₁ , ₀) = auto
  lemma-[]ᵇ {n} (₁ , ₁) = auto
  lemma-[]ᵇ {n} (₁ , ₂) = auto
  lemma-[]ᵇ {n} (₂ , ₀) = auto
  lemma-[]ᵇ {n} (₂ , ₁) = auto
  lemma-[]ᵇ {n} (₂ , ₂) = auto


  lemma-bbox : ∀ {n} b → (bbox (NP.≤-reflexive {n} auto) b ↓) ≡ [ b ]ᵇ
  lemma-bbox {₀} (₀ , ₀) = auto
  lemma-bbox {₀} (₀ , ₁) = auto
  lemma-bbox {₀} (₀ , ₂) = auto
  lemma-bbox {₀} (₁ , ₀) = auto
  lemma-bbox {₀} (₁ , ₁) = auto
  lemma-bbox {₀} (₁ , ₂) = auto
  lemma-bbox {₀} (₂ , ₀) = auto
  lemma-bbox {₀} (₂ , ₁) = auto
  lemma-bbox {₀} (₂ , ₂) = auto
  lemma-bbox {₁₊ n} b = begin
    ((bbox (NP.≤-reflexive auto) b ↓) ↓) ≡⟨ Eq.cong _↓ (lemma-bbox b) ⟩
    ([ b ]ᵇ ↓) ≡⟨ lemma-[]ᵇ b ⟩
    [ b ]ᵇ ∎
    where open ≡-Reasoning


  bboxes : ∀ {j n} → j ≤ n → Vec B j → Word (Gen (₁₊ n))
  bboxes {₀} {n} j≤n [] = ε
  bboxes {₁₊ j} {₁₊ n} (s≤s j≤n) (b ∷ v) = bboxes j≤n v ↑ • bbox j≤n b

  lemma-bboxes : ∀ {n} (vb : Vec B n) → bboxes (NP.≤-reflexive auto) vb ≡ [ vb ]ᵛᵇ
  lemma-bboxes {₀} [] = auto
  lemma-bboxes {₁} (b ∷ []) = auto
  lemma-bboxes {₂₊ n} (b ∷ vb) = Eq.cong₂ _•_ (Eq.cong _↑ (lemma-bboxes vb)) (lemma-bbox b) 

  [_]ˡ' : ∀ {j} → L' j → Word (Gen (₁₊ j))
  [_]ˡ' {j} (bs , a) = [ bs ]ᵛᵇ • [ a ]ᵃ

  [_]ˡ : ∀ {n} → L n → Word (Gen (₁₊ n))
  [_]ˡ {n} ((j , bs , a) , j≤n) = bboxes j≤n bs • abox j≤n a

  [_] : ∀ {n} → LM n → Word (Gen (₁₊ n))
  [_] {n} (l , m) = [ m ]ᵐ • [ l ]ˡ

-}


{-
  norm1-antisym' : ∀ (p q : Pauli1) -> norm1 p q ≡ - norm1 q p
  norm1-antisym' p@(a , b) q@(c , d) = begin
    norm1 (a , b) (c , d) ≡⟨ solve p-2 {!4!} {!!} {!!} ⟩
    (- a) * d + c * b ≡⟨ {!\ a b c d -> (solve p-2 4 ? ?)!} ⟩
    - ((- c) * b + a * d) ≡⟨ solve p-2 {!4!} {!!} {!!} ⟩
    - norm1 (c , d) (a , b) ∎
    where
    open ≡-Reasoning
    aux2 : ∀ a b c d e -> - e * ((a) * d + c * b) ≡ - e * (c * b + (a) * d)
    aux2 = solve p-2 5 (\ a b c d e -> (⊝ e) ⊗ ((a) ⊗ d ⊕ c ⊗ b) , (⊝ e) ⊗ (c ⊗ b ⊕ (a) ⊗ d)) λ {x} {x = x₁} {x = x₂} {x = x₃} {x = x₄} → Eq.refl

    aux3 : ∀ a b -> a * b ≡ b * a
    aux3 = solve p-2 2 (\ a b -> a ⊗ b , b ⊗ a) λ {x} {x = x₁} → Eq.refl

-}

  module Two-Qupit-Completeness where

{-
    aux1 : ∀ (p : Pauli 1) -> norm pIₙ p ≡ 0
    aux1 p = {!!}

    Theorem-NF :
    
      ∀ (p q : Pauli 1) ->
      norm p q ≡ 1 ->
      -------------------------------
      ∃ \ nf -> act ⟦ nf ⟧ p ≡ pZ₀ ×
                act ⟦ nf ⟧ q ≡ pX₀
      
    Theorem-NF p@((₀ , ₀) ∷ []) q@(q1 ∷ []) eq with 0ₚ≢1ₚ (Eq.trans (Eq.sym (aux1 q)) eq)
    ... | ()
    Theorem-NF p@((₀ , ₁₊ b) ∷ []) q@((₀ , ₀) ∷ []) eq = {!!}
    Theorem-NF p@((₀ , ₁₊ b) ∷ []) q@((₀ , ₁₊ d) ∷ []) eq = {!!}
    Theorem-NF p@((₀ , ₁₊ b) ∷ []) q@((₁₊ c , ₀) ∷ []) eq = {!!}
    Theorem-NF p@((₀ , ₁₊ b) ∷ []) q@((₁₊ c , ₁₊ d) ∷ []) eq = {!!}
    Theorem-NF p@((₁₊ a , ₀) ∷ []) q@((₀ , ₀) ∷ []) eq = {!!}
    Theorem-NF p@((₁₊ a , ₀) ∷ []) q@((₀ , ₁₊ d) ∷ []) eq = {!!}
    Theorem-NF p@((₁₊ a , ₀) ∷ []) q@((₁₊ c , ₀) ∷ []) eq = {!!}
    Theorem-NF p@((₁₊ a , ₀) ∷ []) q@((₁₊ c , ₁₊ d) ∷ []) eq = {!!}
    Theorem-NF p@((₁₊ a , ₁₊ b) ∷ []) q@((₀ , ₀) ∷ []) eq = {!!}
    Theorem-NF p@((₁₊ a , ₁₊ b) ∷ []) q@((₀ , ₁₊ d) ∷ []) eq = {!!}
    Theorem-NF p@((₁₊ a , ₁₊ b) ∷ []) q@((₁₊ c , ₀) ∷ []) eq = {!!}
    Theorem-NF p@((₁₊ a , ₁₊ b) ∷ []) q@((₁₊ c , ₁₊ d) ∷ []) eq = {!!}
  -}

{-
  prop-abox : ∀ {n} (p : Pauli1) (p≢I : p ≢ pI) (ps : Pauli n) → 
    act [ p , p≢I ]ᵃ (p ∷ ps) ≡ (₀ , ₁) ∷ ps
  prop-abox (₀ , ₀) p≢I ps with p≢I auto
  ... | ()
  prop-abox (₀ , ₁) p≢I ps = auto
  prop-abox (₀ , ₂) p≢I ps = auto
  prop-abox (₁ , ₀) p≢I ps = auto
  prop-abox (₁ , ₁) p≢I ps = auto
  prop-abox (₁ , ₂) p≢I ps = auto
  prop-abox (₂ , ₀) p≢I ps = auto
  prop-abox (₂ , ₁) p≢I ps = auto
  prop-abox (₂ , ₂) p≢I ps = auto

  neqeq : ∀ x → x ≢ pI ⊎ x ≡ pI
  neqeq (₀ , ₀) = inj₂ auto
  neqeq (₀ , ₁) = inj₁ (λ ())
  neqeq (₀ , ₂) = inj₁ (λ ())
  neqeq (₁ , ₀) = inj₁ (λ ())
  neqeq (₁ , ₁) = inj₁ (λ ())
  neqeq (₁ , ₂) = inj₁ (λ ())
  neqeq (₂ , ₀) = inj₁ (λ ())
  neqeq (₂ , ₁) = inj₁ (λ ())
  neqeq (₂ , ₂) = inj₁ (λ ())



  prop-abox-↓ : ∀ {n} (p : Pauli1) (p≢I : p ≢ pI) (ps : Pauli (₁₊ n)) → 
    act ([ p , p≢I ]ᵃ ↓) (p ∷ ps) ≡ (₀ , ₁) ∷ ps
  prop-abox-↓ (₀ , ₀) p≢I ps with p≢I auto
  ... | ()
  prop-abox-↓ (₀ , ₁) p≢I ps = auto
  prop-abox-↓ (₀ , ₂) p≢I ps = auto
  prop-abox-↓ (₁ , ₀) p≢I ps = auto
  prop-abox-↓ (₁ , ₁) p≢I ps = auto
  prop-abox-↓ (₁ , ₂) p≢I ps = auto
  prop-abox-↓ (₂ , ₀) p≢I ps = auto
  prop-abox-↓ (₂ , ₁) p≢I ps = auto
  prop-abox-↓ (₂ , ₂) p≢I ps = auto

  lemma-[]ᵃ : ∀ {n} a → ([_]ᵃ {n} a ↓) ≡ [ a ]ᵃ
  lemma-[]ᵃ ((₀ , ₀) , p≢I) with p≢I auto
  ... | ()
  lemma-[]ᵃ ((₀ , ₁) , p≢I) = auto
  lemma-[]ᵃ ((₀ , ₂) , p≢I) = auto
  lemma-[]ᵃ ((₁ , ₀) , p≢I) = auto
  lemma-[]ᵃ ((₁ , ₁) , p≢I) = auto
  lemma-[]ᵃ ((₁ , ₂) , p≢I) = auto
  lemma-[]ᵃ ((₂ , ₀) , p≢I) = auto
  lemma-[]ᵃ ((₂ , ₁) , p≢I) = auto
  lemma-[]ᵃ ((₂ , ₂) , p≢I) = auto


  lemma-abox-a : ∀ {n} a → (abox (NP.≤-reflexive {n} auto) a) ≡ [ a ]ᵃ
  lemma-abox-a {₀} ((₀ , ₀) , p≢I) with p≢I auto
  ... | ()
  lemma-abox-a {₀} ((₀ , ₁) , p≢I) = auto
  lemma-abox-a {₀} ((₀ , ₂) , p≢I) = auto
  lemma-abox-a {₀} ((₁ , ₀) , p≢I) = auto
  lemma-abox-a {₀} ((₁ , ₁) , p≢I) = auto
  lemma-abox-a {₀} ((₁ , ₂) , p≢I) = auto
  lemma-abox-a {₀} ((₂ , ₀) , p≢I) = auto
  lemma-abox-a {₀} ((₂ , ₁) , p≢I) = auto
  lemma-abox-a {₀} ((₂ , ₂) , p≢I) = auto
  lemma-abox-a {₁₊ n} a = begin
    (abox (NP.≤-reflexive auto) a ↓) ≡⟨ Eq.cong _↓ (lemma-abox-a a) ⟩
    ( [ a ]ᵃ ↓) ≡⟨ lemma-[]ᵃ a ⟩
    [ a ]ᵃ ∎
    where open ≡-Reasoning

{-
  prop-abox-↓↓ : ∀ {j n} (p : Pauli1) (p≢I : p ≢ pI) (le : j ≤ n) (ps : Pauli n) → 
    act (abox le (p , p≢I)) (p ∷ ps) ≡ (₀ , ₁) ∷ ps
  prop-abox-↓↓ (₀ , ₀) p≢I le ps with p≢I auto
  ... | ()
  prop-abox-↓↓ (₀ , ₁) p≢I le ps = {!!}
  prop-abox-↓↓ (₀ , ₂) p≢I le ps = {!!}
  prop-abox-↓↓ (₁ , ₀) p≢I le ps = {!!}
  prop-abox-↓↓ (₁ , ₁) p≢I le ps = {!!}
  prop-abox-↓↓ (₁ , ₂) p≢I le ps = {!!}
  prop-abox-↓↓ (₂ , ₀) p≢I le ps = {!!}
  prop-abox-↓↓ (₂ , ₁) p≢I le ps = {!!}
  prop-abox-↓↓ (₂ , ₂) p≢I le ps = {!!}
-}

  prop-bbox : ∀ {n} (p : Pauli1) (ps : Pauli n) → act [ p ]ᵇ (pZ ∷ p ∷ ps) ≡ pI ∷ pZ ∷ ps
  prop-bbox (₀ , ₀) ps = auto
  prop-bbox (₀ , ₁) ps = auto
  prop-bbox (₀ , ₂) ps = auto
  prop-bbox (₁ , ₀) ps = auto
  prop-bbox (₁ , ₁) ps = auto
  prop-bbox (₁ , ₂) ps = auto
  prop-bbox (₂ , ₀) ps = auto
  prop-bbox (₂ , ₁) ps = auto
  prop-bbox (₂ , ₂) ps = auto

  prop-dbox : ∀ {n} (p : Pauli1) (ps : Pauli n) → act [ p ]ᵈ (p ∷ pX ∷ ps) ≡ pX ∷ pI ∷ ps
  prop-dbox (₀ , ₀) ps = auto
  prop-dbox (₀ , ₁) ps = auto
  prop-dbox (₀ , ₂) ps = auto
  prop-dbox (₁ , ₀) ps = auto
  prop-dbox (₁ , ₁) ps = auto
  prop-dbox (₁ , ₂) ps = auto
  prop-dbox (₂ , ₀) ps = auto
  prop-dbox (₂ , ₁) ps = auto
  prop-dbox (₂ , ₂) ps = auto


  prop-dbox-XZᵇ : ∀ {n} (p : Pauli1) (ᵇ : ℤ ₚ) (ps : Pauli n) → act [ p ]ᵈ (p ∷ pXZ ᵇ ∷ ps) ≡ pXZ ᵇ ∷ pI ∷ ps
  prop-dbox-XZᵇ (₀ , ₀) ₀ ps = auto
  prop-dbox-XZᵇ (₀ , ₀) ₁ ps = auto
  prop-dbox-XZᵇ (₀ , ₀) ₂ ps = auto
  prop-dbox-XZᵇ (₀ , ₁) ₀ ps = auto
  prop-dbox-XZᵇ (₀ , ₁) ₁ ps = auto
  prop-dbox-XZᵇ (₀ , ₁) ₂ ps = auto
  prop-dbox-XZᵇ (₀ , ₂) ₀ ps = auto
  prop-dbox-XZᵇ (₀ , ₂) ₁ ps = auto
  prop-dbox-XZᵇ (₀ , ₂) ₂ ps = auto
  prop-dbox-XZᵇ (₁ , ₀) ₀ ps = auto
  prop-dbox-XZᵇ (₁ , ₀) ₁ ps = auto
  prop-dbox-XZᵇ (₁ , ₀) ₂ ps = auto
  prop-dbox-XZᵇ (₁ , ₁) ₀ ps = auto
  prop-dbox-XZᵇ (₁ , ₁) ₁ ps = auto
  prop-dbox-XZᵇ (₁ , ₁) ₂ ps = auto
  prop-dbox-XZᵇ (₁ , ₂) ₀ ps = auto
  prop-dbox-XZᵇ (₁ , ₂) ₁ ps = auto
  prop-dbox-XZᵇ (₁ , ₂) ₂ ps = auto
  prop-dbox-XZᵇ (₂ , ₀) ₀ ps = auto
  prop-dbox-XZᵇ (₂ , ₀) ₁ ps = auto
  prop-dbox-XZᵇ (₂ , ₀) ₂ ps = auto
  prop-dbox-XZᵇ (₂ , ₁) ₀ ps = auto
  prop-dbox-XZᵇ (₂ , ₁) ₁ ps = auto
  prop-dbox-XZᵇ (₂ , ₁) ₂ ps = auto
  prop-dbox-XZᵇ (₂ , ₂) ₀ ps = auto
  prop-dbox-XZᵇ (₂ , ₂) ₁ ps = auto
  prop-dbox-XZᵇ (₂ , ₂) ₂ ps = auto


  prop-ebox : ∀ {n} (b : ℤ ₚ) (p : Pauli n) → 
    act [ - b ]ᵉ ((₁ , b) ∷ p) ≡ (₁ , ₀) ∷ p
  prop-ebox {n} ₀ p = auto
  prop-ebox {n} ₁ p = auto
  prop-ebox {n} ₂ p = auto

  prop-ebox-dual : ∀ {n} (b : ℤ ₚ) → 
    act ([_]ᵉ {n} b) pZ₀ ≡ pZ₀
  prop-ebox-dual {₀} ₀ = auto
  prop-ebox-dual {₀} ₁ = auto
  prop-ebox-dual {₀} ₂ = auto
  prop-ebox-dual {₁₊ n} ₀ = auto
  prop-ebox-dual {₁₊ n} ₁ = auto
  prop-ebox-dual {₁₊ n} ₂ = auto

  prop-dbox-Z : ∀ {n} (p : Pauli1) (ps : Pauli n) → act [ p ]ᵈ (pI ∷ pZ ∷ ps) ≡ pZ ∷ pI ∷ ps
  prop-dbox-Z (₀ , ₀) ps = auto
  prop-dbox-Z (₀ , ₁) ps = auto
  prop-dbox-Z (₀ , ₂) ps = auto
  prop-dbox-Z (₁ , ₀) ps = auto
  prop-dbox-Z (₁ , ₁) ps = auto
  prop-dbox-Z (₁ , ₂) ps = auto
  prop-dbox-Z (₂ , ₀) ps = auto
  prop-dbox-Z (₂ , ₁) ps = auto
  prop-dbox-Z (₂ , ₂) ps = auto



{-
  prop-bbox-X : ∀ {n} (p : Pauli1) (ps : Pauli n) → ∃ \ q → (act [ p ]ᵇ (pX ∷ p ∷ ps)) ≡ q ∷ pX ∷ ps
  prop-bbox-X (₀ , ₀) p = (₀ , ₀) , auto
  prop-bbox-X (₀ , ₁) p = (₀ , ₁ + 2F * pX .proj₂) , auto
  prop-bbox-X (₀ , ₂) p = (2F *
                            (2F * (2F * ₂ + (2F * ₂ + ₀)) +
                             (2F * (2F * ₂ + (2F * ₂ + ₀)) + 2F * ₂))
                            , 2F * (2F * ₂ + (2F * ₂ + ₀)) + 2F * pX .proj₂)
                           , auto
  prop-bbox-X (₁ , ₀) p = (2F * (2F * (2F * (₁ + ₀)) + 2F * ₁) ,
                            2F * (2F * (₁ + ₀)) + 2F * pX .proj₂)
                           , auto
  prop-bbox-X (₁ , ₁) p = (2F *
                            (2F *
                             (2F * (2F * (2F * ₁) + (2F * (2F * ₁) + 2F * ₁)) +
                              (2F * (2F * (2F * ₁) + (2F * (2F * ₁) + 2F * ₁)) + 2F * (2F * ₁)))
                             + 2F * (2F * (2F * ₁) + (2F * (2F * ₁) + 2F * ₁)))
                            ,
                            2F *
                            (2F * (2F * (2F * ₁) + (2F * (2F * ₁) + 2F * ₁)) +
                             (2F * (2F * (2F * ₁) + (2F * (2F * ₁) + 2F * ₁)) + 2F * (2F * ₁)))
                            + 2F * pX .proj₂)
                           , auto
  prop-bbox-X (₁ , ₂) p = (2F * (2F * (2F * (2F * ₂) + (2F * (2F * ₂) + 2F * ₁))) ,
                            2F *
                            (2F * (2F * (2F * ₂) + (2F * (2F * ₂) + 2F * ₁)) +
                             (2F * (2F * (2F * ₂) + (2F * (2F * ₂) + 2F * ₁)) + 2F * (2F * ₂)))
                            + 2F * pX .proj₂)
                           , auto
  prop-bbox-X (₂ , ₀) p = (2F *
                            (2F * (2F * (₂ + (₂ + ₀))) + (2F * (2F * (₂ + (₂ + ₀))) + 2F * ₂))
                            , 2F * (2F * (₂ + (₂ + ₀))) + 2F * pX .proj₂)
                           , auto
  prop-bbox-X (₂ , ₁) p = (2F *
                            (2F * (2F * (2F * (2F * ₁) + 2F * ₂) + 2F * (2F * ₁)) +
                             (2F * (2F * (2F * (2F * ₁) + 2F * ₂) + 2F * (2F * ₁)) +
                              2F * (2F * (2F * ₁) + 2F * ₂)))
                            ,
                            2F * (2F * (2F * (2F * ₁) + 2F * ₂) + 2F * (2F * ₁)) +
                            2F * pX .proj₂)
                           , auto
  prop-bbox-X (₂ , ₂) p = (2F * (2F * (2F * (2F * ₂) + 2F * ₂)) ,
                            2F * (2F * (2F * (2F * ₂) + 2F * ₂) + 2F * (2F * ₂)) +
                            2F * pX .proj₂)
                           , auto
-}

  prop-dbox-I : ∀ {n} (p : Pauli1) (ps : Pauli n) → act [ p ]ᵈ (pI ∷ pI ∷ ps) ≡ pI ∷ pI ∷ ps
  prop-dbox-I (₀ , ₀) ps = auto
  prop-dbox-I (₀ , ₁) ps = auto
  prop-dbox-I (₀ , ₂) ps = auto
  prop-dbox-I (₁ , ₀) ps = auto
  prop-dbox-I (₁ , ₁) ps = auto
  prop-dbox-I (₁ , ₂) ps = auto
  prop-dbox-I (₂ , ₀) ps = auto
  prop-dbox-I (₂ , ₁) ps = auto
  prop-dbox-I (₂ , ₂) ps = auto


  prop-dboxes : ∀ {n} (vd : Vec D n) → act [ vd ]ᵛᵈ (pZₙ) ≡ pZ₀
  prop-dboxes {₀} [] = auto
  prop-dboxes {₁} (x ∷ []) = prop-dbox-Z x pIₙ
  prop-dboxes {₂₊ n} vd@(x ∷ ds) = begin
    act [ vd ]ᵛᵈ (pI ∷ pI ∷ pZₙ) ≡⟨ auto ⟩
    act [ x ]ᵈ  (act ([ ds ]ᵛᵈ ↑) (pI ∷ pI ∷ pZₙ)) ≡⟨ Eq.cong (act [ x ]ᵈ) (lemma-act-↑ [ ds ]ᵛᵈ pI (pI ∷ pZₙ)) ⟩
    act [ x ]ᵈ  (pI ∷ act [ ds ]ᵛᵈ (pI ∷ pZₙ)) ≡⟨ Eq.cong (\ □ → act [ x ]ᵈ  (pI ∷ □)) (prop-dboxes ds) ⟩
    act [ x ]ᵈ  (pI ∷ (pZ ∷ pIₙ)) ≡⟨ prop-dbox-Z x pIₙ ⟩
    pZ ∷ (₀ , ₀) ∷ (₀ , ₀) ∷ pIₙ ∎
    where open ≡-Reasoning

  last-∷ : ∀ {n}{A : Set}{a : A} {as : Vec A (₁₊ n)} → last (a ∷ as) ≡ last as
  last-∷ {₀} {A} {a} {x ∷ []} = auto
  last-∷ {₁₊ n} {A} {a} {x ∷ x₁ ∷ as} rewrite last-∷ {n} {A} {a} {x₁ ∷ as} = ih
    where
    ih = last-∷ {n} {A} {a} {x₁ ∷ as}

  prop-∃-dboxes : ∀ {n} (ps : Pauli (₁₊ n)) (eqX : last ps ≡ pX) → ∃ \ vd → act [ vd ]ᵛᵈ ps ≡ pX₀
  prop-∃-dboxes {₀} (x ∷ []) eqX rewrite eqX = [] , auto
  prop-∃-dboxes {₁} (x ∷ y ∷ []) eqX rewrite eqX = x ∷ [] , prop-dbox x []
  prop-∃-dboxes {₂₊ n} (x ∷ y ∷ ps) eqX = x ∷ proj₁ ih , (begin
    act [ x ]ᵈ (act ([ proj₁ ih ]ᵛᵈ ↑) (x ∷ y ∷ ps)) ≡⟨ Eq.cong (act [ x ]ᵈ) (lemma-act-↑ [ proj₁ ih ]ᵛᵈ x (y ∷ ps)) ⟩
    act [ x ]ᵈ (x ∷ act ([ proj₁ ih ]ᵛᵈ) (y ∷ ps)) ≡⟨ Eq.cong (\ □ → act [ x ]ᵈ (x ∷ □)) (proj₂ ih) ⟩
    act [ x ]ᵈ (x ∷ pX₀) ≡⟨ prop-dbox x pIₙ ⟩
    pX ∷ (₀ , ₀) ∷ (₀ , ₀) ∷ pIₙ ∎)
    where
    open ≡-Reasoning
    ih : ∃ \ vd → act [ vd ]ᵛᵈ (y ∷ ps) ≡ pX₀
    ih = prop-∃-dboxes {₁₊ n} (y ∷ ps) (Eq.trans (Eq.sym (last-∷ {a = x} {as = y ∷ ps})) eqX)


  prop-∃-dboxes-XZ : ∀ {n} {ᵉ} (ps : Pauli (₁₊ n)) (eqX : last ps ≡ (₁ , ᵉ)) → ∃ \ vd → act [ vd ]ᵛᵈ ps ≡ pX₀Z₀ ᵉ
  prop-∃-dboxes-XZ {₀} {ᵉ} (x ∷ []) eqX rewrite eqX = [] , auto
  prop-∃-dboxes-XZ {₁} {ᵉ} (x ∷ y ∷ []) eqX rewrite eqX = x ∷ [] , prop-dbox-XZᵇ x ᵉ []
  prop-∃-dboxes-XZ {₂₊ n} {ᵉ} (x ∷ y ∷ ps) eqX = x ∷ proj₁ ih , (begin
    act [ x ]ᵈ (act ([ proj₁ ih ]ᵛᵈ ↑) (x ∷ y ∷ ps)) ≡⟨ Eq.cong (act [ x ]ᵈ) (lemma-act-↑ [ proj₁ ih ]ᵛᵈ x (y ∷ ps)) ⟩
    act [ x ]ᵈ (x ∷ act ([ proj₁ ih ]ᵛᵈ) (y ∷ ps)) ≡⟨ Eq.cong (\ □ → act [ x ]ᵈ (x ∷ □)) (proj₂ ih) ⟩
    act [ x ]ᵈ (x ∷ pX₀Z₀ ᵉ) ≡⟨ prop-dbox-XZᵇ x ᵉ pIₙ ⟩
    pX₀Z₀ ᵉ ∎)
    where
    open ≡-Reasoning
    ih : ∃ \ vd → act [ vd ]ᵛᵈ (y ∷ ps) ≡ pX₀Z₀ ᵉ
    ih = prop-∃-dboxes-XZ {₁₊ n} {ᵉ} (y ∷ ps) (Eq.trans (Eq.sym (last-∷ {a = x} {as = y ∷ ps})) eqX)


  prop-∃-bboxes : ∀ {n} (ps : Pauli (₁₊ n)) (eqZ : head ps ≡ pZ) → ∃ \ vb → act [ vb ]ᵛᵇ ps ≡ pZₙ
  prop-∃-bboxes {₀} (x ∷ []) eqZ rewrite eqZ = [] , auto
  prop-∃-bboxes {₁} (x ∷ y ∷ []) eqZ rewrite eqZ = (y ∷ []) , (prop-bbox y [])
  prop-∃-bboxes {₂₊ n} (x ∷ y ∷ z ∷ ps) eqZ rewrite eqZ = y ∷ proj₁ ih , (begin
    act ([ proj₁ ih ]ᵛᵇ ↑) (act [ y ]ᵇ (pZ ∷ y ∷ z ∷ ps)) ≡⟨ Eq.cong (act ([ proj₁ ih ]ᵛᵇ ↑)) (prop-bbox y (z ∷ ps)) ⟩
    act ([ proj₁ ih ]ᵛᵇ ↑) (pI ∷ pZ ∷ z ∷ ps) ≡⟨ lemma-act-↑ [ proj₁ ih ]ᵛᵇ pI (pZ ∷ z ∷ ps) ⟩
    pI ∷ act ([ proj₁ ih ]ᵛᵇ) (pZ ∷ z ∷ ps) ≡⟨ Eq.cong (pI ∷_) (proj₂ ih) ⟩
    pI ∷ pI ∷ pZₙ ∎)
    where
    open ≡-Reasoning
    ih : ∃ \ vd → act [ vd ]ᵛᵇ (pZ ∷ z ∷ ps) ≡ pZₙ
    ih = prop-∃-bboxes (pZ ∷ z ∷ ps) auto

  prop-∃-M : ∀ {n} {e} (ps : Pauli (₁₊ n)) (eqX : last ps ≡ (₁ , e)) → ∃ \ m → act [ m ]ᵐ ps ≡ pX₀
  prop-∃-M {0} {e} (x ∷ []) eqX rewrite eqX = (- e , []) , prop-ebox e []
  prop-∃-M {n@(suc m)} {e} ps eqX = (- e , proj₁ vdp) , (begin
    act [ - e ]ᵉ (act [ proj₁ vdp ]ᵛᵈ ps) ≡⟨ Eq.cong (act [ - e ]ᵉ) (proj₂ vdp) ⟩
    act [ - e ]ᵉ (pX₀Z₀ e) ≡⟨ prop-ebox e pIₙ ⟩
    pX₀ ∎)
    where
    open ≡-Reasoning
    vdp = prop-∃-dboxes-XZ {n} {e} ps eqX

  lemma-init-last : ∀ {n} {A : Set} (vs : Vec A (₁₊ n)) → vs ≡ init vs ∷ʳ last vs
  lemma-init-last (x ∷ []) = auto
  lemma-init-last (x ∷ x₁ ∷ vs) = Eq.cong (x ∷_) (lemma-init-last (x₁ ∷ vs))

  lemma-<⇒≤ : ∀ {j n} (le : j < (₁₊ n)) → NP.<⇒≤ (s≤s le) ≡ s≤s (NP.<⇒≤ le)
  lemma-<⇒≤ (s≤s z≤n) = auto
  lemma-<⇒≤ (s≤s (s≤s le)) = auto

  lemma-sspred : ∀ {j n} (le : j < (₁₊ n)) → s≤s (NP.≤-pred le) ≡ le
  lemma-sspred (s≤s z≤n) = auto
  lemma-sspred (s≤s (s≤s le)) = auto

  lemma-abox : ∀ {n j} p (ps : Pauli (₁₊ n)) (le : j < (₁₊ n)) a (neq : a ≢ pI) →
    act (abox (NP.<⇒≤ le) (a , neq)) (p ∷ ps) ≡ p ∷ act (abox (NP.≤-pred le) (a , neq)) ps
  lemma-abox {₀} {₀} p (x ∷ []) (s≤s z≤n) a neq = lemma-act-↑ ([ a , neq ]ᵃ) p (x ∷ [])
  lemma-abox {₁₊ n} {₀} p (x ∷ x₁ ∷ ps) (s≤s z≤n) a neq = lemma-act-↑ (abox z≤n (a , neq) ↑) p (x ∷ x₁ ∷ ps)
  lemma-abox {₁₊ n} {₁₊ j} p (x ∷ ps) (s≤s le) a neq = begin
    act (abox (NP.<⇒≤ (s≤s le)) (a , neq)) (p ∷ x ∷ ps) ≡⟨ Eq.cong (\ □ → act (abox □ (a , neq)) (p ∷ x ∷ ps)) ( lemma-<⇒≤ le) ⟩
    act (abox (s≤s (NP.<⇒≤ le)) (a , neq)) (p ∷ x ∷ ps) ≡⟨ auto ⟩
    act (abox (NP.<⇒≤ le) (a , neq) ↓) (p ∷ x ∷ ps) ≡⟨ Eq.cong (\ □ → act (abox (NP.<⇒≤ le) (a , neq) ↓) (p ∷ x ∷ □)) (lemma-init-last ps) ⟩
    act (abox (NP.<⇒≤ le) (a , neq) ↓) (p ∷ x ∷ (init ps ∷ʳ last ps)) ≡⟨ auto ⟩
    act (abox (NP.<⇒≤ le) (a , neq) ↓) ((p ∷ x ∷ init ps) ∷ʳ last ps) ≡⟨ lemma-act-↓ (abox (NP.<⇒≤ le) (a , neq)) (last ps) (p ∷ x ∷ init ps) ⟩
    act (abox (NP.<⇒≤ le) (a , neq)) (p ∷ x ∷ init ps) ∷ʳ last ps ≡⟨ Eq.cong (_∷ʳ last ps) (lemma-abox p (x ∷ init ps) le a neq) ⟩
    (p ∷ act (abox (NP.≤-pred le) (a , neq)) (x ∷ init ps)) ∷ʳ last ps ≡⟨ auto ⟩
    p ∷ (act (abox (NP.≤-pred le) (a , neq)) (x ∷ init ps) ∷ʳ last ps) ≡⟨ Eq.cong (p ∷_) (Eq.sym (lemma-act-↓ (abox (NP.≤-pred le) (a , neq)) (last ps) (x ∷ init ps))) ⟩
    p ∷ (act (abox (NP.≤-pred le) (a , neq) ↓) ((x ∷ init ps) ∷ʳ last ps)) ≡⟨ auto ⟩
    p ∷ (act (abox (NP.≤-pred le) (a , neq) ↓) (x ∷ (init ps ∷ʳ last ps))) ≡⟨ Eq.cong (\ □ → p ∷ (act (abox (NP.≤-pred le) (a , neq) ↓) (x ∷ □))) (Eq.sym (lemma-init-last ps)) ⟩
    p ∷ (act (abox (NP.≤-pred le) (a , neq) ↓) (x ∷ ps)) ≡⟨ Eq.sym auto ⟩
    p ∷ act (abox (s≤s (NP.≤-pred le)) (a , neq)) (x ∷ ps) ≡⟨ Eq.cong (\ □ → p ∷ act (abox □ (a , neq)) (x ∷ ps)) (lemma-sspred le) ⟩
    p ∷ act (abox le (a , neq)) (x ∷ ps) ∎
    where
    open ≡-Reasoning

  lemma-bbox2 : ∀ {n j} p (ps : Pauli (₂₊ n)) (le : j < (₁₊ n)) b →
    act (bbox (NP.<⇒≤ le) (b)) (p ∷ ps) ≡ p ∷ act (bbox (NP.≤-pred le) (b)) ps
  lemma-bbox2 {₀} {₀} p (x ∷ x₁ ∷ []) (s≤s z≤n) b = lemma-act-↑ [ b ]ᵇ p (x ∷ x₁ ∷ [])
  lemma-bbox2 {₁₊ n} {₀} p (x ∷ ps) (s≤s z≤n) b = lemma-act-↑ (bbox z≤n b ↑) p (x ∷ ps)
  lemma-bbox2 {₁₊ n} {₁₊ j} p (x ∷ ps) (s≤s le) b = begin
    act (bbox (NP.<⇒≤ (s≤s le)) (b)) (p ∷ x ∷ ps) ≡⟨ Eq.cong (\ □ → act (bbox □ (b)) (p ∷ x ∷ ps)) ( lemma-<⇒≤ le) ⟩
    act (bbox (s≤s (NP.<⇒≤ le)) (b)) (p ∷ x ∷ ps) ≡⟨ auto ⟩
    act (bbox (NP.<⇒≤ le) (b) ↓) (p ∷ x ∷ ps) ≡⟨ Eq.cong (\ □ → act (bbox (NP.<⇒≤ le) (b) ↓) (p ∷ x ∷ □)) (lemma-init-last ps) ⟩
    act (bbox (NP.<⇒≤ le) (b) ↓) (p ∷ x ∷ (init ps ∷ʳ last ps)) ≡⟨ auto ⟩
    act (bbox (NP.<⇒≤ le) (b) ↓) ((p ∷ x ∷ init ps) ∷ʳ last ps) ≡⟨ lemma-act-↓ (bbox (NP.<⇒≤ le) (b)) (last ps) (p ∷ x ∷ init ps) ⟩
    act (bbox (NP.<⇒≤ le) (b)) (p ∷ x ∷ init ps) ∷ʳ last ps ≡⟨ Eq.cong (_∷ʳ last ps) (lemma-bbox2 p (x ∷ init ps) le b) ⟩
    (p ∷ act (bbox (NP.≤-pred le) (b)) (x ∷ init ps)) ∷ʳ last ps ≡⟨ auto ⟩
    p ∷ (act (bbox (NP.≤-pred le) (b)) (x ∷ init ps) ∷ʳ last ps) ≡⟨ Eq.cong (p ∷_) (Eq.sym (lemma-act-↓ (bbox (NP.≤-pred le) (b)) (last ps) (x ∷ init ps))) ⟩
    p ∷ (act (bbox (NP.≤-pred le) (b) ↓) ((x ∷ init ps) ∷ʳ last ps)) ≡⟨ auto ⟩
    p ∷ (act (bbox (NP.≤-pred le) (b) ↓) (x ∷ (init ps ∷ʳ last ps))) ≡⟨ Eq.cong (\ □ → p ∷ (act (bbox (NP.≤-pred le) (b) ↓) (x ∷ □))) (Eq.sym (lemma-init-last ps)) ⟩
    p ∷ (act (bbox (NP.≤-pred le) (b) ↓) (x ∷ ps)) ≡⟨ Eq.sym auto ⟩
    p ∷ act (bbox (s≤s (NP.≤-pred le)) (b)) (x ∷ ps) ≡⟨ Eq.cong (\ □ → p ∷ act (bbox □ (b)) (x ∷ ps)) (lemma-sspred le) ⟩
    p ∷ act (bbox le (b)) (x ∷ ps) ∎
    where
    open ≡-Reasoning

  lemma-↑↓ : ∀ {n} (w : Word (Gen n)) → w ↑ ↓ ≡ w ↓ ↑
  lemma-↑↓ [ x ↑] = auto
  lemma-↑↓ ε = auto
  lemma-↑↓ (w • w₁) = Eq.cong₂ _•_ (lemma-↑↓ w) (lemma-↑↓ w₁)

  lemma-bbox2a : ∀ {n j} (le : j < (₁₊ n)) b →
    bbox (NP.<⇒≤ le) b ≡ bbox (≤-pred le) b ↑
  lemma-bbox2a {₀} {₀} (s≤s z≤n) b = auto
  lemma-bbox2a {₁₊ n} {₀} (s≤s z≤n) b = auto
  lemma-bbox2a {₁₊ n} {₁₊ j} (s≤s (s≤s le)) b = begin
    (bbox (NP.<⇒≤ (s≤s le)) b ↓) ≡⟨ Eq.cong _↓ ih ⟩
    ((bbox le b ↑) ↓) ≡⟨ lemma-↑↓ (bbox le b) ⟩
    ((bbox le b ↓) ↑) ∎
    where
    open ≡-Reasoning
    ih = lemma-bbox2a (s≤s le) b

  lemma-bboxes2a : ∀ {n j} (le : j < (₁₊ n)) vb →
    bboxes (NP.<⇒≤ le) vb ≡ (bboxes (≤-pred le) vb ↑)
  lemma-bboxes2a {₀} {₀} (s≤s z≤n) [] = auto
  lemma-bboxes2a {₁₊ n} {₀} (s≤s le) [] = auto
  lemma-bboxes2a {₁₊ n} {₁₊ j} (s≤s le@(s≤s le')) (x ∷ vb) = begin
    bboxes (NP.<⇒≤ (s≤s le)) (x ∷ vb) ≡⟨ auto ⟩
    bboxes (s≤s (NP.<⇒≤ le)) (x ∷ vb) ≡⟨ auto ⟩
    bboxes (NP.<⇒≤ (le)) (vb) ↑ • bbox (NP.<⇒≤ (le)) x ≡⟨ Eq.cong (bboxes (NP.<⇒≤ (le)) (vb) ↑ •_) (lemma-bbox2a (s≤s le') x) ⟩
    bboxes (NP.<⇒≤ (le)) (vb) ↑ • bbox (≤-pred le) x ↑ ≡⟨ auto ⟩
    (bboxes (NP.<⇒≤ le) (vb) • bbox (≤-pred le) x) ↑ ≡⟨ Eq.cong ( \ □ → (□ • bbox (≤-pred le) x) ↑) ih ⟩
    (bboxes (≤-pred le) vb ↑ • bbox (≤-pred le) x) ↑ ≡⟨ auto ⟩
    (bboxes (s≤s (≤-pred le)) (x ∷ vb) ↑) ≡⟨ auto ⟩
    (bboxes (≤-pred (s≤s le)) (x ∷ vb) ↑) ∎
    where
    open ≡-Reasoning
    ih = lemma-bboxes2a le vb

  lemma-bboxes2 : ∀ {n j} p (ps : Pauli (₁₊ n)) (le : j < (₁₊ n)) vb →
    act (bboxes (NP.<⇒≤ le) vb) (p ∷ ps) ≡ p ∷ act (bboxes (NP.≤-pred le) vb) ps
  lemma-bboxes2 {₀} {₀} p (x ∷ []) (s≤s z≤n) [] = auto
  lemma-bboxes2 {₁₊ n} {₀} p (x ∷ ps) (s≤s z≤n) [] = auto
  lemma-bboxes2 {₁₊ n} {₁₊ j} p (x ∷ ps) (s≤s le@(s≤s le')) (b ∷ vb) = begin
    act (bboxes (NP.<⇒≤ (s≤s le)) (b ∷ vb)) (p ∷ x ∷ ps) ≡⟨ auto ⟩
    act (bboxes (s≤s (NP.<⇒≤ le)) (b ∷ vb)) (p ∷ x ∷ ps) ≡⟨ auto ⟩
    act (bboxes (NP.<⇒≤ (le)) vb ↑ • bbox (NP.<⇒≤ le) b) (p ∷ x ∷ ps) ≡⟨ auto ⟩
    act (bboxes (NP.<⇒≤ (le)) vb ↑) (act (bbox (NP.<⇒≤ le) b) (p ∷ x ∷ ps)) ≡⟨ Eq.cong (act (bboxes (NP.<⇒≤ (le)) vb ↑)) (lemma-bbox2 p (x ∷ ps) le b) ⟩
    act (bboxes (NP.<⇒≤ (le)) vb ↑) (p ∷ act (bbox (NP.≤-pred le) b) (x ∷ ps)) ≡⟨ lemma-act-↑ (bboxes (NP.<⇒≤ (le)) vb) p (act (bbox (≤-pred le) b) (x ∷ ps)) ⟩
    p ∷ act (bboxes (NP.<⇒≤ (le)) vb) (act (bbox (NP.≤-pred le) b) (x ∷ ps)) ≡⟨ auto ⟩
    p ∷ act (bboxes (NP.<⇒≤ (le)) vb) (act (bbox (NP.≤-pred le) b) (x ∷ ps)) ≡⟨ Eq.cong (\ □ → p ∷ act (□) (act (bbox (NP.≤-pred le) b) (x ∷ ps))) (lemma-bboxes2a (s≤s le') vb) ⟩
    p ∷ act (bboxes ((≤-pred le)) (vb) ↑) (act (bbox ((≤-pred le)) b) (x ∷ ps))  ≡⟨ auto ⟩
    p ∷ act (bboxes ((≤-pred le)) (vb) ↑ • bbox ((≤-pred le)) b) (x ∷ ps)  ≡⟨ auto ⟩
    p ∷ act (bboxes (s≤s (≤-pred le)) (b ∷ vb)) (x ∷ ps)  ≡⟨ auto ⟩
    p ∷ act (bboxes (≤-pred (s≤s le)) (b ∷ vb)) (x ∷ ps) ∎
    where
    open ≡-Reasoning
    ih = lemma-bboxes2 p ps le vb

  prop-∃-L' : ∀ {n} (ps : Pauli n) (p : Pauli1) (p≢I : p ≢ pI) → ∃ \ l → act [ l ]ˡ (p ∷ ps) ≡ pZₙ
  prop-∃-L' {0} [] p neq = ((0 , [] , p , neq) , z≤n) , prop-abox p neq []
  prop-∃-L' {n@(suc n')} ps@(q ∷ qs) p neq =
    let le = NP.≤-reflexive auto in
    let (vb , prf) = prop-∃-bboxes (pZ ∷ q ∷ qs) auto in
    ((n , vb , p , neq), le) , (begin
      act (bboxes le vb) (act (abox le (p , neq)) (p ∷ ps)) ≡⟨ auto ⟩
      act (bboxes le vb) (act (abox le (p , neq)) (p ∷ q ∷ qs)) ≡⟨ Eq.cong (\ □ → act (bboxes le vb) (act (□) (p ∷ q ∷ qs))) (lemma-abox-a (p , neq)) ⟩ --(prop-abox-↓↓ p neq le (q ∷ qs))
      act (bboxes le vb) (act ([(p , neq)]ᵃ) (p ∷ q ∷ qs)) ≡⟨ Eq.cong (act (bboxes le vb)) (prop-abox p neq (q ∷ qs)) ⟩
      act (bboxes le vb) (pZ ∷ q ∷ qs) ≡⟨ Eq.cong (\ □ → act □ (pZ ∷ q ∷ qs)) (lemma-bboxes vb) ⟩
      act ([ vb ]ᵛᵇ) (pZ ∷ q ∷ qs) ≡⟨ prf ⟩
      pZₙ ∎)
    where
    open ≡-Reasoning

{-
  lemma-act-bbox : ∀ {j n} (j<n : j < n) p ps → act (bbox j<n pI) (p ∷ ps) ≡ p ∷ ps
  lemma-act-bbox {₀} {₁₊ n} (s≤s j≤n) p ps = {!!}
  lemma-act-bbox {₁₊ j} {₀} () p ps
  lemma-act-bbox {₁₊ j} {₁₊ n} (s≤s j<n) p ps = {!!}
  lemma-act-bbox {j} {n} (j<n) p ps = begin
    act (bbox j<n pI) (p ∷ ps) ≡⟨ {!!} ⟩
    p ∷ ps ∎
    where
    open ≡-Reasoning

  lemma-bboxes-< : ∀ {j n} (j<n : j < ₁₊ n) (vb : Vec B j) p ps →
    act (bboxes (NP.≤-pred j<n) vb) (p ∷ ps) ≡ {!!} -- p ∷ act (bboxes (j<n) vb) ps
  lemma-bboxes-< {j} {n} (s≤s j<n) vb p ps = begin
    act (bboxes (j<n) (vb)) (p ∷ ps) ≡⟨ Eq.refl ⟩
    {!!} ∎
    where
    open ≡-Reasoning
-}

  prop-∃-L : ∀ {n} (ps : Pauli (₁₊ n)) (≢I : ps ≢ pIₙ {₁₊ n}) → ∃ \ l → act [ l ]ˡ ps ≡ pZₙ
  prop-∃-L {₀} (x ∷ []) ≢I = ((₀ , [] , x , neq) , z≤n) , prop-abox x neq []
    where
    neq : x ≢ pI
    neq eq = ≢I (Eq.cong (_∷ []) eq)
  prop-∃-L {₁} ps@(x ∷ y ∷ []) ≢I = [ c1 , c2 ]′ (neqeq x)
    where
    open ≡-Reasoning
    c1 : x ≢ pI → ∃ \ l → act [ l ]ˡ ps ≡ pZₙ
    c1 neq = ((₁ , (y ∷ []), x , neq) , s≤s z≤n) , (begin
      act [ y ]ᵇ (act ([ x , neq ]ᵃ ↓) (x ∷ y ∷ [])) ≡⟨ Eq.cong (act [ y ]ᵇ) (prop-abox-↓ x neq (y ∷ [])) ⟩
      act [ y ]ᵇ (pZ ∷ y ∷ []) ≡⟨ prop-bbox y [] ⟩
      pI ∷ pZ ∷ [] ∎)

    c2 : x ≡ pI → ∃ \ l → act [ l ]ˡ ps ≡ pZₙ
    c2 eq rewrite eq = ((₀ , ([]), y , neq) , z≤n) , (begin
      act ([ y , neq ]ᵃ ↑) (pI ∷ y ∷ []) ≡⟨ lemma-act-↑ [ y , neq ]ᵃ pI (y ∷ []) ⟩
      pI ∷ act ([ y , neq ]ᵃ) (y ∷ []) ≡⟨ Eq.cong (pI ∷_) (prop-abox y neq []) ⟩
      pI ∷ pZ ∷ [] ∎)
      where
      neq : y ≢ pI
      neq eq2 rewrite eq | eq2 = ≢I auto

  prop-∃-L {₂₊ n} ps@(x ∷ y ∷ ps') ≢I = [ c1 , c2 ]′ (neqeq x)
    where
    open ≡-Reasoning
    c1 : x ≢ pI → ∃ \ l → act [ l ]ˡ ps ≡ pZₙ
    c1 neq = prop-∃-L' (y ∷ ps') x neq
    
    c2 : x ≡ pI → ∃ \ l → act [ l ]ˡ ps ≡ pZₙ
    c2 eq rewrite eq =
      let ((j , qs , a , neq) , le) , prf = ih in
      let le' = s≤s le in
      let le'' = NP.<⇒≤ le' in
        ((j , qs , a , neq) , le'') , (begin
           act (bboxes le'' qs) (act (abox le'' (a , neq)) ((₀ , ₀) ∷ y ∷ ps')) ≡⟨ Eq.cong (act (bboxes le'' qs)) (lemma-abox pI (y ∷ ps') le' a neq) ⟩
           act (bboxes le'' qs) ((₀ , ₀) ∷ act (abox (≤-pred le') (a , neq)) (y ∷ ps')) ≡⟨ lemma-bboxes2 pI (act (abox (≤-pred le') (a , neq)) (y ∷ ps')) (le') qs ⟩
           (₀ , ₀) ∷ act (bboxes (≤-pred le') qs) (act (abox (≤-pred le') (a , neq)) (y ∷ ps')) ≡⟨ auto ⟩
           (₀ , ₀) ∷ act (bboxes le qs) (act (abox le (a , neq)) (y ∷ ps')) ≡⟨ Eq.cong (pI ∷_) prf ⟩
           (₀ , ₀) ∷ (₀ , ₀) ∷ pZₙ ∎)
      where
      neq : y ∷ ps' ≢ pIₙ
      neq eq2 rewrite eq | eq2 = ≢I auto
      
      ih = prop-∃-L {₁₊ n} (y ∷ ps') neq







  -- open import Data.Product.Relation.Binary.Pointwise.NonDependent as PW
  -- open import Tactic.RingSolver

  lemma-norm-aux-s : ∀ a b c d → norm1 (a , b) (c , d) ≡ norm1 (a , a + b) (c , c + d)
  lemma-norm-aux-s a b c d = begin
    (- a) * d + c * b ≡⟨ lemma-norm-aux-s' a b c d  ⟩
    (- a) * (c + d) + c * (a + b) ∎
    where
    open ≡-Reasoning

  lemma-norm-aux : ∀ a b c d → norm1  (a , b) (c , d) ≡ norm1 (2F * b , a) (2F * d , c)
  lemma-norm-aux a b c d = lemma-norm-aux-h a b c d

  lemma-norm-aux-cz :  ∀ x y z w → norm1 (x .proj₁ , x .proj₂ + y .proj₁)
      (z .proj₁ , z .proj₂ + w .proj₁)
      +
      norm1 (y .proj₁ , x .proj₁ + y .proj₂)
       (w .proj₁ , z .proj₁ + w .proj₂)
      ≡ norm1 x z + norm1 y w
  lemma-norm-aux-cz x y z w = Eq.sym (lemma-norm-aux-cz' (x .proj₁) (x .proj₂) (z .proj₁) (z .proj₂) (y .proj₁) (y .proj₂) (w .proj₁) (w .proj₂))

  lemma-norm-fix-gen : ∀ {n} g ps qs → norm {n} (act1 g ps) (act1 g qs) ≡ norm ps qs
  lemma-norm-fix-gen {n} H-gen (x ∷ ps) (x₁ ∷ qs) = Eq.cong₂ _+_ (Eq.sym (lemma-norm-aux (proj₁ x) (proj₂ x) (proj₁ x₁) (proj₂ x₁))) Eq.refl
  lemma-norm-fix-gen {n} S-gen (x ∷ ps) (x₁ ∷ qs) = Eq.cong₂ _+_ (Eq.sym (lemma-norm-aux-s (proj₁ x) (proj₂ x) (proj₁ x₁) (proj₂ x₁))) Eq.refl
  lemma-norm-fix-gen {n} CZ-gen (x ∷ x₂ ∷ ps) (x₁ ∷ x₃ ∷ qs) = begin
    norm1 (x .proj₁ , x .proj₂ + x₂ .proj₁) (x₁ .proj₁ , x₁ .proj₂ + x₃ .proj₁) + (norm1 (x₂ .proj₁ , x .proj₁ + x₂ .proj₂) (x₃ .proj₁ , x₁ .proj₁ + x₃ .proj₂) + norm ps qs) ≡⟨ Eq.sym (+-assoc (norm1 (x .proj₁ , x .proj₂ + x₂ .proj₁) (x₁ .proj₁ , x₁ .proj₂ + x₃ .proj₁) )  (norm1 (x₂ .proj₁ , x .proj₁ + x₂ .proj₂) (x₃ .proj₁ , x₁ .proj₁ + x₃ .proj₂))  (norm ps qs)) ⟩
    (norm1 (x .proj₁ , x .proj₂ + x₂ .proj₁) (x₁ .proj₁ , x₁ .proj₂ + x₃ .proj₁) + norm1 (x₂ .proj₁ , x .proj₁ + x₂ .proj₂) (x₃ .proj₁ , x₁ .proj₁ + x₃ .proj₂)) + norm ps qs ≡⟨ Eq.cong₂ _+_ (lemma-norm-aux-cz x x₂ x₁ x₃) auto ⟩
    (norm1 x x₁ + norm1 x₂ x₃) + norm ps qs ≡⟨ +-assoc (norm1 x x₁) (norm1 x₂ x₃)  (norm ps qs) ⟩
    norm1 x x₁ + (norm1 x₂ x₃ + norm ps qs) ∎
    where open ≡-Reasoning
    
  lemma-norm-fix-gen {n} (g ₛ) (x ∷ ps) (x₁ ∷ qs) = Eq.cong₂ _+_ (Eq.refl {x = norm1 x x₁})  (lemma-norm-fix-gen g ps qs)

  lemma-norm-fix : ∀ {n} w ps qs → norm {n} (act w ps) (act w qs) ≡ norm ps qs
  lemma-norm-fix {n} [ x ↑] ps qs = lemma-norm-fix-gen x ps qs
  lemma-norm-fix {n} ε ps qs = auto
  lemma-norm-fix {n} (w • w₁) ps qs = begin
    norm (act w (act w₁ ps)) (act w (act w₁ qs)) ≡⟨ lemma-norm-fix w (act w₁ ps) (act w₁ qs) ⟩
    norm ((act w₁ ps)) ((act w₁ qs)) ≡⟨ lemma-norm-fix w₁ ps qs ⟩
    norm ps qs ∎
    where open ≡-Reasoning


  lemma-norm1-pI' : ∀ x → norm1 pI x ≡ 0F
  lemma-norm1-pI' x = begin
    norm1 pI x ≡⟨ lemma-norm1-pI (x .proj₁) (x .proj₂) ⟩
    0F ∎
    where
    open ≡-Reasoning

  lemma-norm1-pIʳ : ∀ x → norm1 x pI ≡ 0F
  lemma-norm1-pIʳ x = begin
    norm1 x pI ≡⟨ lemma-norm1-pIʳ' (x .proj₁) (x .proj₂) ⟩
    0F ∎
    where
    open ≡-Reasoning

  lemma-eq0 : ∀ {n} (ps : Pauli ( n)) → norm pIₙ ps ≡ 0F
  lemma-eq0 {₀} ([]) = auto
  lemma-eq0 {₁₊ n} (x ∷ ps) = Eq.cong₂ _+_ eq0 (lemma-eq0 ps)
    where
    open ≡-Reasoning
    eq0 : norm1 pI x ≡ 0F
    eq0 = begin
      norm1 pI x ≡⟨ lemma-norm1-pI (x .proj₁) (x .proj₂) ⟩
      0F ∎


  lemma-neqI : ∀ {n} (ps qs : Pauli (₁₊ n)) (eq1 : norm ps qs ≡ ₁) → ps ≢ pIₙ
  lemma-neqI ps qs eq1 eq rewrite eq = 1neq0 (Eq.trans (Eq.sym eq1) (lemma-eq0 qs))
    where
    1neq0 : ₁ ≢ 0F
    1neq0 ()

  lemma-na1 : ∀ p → norm1 pZ p ≡ ₁ → proj₁ p ≡ ₁
  lemma-na1 p eq = [ (\ h → ⊥-elim (c0 h)) , (\ h → [ (λ z → z) , (\ h → ⊥-elim (c2 h)) ]′ h )]′ (lemma-enum (proj₁ p))
    where
    c0 : proj₁ p ≡ 0F → ⊥
    c0 eq2 = 0F≠₁ (Eq.trans (Eq.sym aux1) eq)
      where
      0F≠₁ : 0F ≡ ₁ → ⊥
      0F≠₁ ()
      aux1 : norm1 pZ p ≡ 0F
      aux1 rewrite eq2 = auto
    c2 : proj₁ p ≡ 2F → ⊥
    c2 eq2 = 2F≠₁ (Eq.trans (Eq.sym aux1) eq)
      where
      2F≠₁ : 2F ≡ ₁ → ⊥
      2F≠₁ ()
      aux1 : norm1 pZ p ≡ 2F
      aux1 rewrite eq2 = auto

  lemma-₁-trivial : ∀ (p : Pauli1) → proj₁ p ≡ ₁ → ∃ \ e → p ≡ (₁ , e)
  lemma-₁-trivial (a , ₀) eq rewrite eq = ₀ , auto
  lemma-₁-trivial (a , ₁) eq rewrite eq = ₁ , auto
  lemma-₁-trivial (a , ₂) eq rewrite eq = ₂ , auto


  lemma-norm-pzn : ∀ {n} (qs : Pauli (₁₊ n)) (eq1 : norm pZₙ qs ≡ ₁) →
    ∃ \ e → last qs ≡ (₁ , e)
  lemma-norm-pzn (x ∷ []) eq1 = lemma-₁-trivial x aux
    where
    aux0 : norm1 pZ x ≡ ₁
    aux0 = Eq.trans (Eq.sym (+-identityʳ (norm1 pZ x))) eq1
    
    aux : proj₁ (last (x ∷ [])) ≡ ₁
    aux = lemma-na1 x aux0
  lemma-norm-pzn (x ∷ y ∷ qs) eq1 = (proj₁ ih) , (proj₂ ih)
    where
    open ≡-Reasoning
    ihh : norm pZₙ (y ∷ qs) ≡ ₁
    ihh = begin
      norm pZₙ (y ∷ qs) ≡⟨ Eq.sym (+-identityˡ (norm pZₙ (y ∷ qs))) ⟩
      0F + norm pZₙ (y ∷ qs) ≡⟨ Eq.cong (\ □ → □ + norm pZₙ (y ∷ qs)) (Eq.sym (lemma-norm1-pI' x)) ⟩
      norm1 pI x + norm pZₙ (y ∷ qs) ≡⟨ auto ⟩
      norm pZₙ (x ∷ y ∷ qs) ≡⟨ eq1 ⟩
      ₁ ∎

    ih = lemma-norm-pzn (y ∷ qs) ihh

  lemma-lbox : ∀ {n} (ps qs : Pauli (₁₊ n)) (eq1 : norm ps qs ≡ ₁) →
    let (l , pzn) = prop-∃-L ps (lemma-neqI ps qs eq1) in
    ∃ \ e → last (act [ l ]ˡ qs) ≡ (₁ , e)
  lemma-lbox {n} ps qs eq1 = (proj₁ la) , proj₂ la
    where
    open ≡-Reasoning
    lp = prop-∃-L ps (lemma-neqI ps qs eq1)
    pn = lemma-norm-fix [ proj₁ lp ]ˡ ps qs
    ps' = act [ proj₁ lp ]ˡ ps
    qs' = act [ proj₁ lp ]ˡ qs
    eq1' : norm pZₙ qs' ≡ ₁
    eq1' = begin
      norm pZₙ qs' ≡⟨ Eq.cong (\ □ → norm □ qs') (Eq.sym (proj₂ lp)) ⟩
      norm ps' qs' ≡⟨ pn ⟩
      norm ps qs ≡⟨ eq1 ⟩
      ₁ ∎

    la = lemma-norm-pzn qs' eq1'
    em = prop-∃-M qs' (proj₂ la)


  lemma-lbox' : ∀ {n} (ps qs : Pauli (₁₊ n)) (eq1 : norm ps qs ≡ ₁) →
    ∃ \ l → 
    ∃ \ e → last (act [ l ]ˡ qs) ≡ (₁ , e) × (act [ l ]ˡ ps) ≡ pZₙ
  lemma-lbox' {n} ps qs eq1 = proj₁ lp , (proj₁ la) , proj₂ la , proj₂ lp
    where
    open ≡-Reasoning
    lp = prop-∃-L ps (lemma-neqI ps qs eq1)
    pn = lemma-norm-fix [ proj₁ lp ]ˡ ps qs
    ps' = act [ proj₁ lp ]ˡ ps
    qs' = act [ proj₁ lp ]ˡ qs
    eq1' : norm pZₙ qs' ≡ ₁
    eq1' = begin
      norm pZₙ qs' ≡⟨ Eq.cong (\ □ → norm □ qs') (Eq.sym (proj₂ lp)) ⟩
      norm ps' qs' ≡⟨ pn ⟩
      norm ps qs ≡⟨ eq1 ⟩
      ₁ ∎

    la = lemma-norm-pzn qs' eq1'

  prop-∃-LM : ∀ {n} (ps qs : Pauli (₁₊ n)) (eq1 : norm ps qs ≡ ₁) →
    ∃ \ lm → act [ lm ] ps ≡ pZ₀ × act [ lm ] qs ≡ pX₀
  prop-∃-LM {n} ps qs eq1 = (l , m) , claim , claim2
    where
    open ≡-Reasoning
    
    lp = lemma-lbox' ps qs eq1
    l = proj₁ lp
    qs' = act [ l ]ˡ qs
    mp = prop-∃-M qs' (lp .proj₂ .proj₂ .proj₁)
    m = proj₁ mp
    claim : act [ (l , m) ] ps ≡ pZ₀
    claim = begin
      act [ (l , m) ] ps ≡⟨ auto ⟩
      act [ m ]ᵐ (act [ l ]ˡ ps) ≡⟨ Eq.cong (\ □ →  act [ m ]ᵐ □ ) ((lp .proj₂ .proj₂ .proj₂)) ⟩
      act [ m ]ᵐ pZₙ ≡⟨ auto ⟩
      act [ m .proj₁ ]ᵉ (act [ m .proj₂ ]ᵛᵈ pZₙ) ≡⟨ Eq.cong (\ □ → act [ m .proj₁ ]ᵉ □) (prop-dboxes (m .proj₂)) ⟩
      act [ m .proj₁ ]ᵉ (pZ₀) ≡⟨ prop-ebox-dual (m .proj₁) ⟩
      pZ₀ ∎

    claim2 : act [ (l , m) ] qs ≡ pX₀
    claim2 = begin
      act [ (l , m) ] qs ≡⟨ auto ⟩
      act [ m ]ᵐ (act [ l ]ˡ qs) ≡⟨ auto ⟩
      act [ m ]ᵐ qs' ≡⟨ proj₂ mp ⟩
      pX₀ ∎


-}


module Lemmas00 where

  variable
    n : ℕ

  -- open Lemmas hiding (n)
  -- open Lemmas2 hiding (n)
  -- open Lemmas3 hiding (n)

  open import Zp.ModularArithmetic
  open Rewriting

  -- lemma-semi-CZ-HH↓ : let open PB ((₂₊ n) QRel,_===_) in

  --   CZ • H ↓ ^ 2 ≈ H ↓ ^ 2 • CZ^ ₋₁
    
  -- lemma-semi-CZ-HH↓ = {!!}
    


module Symplectic-Powers0 where

  -- This module provides a rewrite system for reducing powers of
  -- Symplectic operators (for example, S⁴ → I). It also commutes
  -- generators on different qubits (for example, H1 H0 → H0 H1).
  -- Finally, it moves scalars to the end of the word. While this is
  -- not yet a very powerful rewrite system, it is a useful
  -- bootstrapping step.
  variable
    n : ℕ

  open Symplectic-Derived-Gen
  open Rewriting


  -- ----------------------------------------------------------------------
  -- * Lemmas

  -- The following lemmas are needed to justify the rewrite steps.

  -- ----------------------------------------------------------------------
  -- * Rewrite rules for monoidal structure and order of generators

  step-order : let open PB ((₁₊ n) QRel,_===_) hiding (_===_) in Step-Function (Gen (₁₊ n))  ((₁₊ n) QRel,_===_)

  -- Order of generators.
  -- step-order (((S-gen ₁)) ∷ ((S-gen ₁)) ∷ ((S-gen ₁)) ∷ xs) = just (xs , at-head (PB.axiom order-S))
  -- step-order (((S-gen ₁) ₛ) ∷ ((S-gen ₁) ₛ) ∷ ((S-gen ₁) ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ order-S)))
  -- step-order (((S-gen ₁) ₛ ₛ) ∷ ((S-gen ₁) ₛ ₛ) ∷ ((S-gen ₁) ₛ ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ (cong↑ order-S))))
  step-order (((H-gen ₁)) ∷ ((H-gen ₁)) ∷ ((H-gen ₁)) ∷ ((H-gen ₁)) ∷ xs) = just (xs , at-head (PB.axiom order-H))
  step-order (((H-gen ₁) ₛ) ∷ ((H-gen ₁) ₛ) ∷ ((H-gen ₁) ₛ) ∷ ((H-gen ₁) ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ order-H)))
  step-order (((H-gen ₁) ₛ ₛ) ∷ ((H-gen ₁) ₛ ₛ) ∷ ((H-gen ₁) ₛ ₛ) ∷ ((H-gen ₁) ₛ ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ (cong↑ order-H))))
  -- step-order ((CZ-gen) ∷ (CZ-gen) ∷ (CZ-gen) ∷ xs) = just (xs , at-head (PB.axiom order-CZ))
  -- step-order ((CZ-gen ₛ) ∷ (CZ-gen ₛ) ∷ (CZ-gen ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ order-CZ)))

  step-order (((S-gen ₁)) ∷ ((H-gen ₁)) ∷ ((S-gen ₁)) ∷ ((H-gen ₁)) ∷ ((S-gen ₁)) ∷ ((H-gen ₁)) ∷ xs) = just (xs , at-head (PB.axiom order-SH))
  step-order (((S-gen ₁) ₛ) ∷ ((H-gen ₁) ₛ) ∷ ((S-gen ₁) ₛ) ∷ ((H-gen ₁) ₛ) ∷ ((S-gen ₁) ₛ) ∷ ((H-gen ₁) ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ order-SH)))
  step-order (((S-gen ₁) ₛ ₛ) ∷ ((H-gen ₁) ₛ ₛ) ∷ ((S-gen ₁) ₛ ₛ) ∷ ((H-gen ₁) ₛ ₛ) ∷ ((S-gen ₁) ₛ ₛ) ∷ ((H-gen ₁) ₛ ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ (cong↑ order-SH))))

--  step-order (CZ-gen ∷ (H-gen ₁) ∷ (H-gen ₁) ₛ ∷ CZ-gen ∷ (H-gen ₁) ∷ (H-gen ₁) ₛ ∷ CZ-gen ∷ (H-gen ₁) ∷ (H-gen ₁) ₛ ∷ CZ-gen ∷ (H-gen ₁) ∷ (H-gen ₁) ₛ ∷ CZ-gen ∷ (H-gen ₁) ∷ (H-gen ₁) ₛ ∷ CZ-gen ∷ (H-gen ₁) ∷ (H-gen ₁) ₛ ∷ xs) = just (xs , at-head (PB.axiom lemma-order-Ex))
--  step-order (CZ-gen ₛ ∷ (H-gen ₁) ₛ ∷ (H-gen ₁) ₛ ₛ ∷ CZ-gen ₛ ∷ (H-gen ₁) ₛ ∷ (H-gen ₁) ₛ ₛ ∷ CZ-gen ₛ ∷ (H-gen ₁) ₛ ∷ (H-gen ₁) ₛ ₛ ∷ CZ-gen ₛ ∷ (H-gen ₁) ₛ ∷ (H-gen ₁) ₛ ₛ ∷ CZ-gen ₛ ∷ (H-gen ₁) ₛ ∷ (H-gen ₁) ₛ ₛ ∷ CZ-gen ₛ ∷ (H-gen ₁) ₛ ∷ (H-gen ₁) ₛ ₛ ∷ xs) = just (xs , at-head (PB.axiom (cong↑ order-Ex)))
  

  -- Commuting of generators.

  -- Catch-all
  step-order _ = nothing

  -- From this rewrite relation, we extract a tactic 'general-powers'.
module Powers0-Symplectic (n : ℕ) where

  open Rewriting
  open Symplectic-Powers0 hiding (n)
  open Rewriting.Step (step-cong (step-order {n})) renaming (general-rewrite to general-powers0) public

module Lemmas0 (n : ℕ) where

  open Symplectic-Derived-Gen
  open Symplectic-Derived-GroupLike
  open import Zp.ModularArithmetic

  open PB ((₁₊ n) QRel,_===_) hiding (_===_)
  open PP ((₁₊ n) QRel,_===_)
  open Pattern-Assoc
  open import Data.Nat.DivMod
  open import Data.Fin.Properties


  lemma-S^k+l : ∀ k l -> S^ k • S^ l ≈ S^ (k + l)
  lemma-S^k+l k l = begin
    S^ k • S^ l ≈⟨ cong (axiom (derived-S k)) (axiom (derived-S l)) ⟩
    S ^ toℕ k • S ^ toℕ l ≈⟨ sym (lemma-^-+ S (toℕ k) (toℕ l)) ⟩
    S ^ (toℕ k Nat.+ toℕ l) ≡⟨ Eq.cong (S ^_) (m≡m%n+[m/n]*n k+l p) ⟩
    S ^ (k+l Nat.% p Nat.+ (k+l Nat./ p) Nat.* p) ≈⟨ lemma-^-+ S (k+l Nat.% p) (((k+l Nat./ p) Nat.* p)) ⟩
    S ^ (k+l Nat.% p) • S ^ ((k+l Nat./ p) Nat.* p) ≈⟨ cong (refl' (Eq.cong (S ^_) (Eq.sym (toℕ-fromℕ< (m%n<n k+l p))))) (refl' (Eq.cong (S ^_) (NP.*-comm ((k+l Nat./ p)) p))) ⟩
    S ^ toℕ (fromℕ< (m%n<n k+l p)) • S ^ (p Nat.* (k+l Nat./ p) ) ≈⟨ cong (sym (axiom (derived-S (k + l)))) (sym (lemma-^^ S p (k+l Nat./ p))) ⟩
    S^ (k + l) • (S ^ p) ^ (k+l Nat./ p) ≈⟨ cright (lemma-^-cong (S ^ p) ε (k+l Nat./ p) (axiom order-S)) ⟩
    S^ (k + l) • ε ^ (k+l Nat./ p) ≈⟨ cright lemma-ε^k=ε (k+l Nat./ p) ⟩
    S^ (k + l) • ε ≈⟨ right-unit ⟩
    S^ (k + l) ∎
    where
    k+l = toℕ k Nat.+ toℕ l
    open SR word-setoid



  lemma-S^k-k : ∀ k -> S^ k • S^ (- k) ≈ ε
  lemma-S^k-k k = begin
    S^ k • S^ (- k) ≈⟨ lemma-S^k+l k (- k) ⟩
    S^ (k + - k) ≡⟨ Eq.cong S^ (+-inverseʳ k) ⟩
    S^ ₀ ≈⟨ axiom (derived-S ₀) ⟩
    ε ∎
    where
    open SR word-setoid
    k-k = toℕ k Nat.+ toℕ (- k)

  lemma-S^-k+k : ∀ k -> S^ (- k) • S^ k ≈ ε
  lemma-S^-k+k k = begin
    S^ (- k) • S^ k ≈⟨ cong (axiom (derived-S (- k))) (axiom (derived-S k)) ⟩
    S ^ toℕ (- k) • S ^ toℕ k ≈⟨ word-comm (toℕ (- k)) (toℕ ( k)) refl ⟩
    S ^ toℕ k • S ^ toℕ (- k) ≈⟨ cong (sym (axiom (derived-S k))) (sym (axiom (derived-S (- k)))) ⟩
    S^ k • S^ (- k) ≈⟨ lemma-S^k-k k ⟩
    ε ∎
    where
    open SR word-setoid

  open Eq using (_≢_)

  ₁⁻¹ = ((₁ , λ ()) ⁻¹) .proj₁

  
  lemma-M1 : ε ≈ M (₁ , λ ())
  lemma-M1 = begin
    ε ≈⟨ _≈_.sym (axiom order-SH) ⟩
    (S • H) ^ 3 ≈⟨ by-assoc auto ⟩
    S • H • S • H • S • H ≡⟨ auto ⟩
    S^ ₁ • H • S^ ₁ • H • S^ ₁ • H ≡⟨ Eq.cong (\ xx -> S^ ₁ • H • S^ xx • H • S^ ₁ • H) (Eq.sym inv-₁) ⟩
    S^ ₁ • H • S^ ₁⁻¹ • H • S^ ₁ • H ≈⟨ refl ⟩
    M (₁ , λ ()) ∎
    where
    open SR word-setoid


  lemma-[H⁻¹S⁻¹]^3 : (H⁻¹ • S⁻¹) ^ 3 ≈ ε
  lemma-[H⁻¹S⁻¹]^3 = begin
    (H⁻¹ • S⁻¹) ^ 3 ≈⟨ _≈_.sym assoc ⟩
    (H⁻¹ • S⁻¹) ^' 3 ≈⟨ lemma-cong-inv (axiom order-SH) ⟩
    winv ε ≈⟨ refl ⟩
    ε ∎
    where
    open Group-Lemmas _ _ grouplike renaming (_⁻¹ to winv)
    open SR word-setoid

  lemma-[S⁻¹H⁻¹]^3 : (S⁻¹ • H⁻¹) ^ 3 ≈ ε
  lemma-[S⁻¹H⁻¹]^3 = begin
    (S⁻¹ • H⁻¹) ^ 3 ≈⟨ sym (trans (cright lemma-left-inverse) right-unit) ⟩
    (S⁻¹ • H⁻¹) ^ 3 • (S⁻¹ • S) ≈⟨ special-assoc ((□ • □) ^ 3 • □ • □) (□ • (□ • □) ^ 3 • □) auto ⟩
    S⁻¹ • (H⁻¹ • S⁻¹) ^ 3 • S ≈⟨ cright cleft lemma-[H⁻¹S⁻¹]^3 ⟩
    S⁻¹ • ε • S ≈⟨ by-assoc auto ⟩
    S⁻¹ • S ≈⟨ lemma-left-inverse ⟩
    ε ∎
    where
    open Group-Lemmas _ _ grouplike renaming (_⁻¹ to winv)
    open SR word-setoid

  lemma-S⁻¹ : S⁻¹ ≈ S^ ₚ₋₁
  lemma-S⁻¹ = begin
    S⁻¹ ≈⟨ refl ⟩
    S ^ p-1 ≡⟨ Eq.cong (S ^_) (Eq.sym lemma-toℕ-ₚ₋₁) ⟩
    S ^ toℕ ₚ₋₁ ≈⟨ sym (axiom (derived-S ₚ₋₁)) ⟩
    S^ ₚ₋₁ ∎
    where
    open SR word-setoid

  lemma-HH-M-1 : let -'₁ = -' ((₁ , λ ())) in HH ≈ M -'₁
  lemma-HH-M-1 = begin
    HH ≈⟨ trans (sym right-unit) (cright sym lemma-[S⁻¹H⁻¹]^3) ⟩
    HH • (S⁻¹ • H⁻¹) ^ 3 ≈⟨ (cright lemma-^-cong (S⁻¹ • H⁻¹) (S⁻¹ • H • HH) 3 refl) ⟩
    HH • (S⁻¹ • H • HH) ^ 3 ≈⟨ refl ⟩
    HH • (S⁻¹ • H • HH) • (S⁻¹ • H • HH) • (S⁻¹ • H • HH) ≈⟨ (cright cong (cright sym assoc) (special-assoc (□ ^ 3 • □ ^ 3) (□ ^ 2 • □ ^ 2 • □ ^ 2) auto)) ⟩
    HH • (S⁻¹ • HH • H) • (S⁻¹ • H) • (HH • S⁻¹) • H • HH ≈⟨ (cright cong (sym assoc) (cright cleft word-comm 1 p-1 (trans assoc (axiom comm-HHS)))) ⟩
    HH • ((S⁻¹ • HH) • H) • (S⁻¹ • H) • (S⁻¹ • HH) • H • HH ≈⟨ (cright cong (cleft word-comm p-1 1 (sym (trans assoc (axiom comm-HHS)))) (cright assoc)) ⟩
    HH • ((HH • S⁻¹) • H) • (S⁻¹ • H) • S⁻¹ • HH • H • HH ≈⟨ (cright cright cright cright general-powers0 100 auto) ⟩
    HH • ((HH • S⁻¹) • H) • (S⁻¹ • H) • S⁻¹ • H ≈⟨ special-assoc (□ • (□ ^ 2 • □) • □) (□ ^ 2 • □ ^ 2 • □) auto ⟩
    (HH • HH) • (S⁻¹ • H) • (S⁻¹ • H) • S⁻¹ • H ≈⟨ (cleft general-powers0 100 auto) ⟩
    ε • (S⁻¹ • H) • (S⁻¹ • H) • S⁻¹ • H ≈⟨ left-unit ⟩
    (S⁻¹ • H) • (S⁻¹ • H) • S⁻¹ • H ≈⟨ special-assoc ((□ ^ 2) ^ 3) (□ ^ 6) auto ⟩
    S⁻¹ • H • S⁻¹ • H • S⁻¹ • H ≈⟨ cong lemma-S⁻¹ (cright cong lemma-S⁻¹ (cright (cleft lemma-S⁻¹))) ⟩
    S^ ₚ₋₁ • H • S^ ₚ₋₁ • H • S^ ₚ₋₁ • H ≡⟨ Eq.cong (\ xx -> S^ ₚ₋₁ • H • S^ ₚ₋₁ • H • S^ xx • H) p-1=-1ₚ ⟩
    S^ ₚ₋₁ • H • S^ ₚ₋₁ • H • S^ -₁ • H ≡⟨ Eq.cong₂ (\ xx yy -> S^ xx • H • S^ yy • H • S^ -₁ • H) (p-1=-1ₚ) p-1=-1ₚ ⟩
    S^ -₁ • H • S^ -₁ • H • S^ -₁ • H ≡⟨ Eq.cong (\ xx -> S^ -₁ • H • S^ xx • H • S^ -₁ • H) (Eq.sym aux-₁⁻¹) ⟩
    S^ -₁ • H • S^ -₁⁻¹ • H • S^ -₁ • H ≈⟨ refl ⟩
    S^ x • H • S^ x⁻¹ • H • S^ x • H ≡⟨ Eq.refl ⟩
    M x' ∎
    where
    open Powers0-Symplectic n

    x' = -'₁
    -₁ = -'₁ .proj₁
    -₁⁻¹ = (-'₁ ⁻¹) .proj₁
    x = x' .proj₁
    x⁻¹ = (x' ⁻¹) .proj₁
    open SR word-setoid



  derived-D : ∀ x -> (nz : x ≢ ₀) -> let x⁻¹ = ((x , nz) ⁻¹) .proj₁ in let -x⁻¹ = - x⁻¹ in
    H • S^ x • H ≈ H • S^ x • H • S^ x⁻¹ • H • H ^ 3 • S^ -x⁻¹
  derived-D  x nz = begin
    H • S^ x • H ≈⟨ (cright cright sym right-unit) ⟩
    H • S^ x • H • ε ≈⟨ cright cright cright sym (lemma-S^k-k x⁻¹) ⟩
    H • S^ x • H • S^ x⁻¹ • S^ -x⁻¹ ≈⟨ cright cright cright cright sym left-unit ⟩
    H • S^ x • H • S^ x⁻¹ • ε • S^ -x⁻¹ ≈⟨ cright cright cright cright sym (cong (axiom order-H) refl) ⟩
    H • S^ x • H • S^ x⁻¹ • H ^ 4 • S^ -x⁻¹ ≈⟨ (cright cright cright cright special-assoc (□ ^ 4 • □) (□ • □ ^ 3 • □) auto) ⟩
    H • S^ x • H • S^ x⁻¹ • H • H ^ 3 • S^ -x⁻¹ ∎
    where
    x⁻¹ = ((x , nz) ⁻¹) .proj₁
    -x⁻¹ = - x⁻¹ 
    open SR word-setoid

  derived-5 : ∀ x k -> (nz : x ≢ ₀) -> let x⁻¹ = ((x , nz) ⁻¹) .proj₁ in let -x⁻¹ = - x⁻¹ in
    M (x , nz) • S ^ k ≈ S ^ (k Nat.* toℕ (x * x)) • M (x , nz)
  derived-5 x k@0 nz = trans right-unit (sym left-unit)
  derived-5 x k@1 nz = begin  
    M (x , nz) • S ^ k ≈⟨ refl ⟩
    M (x , nz) • S ≈⟨ axiom (semi-MS (x , nz)) ⟩
    S^ (x * x) • M (x , nz) ≈⟨ cong (axiom (derived-S (x * x))) refl ⟩
    S ^ toℕ (x * x) • M (x , nz) ≈⟨ (cleft refl' (Eq.cong (S ^_) (Eq.sym ( NP.*-identityˡ (toℕ (x * x)))))) ⟩
    S ^ (k Nat.* toℕ (x * x)) • M (x , nz) ∎
    where
    open SR word-setoid
  derived-5 x k@(₂₊ k') nz = begin  
    M (x , nz) • S ^ k ≈⟨ refl ⟩
    M (x , nz) • S • S ^ ₁₊ k' ≈⟨ sym assoc ⟩
    (M (x , nz) • S) • S ^ ₁₊ k' ≈⟨ (cleft derived-5 x 1 nz) ⟩
    (S ^ (1 Nat.* toℕ (x * x)) • M (x , nz)) • S ^ ₁₊ k' ≈⟨ assoc ⟩
    S ^ (1 Nat.* toℕ (x * x)) • M (x , nz) • S ^ ₁₊ k' ≈⟨ (cright derived-5 x (₁₊ k') nz) ⟩
    S ^ (1 Nat.* toℕ (x * x)) • S ^ (₁₊ k' Nat.* toℕ (x * x)) • M (x , nz) ≈⟨ sym assoc ⟩
    (S ^ (1 Nat.* toℕ (x * x)) • S ^ (₁₊ k' Nat.* toℕ (x * x))) • M (x , nz) ≈⟨ (cleft sym (lemma-^-+ S ((1 Nat.* toℕ (x * x))) ((₁₊ k' Nat.* toℕ (x * x))))) ⟩
    (S ^ ((1 Nat.* toℕ (x * x)) Nat.+ (₁₊ k' Nat.* toℕ (x * x)))) • M (x , nz) ≈⟨ (cleft refl' (Eq.cong (S ^_) (Eq.sym (NP.*-distribʳ-+ (toℕ (x * x)) ₁ (₁₊ k'))))) ⟩
    S ^ ((1 Nat.+ ₁₊ k') Nat.* toℕ (x * x) ) • M (x , nz) ≈⟨ refl ⟩
    S ^ (k Nat.* toℕ (x * x)) • M (x , nz) ∎
    where
    open SR word-setoid

  lemma-S^k-% : ∀ k -> S ^ k ≈ S ^ (k % p)
  lemma-S^k-% k = begin
    S ^ k ≡⟨ Eq.cong (S ^_) (m≡m%n+[m/n]*n k p) ⟩
    S ^ (k Nat.% p Nat.+ k Nat./ p Nat.* p) ≈⟨ lemma-^-+ S (k Nat.% p) (k Nat./ p Nat.* p) ⟩
    S ^ (k Nat.% p) • S ^ (k Nat./ p Nat.* p) ≈⟨ (cright refl' (Eq.cong (S ^_) (NP.*-comm (k Nat./ p) p))) ⟩
    S ^ (k Nat.% p) • S ^ (p Nat.* (k Nat./ p)) ≈⟨ sym (cright lemma-^^ S p (k Nat./ p)) ⟩
    S ^ (k Nat.% p) • (S ^ p) ^ (k Nat./ p) ≈⟨ (cright lemma-^-cong (S ^ p) ε (k Nat./ p) (axiom order-S)) ⟩
    S ^ (k Nat.% p) • (ε) ^ (k Nat./ p) ≈⟨ (cright lemma-ε^k=ε (k Nat./ p)) ⟩
    S ^ (k Nat.% p) • ε ≈⟨ right-unit ⟩
    S ^ (k % p) ∎
    where
    open SR word-setoid

  lemma-MS^k : ∀ x k -> (nz : x ≢ ₀) -> let x⁻¹ = ((x , nz) ⁻¹) .proj₁ in let -x⁻¹ = - x⁻¹ in
    M (x , nz) • S^ k ≈ S^ (k * (x * x)) • M (x , nz)
  lemma-MS^k x k nz = begin 
    M (x , nz) • S^ k ≈⟨ cong refl (axiom (derived-S k)) ⟩
    M (x , nz) • S ^ toℕ k ≈⟨ derived-5 x (toℕ k) nz ⟩
    S ^ (toℕ k Nat.* toℕ (x * x)) • M (x , nz) ≈⟨ (cleft lemma-S^k-% (toℕ k Nat.* toℕ (x * x))) ⟩
    S ^ ((toℕ k Nat.* toℕ (x * x)) % p) • M (x , nz) ≈⟨ (cleft refl' (Eq.cong (S ^_) (lemma-toℕ-% k (x * x)))) ⟩
    S ^ toℕ (k * (x * x)) • M (x , nz) ≈⟨ cong (sym (axiom (derived-S (k * (x * x))))) refl ⟩
    S^ (k * (x * x)) • M (x , nz) ∎
    where
    open SR word-setoid
    x⁻¹ = ((x , nz) ⁻¹) .proj₁
    -x⁻¹ = - x⁻¹

  lemma-S^ab : ∀ (a b : ℤ ₚ) -> S ^ toℕ (a * b) ≈ S ^ (toℕ a Nat.* toℕ b)
  lemma-S^ab a b = begin
    S ^ toℕ (a * b) ≡⟨ auto ⟩
    S ^ toℕ (fromℕ< (m%n<n (toℕ a Nat.* toℕ b) p)) ≡⟨ Eq.cong (S ^_) (toℕ-fromℕ< (m%n<n (toℕ a Nat.* toℕ b) p)) ⟩
    S ^ ((toℕ a Nat.* toℕ b) % p) ≈⟨ sym right-unit ⟩
    S ^ (ab Nat.% p) • ε ≈⟨ (cright sym (lemma-ε^k=ε (ab Nat./ p))) ⟩
    S ^ (ab Nat.% p) • (ε) ^ (ab Nat./ p) ≈⟨ (cright sym (lemma-^-cong (S ^ p) ε (ab Nat./ p) (axiom order-S))) ⟩
    S ^ (ab Nat.% p) • (S ^ p) ^ (ab Nat./ p) ≈⟨ (cright lemma-^^ S p (ab Nat./ p)) ⟩
    S ^ (ab Nat.% p) • S ^ (p Nat.* (ab Nat./ p)) ≈⟨ (cright refl' (Eq.cong (S ^_) (NP.*-comm p (ab Nat./ p)))) ⟩
    S ^ (ab Nat.% p) • S ^ (ab Nat./ p Nat.* p) ≈⟨ sym (lemma-^-+ S (ab Nat.% p) (ab Nat./ p Nat.* p)) ⟩
    S ^ (ab Nat.% p Nat.+ ab Nat./ p Nat.* p) ≡⟨ Eq.cong (S ^_) (Eq.sym (m≡m%n+[m/n]*n ab p)) ⟩
    S ^ (toℕ a Nat.* toℕ b) ∎
    where
    ab = toℕ a Nat.* toℕ b
    open SR word-setoid


  derived-7 : ∀ x y -> (nz : x ≢ ₀) -> (nzy : y ≢ ₀) -> let -'₁ = -' ((₁ , λ ())) in let x⁻¹ = ((x , nz) ⁻¹) .proj₁ in let -x⁻¹ = - x⁻¹ in let -y/x' = (((y , nzy) *' ((x , nz) ⁻¹)) *' -'₁) in let -y/x = -y/x' .proj₁ in
  
    M (y , nzy) • H • S^ x • H ≈ S^ (-x⁻¹ * (y * y)) • M -y/x' • (H • S^ -x⁻¹)
    
  derived-7 x y nzx nzy = begin
    M (y , nzy) • H • S^ x • H ≈⟨ (cright derived-D x nzx) ⟩
    M (y , nzy) • H • S^ x • H • S^ x⁻¹ • H • H ^ 3 • S^ -x⁻¹ ≈⟨ (cright special-assoc (□ • □ • □ • □ • □ • □ • □) (□ ^ 5 • □ • □) auto) ⟩
    M (y , nzy) • (H • S^ x • H • S^ x⁻¹ • H) • H ^ 3 • S^ -x⁻¹ ≈⟨ (cright cleft sym left-unit) ⟩
    M (y , nzy) • (ε • H • S^ x • H • S^ x⁻¹ • H) • H ^ 3 • S^ -x⁻¹ ≈⟨ (cright cleft cleft sym (lemma-S^-k+k x⁻¹)) ⟩
    M (y , nzy) • ((S^ -x⁻¹ • S^ x⁻¹) • H • S^ x • H • S^ x⁻¹ • H) • H ^ 3 • S^ -x⁻¹ ≈⟨ special-assoc (□ • (□ ^ 2 • □ ^ 5) • □) (□ ^ 2 • □ ^ 6 • □) auto ⟩
    (M (y , nzy) • S^ -x⁻¹) • (S^ x⁻¹ • H • S^ x • H • S^ x⁻¹ • H) • H ^ 3 • S^ -x⁻¹ ≈⟨ (cleft (cright axiom (derived-S -x⁻¹))) ⟩
    (M (y , nzy) • S ^ toℕ -x⁻¹) • (S^ x⁻¹ • H • S^ x • H • S^ x⁻¹ • H) • H ^ 3 • S^ -x⁻¹ ≈⟨ (cleft derived-5 y (toℕ -x⁻¹) nzy) ⟩
    (S ^ (toℕ -x⁻¹ Nat.* toℕ (y * y)) • M (y , nzy)) • (S^ x⁻¹ • H • S^ x • H • S^ x⁻¹ • H) • H ^ 3 • S^ -x⁻¹ ≈⟨ special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ⟩
    S ^ (toℕ -x⁻¹ Nat.* toℕ (y * y)) • (M (y , nzy) • (S^ x⁻¹ • H • S^ x • H • S^ x⁻¹ • H)) • H ^ 3 • S^ -x⁻¹ ≈⟨ (cright cleft (cright (cright cright cleft refl' (Eq.cong S^ (Eq.sym (inv-involutive ((x , nz)))))))) ⟩
    S ^ (toℕ -x⁻¹ Nat.* toℕ (y * y)) • (M (y , nzy) • M ((x , nz) ⁻¹)) • H ^ 3 • S^ -x⁻¹ ≈⟨ (cright cleft axiom (M-mul (y , nzy) ((x , nz) ⁻¹))) ⟩
    S ^ (toℕ -x⁻¹ Nat.* toℕ (y * y)) • M ((y , nzy) *' ((x , nz) ⁻¹)) • H ^ 3 • S^ -x⁻¹ ≈⟨ (cright special-assoc (□ • □ ^ 3 • □) (□ ^ 3 • □ ^ 2) auto) ⟩
    S ^ (toℕ -x⁻¹ Nat.* toℕ (y * y)) • (M ((y , nzy) *' ((x , nz) ⁻¹)) • HH) • H • S^ -x⁻¹ ≈⟨ (cright cleft (cright lemma-HH-M-1)) ⟩
    S ^ (toℕ -x⁻¹ Nat.* toℕ (y * y)) • (M ((y , nzy) *' ((x , nz) ⁻¹)) • M -'₁) • H • S^ -x⁻¹ ≈⟨ (cright cleft axiom (M-mul (((y , nzy) *' ((x , nz) ⁻¹))) -'₁)) ⟩
    S ^ (toℕ -x⁻¹ Nat.* toℕ (y * y)) • (M (((y , nzy) *' ((x , nz) ⁻¹)) *' -'₁) ) • H • S^ -x⁻¹ ≈⟨ (cleft sym (lemma-S^ab -x⁻¹ (y * y))) ⟩
    S ^ toℕ (-x⁻¹ * (y * y)) • M -y/x' • (H • S^ -x⁻¹) ≈⟨ cong (sym (axiom (derived-S (-x⁻¹ * (y * y))))) refl ⟩
    S^ (-x⁻¹ * (y * y)) • M -y/x' • (H • S^ -x⁻¹) ∎
    where
    open SR word-setoid
    nz = nzx
    x⁻¹ = ((x , nz) ⁻¹) .proj₁
    x⁻¹⁻¹ = (((x , nz) ⁻¹) ⁻¹) .proj₁
    -x⁻¹ = - x⁻¹
    -y/x' = (((y , nzy) *' ((x , nz) ⁻¹)) *' -'₁)
    -y/x = -y/x' .proj₁

  aux-MM : ∀ {x y : ℤ ₚ} (nzx : x ≢ ₀) (nzy : y ≢ ₀) -> x ≡ y -> M (x , nzx) ≈ M (y , nzy)
  aux-MM {x} {y} nz1 nz2 eq rewrite eq = refl


  semi-HM : ∀ (x : ℤ* ₚ) -> H • M x ≈ M (x ⁻¹) • H
  semi-HM x' = begin
    H • (S^ x • H • S^ x⁻¹ • H • S^ x • H) ≈⟨ by-assoc auto ⟩
    (H • S^ x • H) • S^ x⁻¹ • H • S^ x • H ≈⟨ (trans (sym left-unit) (cong lemma-M1 refl)) ⟩
    M₁ • (H • S^ x • H) • S^ x⁻¹ • H • S^ x • H ≈⟨ sym assoc ⟩
    (M₁ • (H • S^ x • H)) • S^ x⁻¹ • H • S^ x • H ≈⟨ (cleft derived-7 x ₁ (x' .proj₂) λ ()) ⟩
    (S^ (-x⁻¹ * (₁ * ₁)) • M (((₁ , λ ()) *' x' ⁻¹) *' -'₁) • H • S^ -x⁻¹) • S^ x⁻¹ • H • S^ x • H ≈⟨ cleft (cright (cleft aux-MM ((((₁ , λ ()) *' x' ⁻¹) *' -'₁) .proj₂) ((-' (x' ⁻¹)) .proj₂) aux-a1)) ⟩
    (S^ (-x⁻¹ * ₁) • M (-' (x' ⁻¹)) • H • S^ -x⁻¹) • S^ x⁻¹ • H • S^ x • H ≈⟨ special-assoc (□ ^ 4 • □ ^ 4) (□ • □ ^ 4 • □ ^ 3) auto ⟩
    S^ (-x⁻¹ * ₁) • (M (-' (x' ⁻¹)) • H • S^ -x⁻¹ • S^ x⁻¹) • H • S^ x • H ≈⟨ cong (refl' (Eq.cong S^ (*-identityʳ -x⁻¹))) (cleft cright (cright lemma-S^-k+k x⁻¹)) ⟩
    S^ -x⁻¹ • (M (-' (x' ⁻¹)) • H • ε) • H • S^ x • H ≈⟨ (cright cleft (cright right-unit)) ⟩
    S^ -x⁻¹ • (M (-' (x' ⁻¹)) • H) • H • S^ x • H ≈⟨ (cright by-assoc auto) ⟩
    S^ -x⁻¹ • (M (-' (x' ⁻¹)) • H • H) • S^ x • H ≈⟨ (cright cleft cright lemma-HH-M-1) ⟩
    S^ -x⁻¹ • (M (-' (x' ⁻¹)) • M -'₁) • S^ x • H ≈⟨ (cright cleft axiom (M-mul (-' (x' ⁻¹)) -'₁)) ⟩
    S^ -x⁻¹ • M (-' (x' ⁻¹) *' -'₁) • S^ x • H ≈⟨ (cright cleft aux-MM ((-' (x' ⁻¹) *' -'₁) .proj₂) ((x' ⁻¹) .proj₂) aux-a2) ⟩
    S^ -x⁻¹ • M (x' ⁻¹) • S^ x • H ≈⟨ sym (cong refl assoc) ⟩
    S^ -x⁻¹ • (M (x' ⁻¹) • S^ x) • H ≈⟨ (cright cleft lemma-MS^k x⁻¹ x ((x' ⁻¹) .proj₂)) ⟩
    S^ -x⁻¹ • (S^ (x * (x⁻¹ * x⁻¹)) • M (x' ⁻¹)) • H ≈⟨ (cright cleft (cleft refl' (Eq.cong S^ aux-a3))) ⟩
    S^ -x⁻¹ • (S^ x⁻¹ • M (x' ⁻¹)) • H ≈⟨ by-assoc auto ⟩
    (S^ -x⁻¹ • S^ x⁻¹) • M (x' ⁻¹) • H ≈⟨ (cleft lemma-S^-k+k x⁻¹) ⟩
    ε • M (x' ⁻¹) • H ≈⟨ left-unit ⟩
    M (x' ⁻¹) • H ∎
    where
    x = x' .proj₁
    x⁻¹ = ((x' ⁻¹) .proj₁ )

    -x = - x
    -x⁻¹ = - x⁻¹
    aux-a1 : ₁ * x⁻¹ * (-'₁ .proj₁) ≡ -x⁻¹
    aux-a1 = begin
      ₁ * x⁻¹ * (-'₁ .proj₁) ≡⟨ Eq.cong (\ xx -> xx * (-'₁ .proj₁)) (*-identityˡ x⁻¹) ⟩
      x⁻¹ * (-'₁ .proj₁) ≡⟨ Eq.cong (x⁻¹ *_) (Eq.sym p-1=-1ₚ) ⟩
      x⁻¹ * ₋₁ ≡⟨ *-comm x⁻¹ ₋₁ ⟩
      ₋₁ * x⁻¹ ≡⟨ auto ⟩
      -x⁻¹ ∎
      where open ≡-Reasoning

    aux-a2 : -x⁻¹ * - ₁ ≡ x⁻¹
    aux-a2 = begin
      -x⁻¹ * - ₁ ≡⟨ *-comm -x⁻¹ (- ₁) ⟩
      - ₁ * -x⁻¹ ≡⟨ -1*x≈-x -x⁻¹ ⟩
      - -x⁻¹ ≡⟨ -‿involutive x⁻¹ ⟩
      x⁻¹ ∎
      where
      open ≡-Reasoning
      open import Algebra.Properties.Ring (+-*-ring p-2)


    aux-a3 : x * (x⁻¹ * x⁻¹) ≡ x⁻¹
    aux-a3 = begin
      x * (x⁻¹ * x⁻¹) ≡⟨ Eq.sym (*-assoc x x⁻¹ x⁻¹) ⟩
      x * x⁻¹ * x⁻¹ ≡⟨ Eq.cong (_* x⁻¹) (lemma-⁻¹ʳ x {{nztoℕ {y = x} {neq0 = x' .proj₂}}}) ⟩
      ₁ * x⁻¹ ≡⟨ *-identityˡ x⁻¹ ⟩
      x⁻¹ ∎
      where open ≡-Reasoning

    open SR word-setoid





module Lemmas0a where

  private
    variable
      n : ℕ
      
  open Symplectic-Derived-Gen
  open Symplectic-Derived-GroupLike

  open import Data.Nat.DivMod
  open import Data.Fin.Properties


  lemma-S↓HCZH : let open PB ((₂₊ n) QRel,_===_) in
    S • H • CZ • H ≈ H • CZ • H • CZ • S ↑ • S
  lemma-S↓HCZH {n} = sym (begin
    H • CZ • H • CZ • S ↑ • S ≈⟨ by-assoc auto ⟩
    H • (CZ • H • CZ) • S ↑ • S ≈⟨ (cright (cleft axiom selinger-c11)) ⟩
    H • (S⁻¹ ↓ • H ↓ • S⁻¹ ↓ • CZ • H ↓ • S⁻¹ ↓ • S⁻¹ ↑) • S ↑ • S ≈⟨ special-assoc (□ • □ ^ 7 • □ ^ 2) (□ • □ ^ 6 • □ ^ 2 • □) auto ⟩
    H • (S⁻¹ ↓ • H ↓ • S⁻¹ ↓ • CZ • H ↓ • S⁻¹ ↓) • (S⁻¹ ↑ • S ↑) • S ≈⟨ refl ⟩
    H • (S⁻¹ ↓ • H ↓ • S⁻¹ ↓ • CZ • H ↓ • S⁻¹ ↓) • (S⁻¹ • S) ↑ • S ≈⟨ (cright cright cleft (lemma-cong↑ _ _ (M1P.word-comm p-1 1 M1B.refl))) ⟩
    H • (S⁻¹ ↓ • H ↓ • S⁻¹ ↓ • CZ • H ↓ • S⁻¹ ↓) • (S • S⁻¹) ↑ • S ≈⟨ (cright cright cleft lemma-cong↑ _ _ M1B.refl) ⟩
    H • (S⁻¹ ↓ • H ↓ • S⁻¹ ↓ • CZ • H ↓ • S⁻¹ ↓) • (S ^ p) ↑ • S ≈⟨ (cright cright cleft lemma-cong↑ _ _ (M1B.axiom order-S)) ⟩
    H • (S⁻¹ ↓ • H ↓ • S⁻¹ ↓ • CZ • H ↓ • S⁻¹ ↓) • ε ↑ • S ≈⟨ by-assoc auto ⟩
    H • (S⁻¹ ↓ • H ↓ • S⁻¹ ↓ • CZ • H ↓ • S⁻¹ ↓) • S ≈⟨ special-assoc (□ • □ ^ 6 • □) (□ ^ 6 • □ ^ 2) auto ⟩
    (H • S⁻¹ ↓ • H ↓ • S⁻¹ ↓ • CZ • H ↓) • S⁻¹ ↓ • S ≈⟨ (cright cleft lemma-cong↓-S^ p-1) ⟩
    (H • S⁻¹ ↓ • H ↓ • S⁻¹ ↓ • CZ • H ↓) • S⁻¹ • S ≈⟨ (cright word-comm p-1 1 refl) ⟩
    (H • S⁻¹ ↓ • H ↓ • S⁻¹ ↓ • CZ • H ↓) • S • S⁻¹ ≈⟨ (cright axiom order-S) ⟩
    (H • S⁻¹ ↓ • H ↓ • S⁻¹ ↓ • CZ • H ↓) • ε ≈⟨ right-unit ⟩
    (H • S⁻¹ ↓ • H ↓ • S⁻¹ ↓ • CZ • H ↓) ≈⟨ {!!} ⟩
    (H • S⁻¹ ↓ • H ↓) • S⁻¹ ↓ • CZ • H ↓ ≈⟨ (cleft {!!}) ⟩
    (S • H • S) • S⁻¹ ↓ • CZ • H ↓ ≈⟨ general-powers0 100 {!!} ⟩
    S • H • CZ • H ∎)
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    module M1P = PP ((₁₊ n) QRel,_===_)
    module M1B = PB ((₁₊ n) QRel,_===_)
    open SR word-setoid
    open Pattern-Assoc
    open Powers0-Symplectic (suc n)


{-
  lemma-comm-Ex-S↑↑ : let open PB ((₃₊ n) QRel,_===_) in
    Ex • S ↑ ↑ ≈ S ↑ ↑ • Ex
  lemma-comm-Ex-S↑↑ {n} = {!!}
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)


  lemma-comm-Ex↑-S : let open PB ((₃₊ n) QRel,_===_) in
    Ex ↑ • S ≈ S • Ex ↑
  lemma-comm-Ex↑-S {n} = general-comm auto
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (suc n)

  lemma-comm-Ex-H↑↑ : let open PB ((₃₊ n) QRel,_===_) in
    Ex • H ↑ ↑ ≈ H ↑ ↑ • Ex
  lemma-comm-Ex-H↑↑ {n} = general-comm auto
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open Commuting-Symplectic (suc n)

  lemma-comm-Ex↑-H : let open PB ((₃₊ n) QRel,_===_) in
    Ex ↑ • H ≈ H • Ex ↑
  lemma-comm-Ex↑-H {n} = general-comm auto
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open Commuting-Symplectic (suc n)

-}


  lemma-S↑H↑CZ↑H : let open PB ((₂₊ n) QRel,_===_) in
    S ↑ • H ↑ • CZ • H ↑ ≈ H ↑ • CZ • H ↑ • CZ • S ↓ • S ↑
  lemma-S↑H↑CZ↑H {n} = sym (begin
    H ↑ • CZ • H ↑ • CZ • S ↓ • S ↑ ≈⟨ by-assoc auto ⟩
    H ↑ • (CZ • H ↑ • CZ) • S ↓ • S ↑ ≈⟨ (cright ( cleft axiom selinger-c10 )) ⟩
    H ↑ • (S⁻¹ ↑ • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑ • S⁻¹ ↓) • S ↓ • S ↑ ≈⟨ general-powers0 100 {!!} ⟩
    (H ↑ • S⁻¹ ↑ • H ↑) • S⁻¹ ↑ • CZ • H ↑ ≈⟨ (cleft lemma-cong↑ _ _ {!!}) ⟩
    (S ↑ • H ↑ • S ↑) • S⁻¹ ↑ • CZ • H ↑ ≈⟨ general-powers0 100 {!!} ⟩
    S ↑ • H ↑ • CZ • H ↑ ∎)
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)


{-

  lemma-S↑²H↑CZ↑H : let open PB ((₂₊ n) QRel,_===_) in
    S⁻¹ ↑ • H ↑ • CZ • H ↑ ≈ H ↑ • CZ • H ↑ • CZ ^ 2 • S⁻¹ ↓ • S⁻¹ ↑
  lemma-S↑²H↑CZ↑H {n@(₀)} = begin
    S⁻¹ ↑ • H ↑ • CZ • H ↑ ≈⟨ assoc ⟩
    S ↑ • S ↑ • H ↑ • CZ • H ↑ ≈⟨ (cright lemma-S↑H↑CZ↑H) ⟩
    S ↑ • H ↑ • CZ • H ↑ • CZ • S ↓ • S ↑ ≈⟨ by-assoc auto ⟩
    (S ↑ • H ↑ • CZ • H ↑) • CZ • S ↓ • S ↑ ≈⟨ (cleft lemma-S↑H↑CZ↑H) ⟩
    (H ↑ • CZ • H ↑ • CZ • S ↓ • S ↑) • CZ • S ↓ • S ↑ ≈⟨ by-assoc auto ⟩
    (H ↑ • CZ • H ↑) • CZ • S  • S ↑ • CZ • S  • S ↑ ≈⟨ ( general-comm auto) ⟩
    H ↑ • CZ • H ↑ • CZ ^ 2 • S⁻¹ ↓ • S⁻¹ ↑ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
  lemma-S↑²H↑CZ↑H {n@(suc n')} = begin
    S⁻¹ ↑ • H ↑ • CZ • H ↑ ≈⟨ assoc ⟩
    S ↑ • S ↑ • H ↑ • CZ • H ↑ ≈⟨ (cright lemma-S↑H↑CZ↑H) ⟩
    S ↑ • H ↑ • CZ • H ↑ • CZ • S ↓ • S ↑ ≈⟨ by-assoc auto ⟩
    (S ↑ • H ↑ • CZ • H ↑) • CZ • S ↓ • S ↑ ≈⟨ (cleft lemma-S↑H↑CZ↑H) ⟩
    (H ↑ • CZ • H ↑ • CZ • S ↓ • S ↑) • CZ • S ↓ • S ↑ ≈⟨ by-assoc auto ⟩
    (H ↑ • CZ • H ↑) • CZ • S  • S ↑ • CZ • S  • S ↑ ≈⟨ ( general-comm auto) ⟩
    H ↑ • CZ • H ↑ • CZ ^ 2 • S⁻¹ ↓ • S⁻¹ ↑ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)

-}

  lemma-H↑CZ↑HS↑ : let open PB ((₂₊ n) QRel,_===_) in
    S ↑ • S ↓ • CZ • H ↑ • CZ • H ↑ ≈ H ↑ • CZ • H ↑ • S ↑
  lemma-H↑CZ↑HS↑ {n} = begin
    S ↑ • S ↓ • CZ • H ↑ • CZ • H ↑ ≈⟨ ? ⟩
    S ↑ • (CZ • H ↑ • CZ) • H ↑ • S ↓ ≈⟨ (cright (cleft axiom selinger-c10)) ⟩
    S ↑ • (S⁻¹ ↑ • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑ • S⁻¹ ↓) • H ↑ • S ↓ ≈⟨ ? ⟩
    (H ↑ • CZ • S⁻¹ ↑) • (H ↑ • S⁻¹ ↑ • H ↑) ≈⟨ (cright lemma-cong↑ _ _ ?) ⟩
    (H ↑ • CZ • S⁻¹ ↑) • (S • H • S) ↑ ≈⟨ general-powers0 100 ? ⟩
    H ↑ • CZ • H ↑ • S ↑ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)

{-
  lemma-H↑CZ↑HS↑S↑ : let open PB ((₂₊ n) QRel,_===_) in
    S⁻¹ ↑ • S⁻¹ ↓ • CZ ^ 2 • H ↑ • CZ • H ↑ ≈ H ↑ • CZ • H ↑ • S⁻¹ ↑
  lemma-H↑CZ↑HS↑S↑ {n} = begin
    S⁻¹ ↑ • S⁻¹ ↓ • CZ ^ 2 • H ↑ • CZ • H ↑ ≈⟨ rewrite-sym0 100 auto ⟩
    (S ↑ • S ↓ • CZ) • (S ↑ • S ↓ • CZ • H ↑ • CZ • H ↑) ≈⟨ ( cright lemma-H↑CZ↑HS↑) ⟩
    (S ↑ • S ↓ • CZ) • (H ↑ • CZ • H ↑ • S ↑) ≈⟨ by-assoc auto ⟩
    (S ↑ • S ↓ • CZ • H ↑ • CZ • H ↑) • S ↑ ≈⟨ (cleft lemma-H↑CZ↑HS↑) ⟩
    (H ↑ • CZ • H ↑ • S ↑) • S ↑ ≈⟨ by-assoc auto ⟩
    H ↑ • CZ • H ↑ • S⁻¹ ↑ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)    

  lemma-S↓H↓CZ↓H : let open PB ((₂₊ n) QRel,_===_) in
    S • H • CZ • H ≈ H • CZ • H • CZ • S ↑ • S
  lemma-S↓H↓CZ↓H {n} = sym (begin
    H • CZ • H • CZ • S ↑ • S ≈⟨ by-assoc auto ⟩
    H • (CZ • H • CZ) • S ↑ • S ≈⟨ (cright (cleft axiom selinger-c11)) ⟩
    H • (S⁻¹ ↓ • H ↓ • S⁻¹ ↓ • CZ • H ↓ • S⁻¹ ↓ • S⁻¹ ↑) • S ↑ • S ≈⟨ general-powers0 100 auto ⟩
    (H • S⁻¹ ↓ • H ↓) • S⁻¹ ↓ • CZ • H ↓ ≈⟨ (cleft lemma-HSSH) ⟩
    (S • H • S) • S⁻¹ ↓ • CZ • H ↓ ≈⟨ general-powers0 100 auto ⟩
    S • H • CZ • H ∎)
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)

  lemma-S↓²H↓CZ↓H : let open PB ((₂₊ n) QRel,_===_) in
    S⁻¹ ↓ • H ↓ • CZ • H ↓ ≈ H ↓ • CZ • H ↓ • CZ ^ 2 • S⁻¹ ↑ • S⁻¹ ↓
  lemma-S↓²H↓CZ↓H {n@(₀)} = begin
    S⁻¹ ↓ • H ↓ • CZ • H ↓ ≈⟨ assoc ⟩
    S ↓ • S ↓ • H ↓ • CZ • H ↓ ≈⟨ (cright lemma-S↓H↓CZ↓H) ⟩
    S ↓ • H ↓ • CZ • H ↓ • CZ • S ↑ • S ↓ ≈⟨ by-assoc auto ⟩
    (S ↓ • H ↓ • CZ • H ↓) • CZ • S ↑ • S ↓ ≈⟨ (cleft lemma-S↓H↓CZ↓H) ⟩
    (H ↓ • CZ • H ↓ • CZ • S ↑ • S) • CZ • S ↑ • S ↓ ≈⟨ by-assoc auto ⟩
    (H ↓ • CZ • H ↓) • CZ • S ↑  • S ↓ • CZ • S ↑ • S ↓ ≈⟨ ( general-comm auto) ⟩
    H ↓ • CZ • H ↓ • CZ ^ 2 • S⁻¹ ↑ • S⁻¹ ↓ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
  lemma-S↓²H↓CZ↓H {n@(suc _)} = begin
    S⁻¹ ↓ • H ↓ • CZ • H ↓ ≈⟨ assoc ⟩
    S ↓ • S ↓ • H ↓ • CZ • H ↓ ≈⟨ (cright lemma-S↓H↓CZ↓H) ⟩
    S ↓ • H ↓ • CZ • H ↓ • CZ • S ↑ • S ↓ ≈⟨ by-assoc auto ⟩
    (S ↓ • H ↓ • CZ • H ↓) • CZ • S ↑ • S ↓ ≈⟨ (cleft lemma-S↓H↓CZ↓H) ⟩
    (H ↓ • CZ • H ↓ • CZ • S ↑ • S) • CZ • S ↑ • S ↓ ≈⟨ by-assoc auto ⟩
    (H ↓ • CZ • H ↓) • CZ • S ↑  • S ↓ • CZ • S ↑ • S ↓ ≈⟨ ( general-comm auto) ⟩
    H ↓ • CZ • H ↓ • CZ ^ 2 • S⁻¹ ↑ • S⁻¹ ↓ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
-}

  lemma-comm-S-Ex' : let open PB ((₂₊ n) QRel,_===_) in
    S • H • CZ • H • H ↑ • CZ • H ↑ ≈ H • CZ • H • H ↑ • CZ • H ↑ • S ↑
  lemma-comm-S-Ex' {n}  = begin
    S • H • CZ • H • H ↑ • CZ • H ↑ ≈⟨ by-assoc auto ⟩
    (S • H • CZ • H) • H ↑ • CZ • H ↑ ≈⟨ (cleft ?) ⟩ -- lemma-S↓H↓CZ↓H
    (H • CZ • H • CZ • S ↑ • S) • H ↑ • CZ • H ↑ ≈⟨ ? 1000 auto ⟩
    (H • CZ • H • CZ • S ↑ • H ↑) • S ↓ • CZ • H ↑ ≈⟨ (cright ? 1000 auto) ⟩
    (H • CZ • H • CZ • S ↑ • H ↑) • CZ • H ↑ • S ↓ ≈⟨ by-assoc auto ⟩
    (H • CZ • H • CZ) • (S ↑ • H ↑ • CZ • H ↑) • S ↓ ≈⟨ (cright (cleft lemma-S↑H↑CZ↑H)) ⟩
    (H • CZ • H • CZ) • (H ↑ • CZ • H ↑ • CZ • S ↓ • S ↑) • S ↓ ≈⟨ by-assoc auto ⟩
    (H • CZ • H) • (CZ • H ↑ • CZ) • H ↑ • CZ • S ↓ • S ↑ • S ↓ ≈⟨ (cright (cleft axiom selinger-c10)) ⟩
    (H • CZ • H) • (S⁻¹ ↑ • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑ • S⁻¹ ↓) • H ↑ • CZ • S ↓ • S ↑ • S ↓ ≈⟨ (cright ? auto) ⟩
    (H • CZ • H) • (S⁻¹ ↑ • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑) • H ↑ • CZ • S ↓ ^ 4 • S ↑ ≈⟨ (cright general-powers0 100 auto) ⟩
    (H • CZ • H) • (S⁻¹ ↑ • H ↑ • S⁻¹ ↑ • CZ) • (H ↑ • S⁻¹ ↑ • H ↑) • CZ • S ↓ • S ↑ ≈⟨ (cright (cright (cleft lemma-cong↑ _ _ ?))) ⟩ -- lemma-HSSH
    (H • CZ • H) • (S⁻¹ ↑ • H ↑ • S⁻¹ ↑ • CZ) • (S • H • S) ↑ • CZ • S ↓ • S ↑ ≈⟨ (cright ? 1000 auto ) ⟩
    (H • CZ • H) • (S⁻¹ ↑ • H ↑ • CZ • H ↑) • S⁻¹ ↑ • CZ • S ↓ ≈⟨ (cright (cleft ?)) ⟩ -- lemma-S↑²H↑CZ↑H
    (H • CZ • H) • (H ↑ • CZ • H ↑ • CZ ^ 2 • S⁻¹ ↓ • S⁻¹ ↑) • S⁻¹ ↑ • CZ • S ↓ ≈⟨ general-powers0 100 ? ⟩
    (H • CZ • H) • (H ↑ • CZ • H ↑ • CZ ^ 2 • S⁻¹ ↓ • S ↑) • CZ • S ↓ ≈⟨ ? ⟩
    (H • CZ • H) • (H ↑ • CZ • H ↑ • CZ ^ 3 • S ↓ ^ 3 • S ↑) ≈⟨ general-powers0 100 ? ⟩
    H • CZ • H • H ↑ • CZ • H ↑ • S ↑ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)

{-
  lemma-comm-S↑-Ex' : let open PB ((₂₊ n) QRel,_===_) in
    S ↑ • H ↑ • CZ • H ↑ • H ↓ • CZ • H ↓ ≈ H ↑ • CZ • H ↑ • H ↓ • CZ • H ↓ • S ↓
  lemma-comm-S↑-Ex' {n}  = begin
    S ↑ • H ↑ • CZ • H ↑ • H ↓ • CZ • H ↓ ≈⟨ by-assoc auto ⟩
    (S ↑ • H ↑ • CZ • H ↑) • H ↓ • CZ • H ↓ ≈⟨ (cleft lemma-S↑H↑CZ↑H) ⟩
    (H ↑ • CZ • H ↑ • CZ • S ↓ • S ↑) • H ↓ • CZ • H ↓ ≈⟨ rewrite-sym0 1000 auto ⟩
    (H ↑ • CZ • H ↑ • CZ • S ↓ • H ↓) • S ↑ • CZ • H ↓ ≈⟨ (cright rewrite-sym0 1000 auto) ⟩
    (H ↑ • CZ • H ↑ • CZ • S ↓ • H ↓) • CZ • H ↓ • S ↑ ≈⟨ by-assoc auto ⟩
    (H ↑ • CZ • H ↑ • CZ) • (S ↓ • H ↓ • CZ • H ↓) • S ↑ ≈⟨ (cright (cleft lemma-S↓H↓CZ↓H)) ⟩
    (H ↑ • CZ • H ↑ • CZ) • (H ↓ • CZ • H ↓ • CZ • S ↑ • S ↓) • S ↑ ≈⟨ by-assoc auto ⟩
    (H ↑ • CZ • H ↑) • (CZ • H ↓ • CZ) • H ↓ • CZ • S ↑ • S ↓ • S ↑ ≈⟨ (cright (cleft axiom selinger-c11)) ⟩
    (H ↑ • CZ • H ↑) • (S⁻¹ ↓ • H ↓ • S⁻¹ ↓ • CZ • H ↓ • S⁻¹ ↓ • S⁻¹ ↑) • H ↓ • CZ • S ↑ • S ↓ • S ↑ ≈⟨ (cright rewrite-sym0 1000 auto) ⟩
    (H ↑ • CZ • H ↑) • (S⁻¹ ↓ • H ↓ • S⁻¹ ↓ • CZ • H ↓ • S⁻¹ ↓) • H ↓ • CZ • S ↑ ^ 4 • S ↓ ≈⟨ (cright general-powers0 100 auto) ⟩
    (H ↑ • CZ • H ↑) • (S⁻¹ ↓ • H ↓ • S⁻¹ ↓ • CZ) • (H ↓ • S⁻¹ ↓ • H ↓) • CZ • S ↑ • S ↓ ≈⟨ ((cright (cright (cleft lemma-HSSH)))) ⟩
    (H ↑ • CZ • H ↑) • (S⁻¹ ↓ • H ↓ • S⁻¹ ↓ • CZ) • (S • H • S) • CZ • S ↑ • S ↓ ≈⟨ (cright rewrite-sym0 1000 auto) ⟩
    (H ↑ • CZ • H ↑) • (S⁻¹ ↓ • H ↓ • CZ • H ↓) • S⁻¹ ↓ • CZ • S ↑ ≈⟨ (cright cleft lemma-S↓²H↓CZ↓H) ⟩
    (H ↑ • CZ • H ↑) • (H ↓ • CZ • H ↓ • CZ ^ 2 • S⁻¹ ↑ • S⁻¹ ↓) • S⁻¹ ↓ • CZ • S ↑ ≈⟨ general-powers0 100 auto ⟩
    (H ↑ • CZ • H ↑) • (H ↓ • CZ • H ↓ • CZ ^ 2 • S⁻¹ ↑ • S ↓) • CZ • S ↑ ≈⟨ (cright rewrite-sym0 1000 auto) ⟩
    (H ↑ • CZ • H ↑) • (H ↓ • CZ • H ↓ • CZ ^ 3 • S ↑ ^ 3 • S ↓) ≈⟨ general-powers0 100 auto ⟩
    H ↑ • CZ • H ↑ • H ↓ • CZ • H ↓ • S ↓ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)    




  lemma-comm-Ex-S : let open PB ((₂₊ n) QRel,_===_) in
    S ↑ • Ex ≈ Ex • S
  lemma-comm-Ex-S {n}  = begin
    S ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ ≈⟨ general-comm auto ⟩
    (S ↑ • CZ • H • H ↑) • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ ≈⟨ (rewrite-sym0 1000 auto) ⟩
    (CZ • H) • (S ↑ • H ↑ • CZ • H ↑ • H ↓ • CZ • H ↓) • H ↑ ≈⟨ (cright (cleft lemma-comm-S↑-Ex')) ⟩
    (CZ • H) • (H ↑ • CZ • H ↑ • H ↓ • CZ • H ↓ • S ↓) • H ↑ ≈⟨ general-comm auto ⟩
    Ex • S ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)    


  lemma-SHSHS : let open PB ((₁₊ n) QRel,_===_) in

    S • H • S • H • S ≈ H ^ 3

  lemma-SHSHS  {n} = begin
    S • H • S • H • S ≈⟨ sym right-unit ⟩
    (S • H • S • H • S) • ε ≈⟨ sym (cong refl (axiom order-H)) ⟩
    (S • H • S • H • S) • H ^ 4 ≈⟨ by-assoc auto ⟩
    (S • H) ^ 3 • H ^ 3 ≈⟨ cong (axiom order-SH) refl ⟩
    ε • H ^ 3 ≈⟨ left-unit ⟩
    H ^ 3 ∎
    where
    open PB ((₁₊ n) QRel,_===_)
    open PP ((₁₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic n


  lemma-CZHCZCZ : let open PB ((₂₊ n) QRel,_===_) in
    CZ • H ↑ • CZ • CZ ≈ S • S ↑ • H ↑ ^ 3 • CZ • S ↑ • H ↑ • S ↑
  lemma-CZHCZCZ {n@(₀)} = begin
    CZ • H ↑ • CZ • CZ ≈⟨ sym (trans assoc (cong refl assoc)) ⟩
    (CZ • H ↑ • CZ) • CZ ≈⟨ cong (axiom selinger-c10) refl ⟩
    (S⁻¹ ↑ • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑ • S⁻¹ ↓) • CZ ≈⟨ general-comm auto ⟩
    (S⁻¹ ↑ • H ↑ • S⁻¹ ↑) • (CZ • H ↑ • CZ) • S⁻¹ ↑ • S⁻¹ ↓ ≈⟨ (cright (cleft axiom selinger-c10)) ⟩
    (S⁻¹ ↑ • H ↑ • S⁻¹ ↑) • (S⁻¹ ↑ • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑ • S⁻¹ ↓) • S⁻¹ ↑ • S⁻¹ ↓ ≈⟨ rewrite-sym0 100 auto ⟩
    (S⁻¹ ↑ • H ↑ • S⁻¹ ↑) • (S⁻¹ ↑ • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S ↑ • S ↓)  ≈⟨ rewrite-sym0 100 auto ⟩
    (S⁻¹ ↑ • H ↑ • S ↑ • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S ↑ • S ↓)  ≈⟨ general-powers0 100 auto ⟩
    S ↑ • (S ↑ • H ↑ • S ↑ • H ↑ • S ↑) • S ↑ • CZ • H ↑ • S ↑ • S ↓  ≈⟨ (cright (cleft lemma-cong↑ _ _ lemma-SHSHS)) ⟩
    S ↑ • (H ↑ ^ 3) • S ↑ • CZ • H ↑ • S ↑ • S ↓  ≈⟨ general-comm auto ⟩
    S • S ↑ • H ↑ ^ 3 • CZ • S ↑ • H ↑ • S ↑ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)
  lemma-CZHCZCZ {n@(suc _)} = begin
    CZ • H ↑ • CZ • CZ ≈⟨ sym (trans assoc (cong refl assoc)) ⟩
    (CZ • H ↑ • CZ) • CZ ≈⟨ cong (axiom selinger-c10) refl ⟩
    (S⁻¹ ↑ • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑ • S⁻¹ ↓) • CZ ≈⟨ general-comm auto ⟩
    (S⁻¹ ↑ • H ↑ • S⁻¹ ↑) • (CZ • H ↑ • CZ) • S⁻¹ ↑ • S⁻¹ ↓ ≈⟨ (cright (cleft axiom selinger-c10)) ⟩
    (S⁻¹ ↑ • H ↑ • S⁻¹ ↑) • (S⁻¹ ↑ • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑ • S⁻¹ ↓) • S⁻¹ ↑ • S⁻¹ ↓ ≈⟨ rewrite-sym0 100 auto ⟩
    (S⁻¹ ↑ • H ↑ • S⁻¹ ↑) • (S⁻¹ ↑ • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S ↑ • S ↓)  ≈⟨ rewrite-sym0 100 auto ⟩
    (S⁻¹ ↑ • H ↑ • S ↑ • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S ↑ • S ↓)  ≈⟨ general-powers0 100 auto ⟩
    S ↑ • (S ↑ • H ↑ • S ↑ • H ↑ • S ↑) • S ↑ • CZ • H ↑ • S ↑ • S ↓  ≈⟨ (cright (cleft lemma-cong↑ _ _ lemma-SHSHS)) ⟩
    S ↑ • (H ↑ ^ 3) • S ↑ • CZ • H ↑ • S ↑ • S ↓  ≈⟨ general-comm auto ⟩
    S • S ↑ • H ↑ ^ 3 • CZ • S ↑ • H ↑ • S ↑ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)



  lemma-CZCZH↓CZ : let open PB ((₂₊ n) QRel,_===_) in
    CZ • CZ • H • CZ ≈ S • H • CZ • S • (H ^ 3) • S • S ↑
  lemma-CZCZH↓CZ {n@(₀)} = begin
    CZ • CZ • H  • CZ ≈⟨ cong refl (axiom selinger-c11) ⟩
    CZ • (S  ^ 2 • H  • S  ^ 2 • CZ • H  • S  ^ 2 • S⁻¹ ↑) ≈⟨ general-comm auto ⟩
    S  ^ 2 • (CZ • H • CZ) • S  ^ 2 • H  • S  ^ 2 • S⁻¹ ↑ ≈⟨ (cright (cleft axiom selinger-c11)) ⟩
    S  ^ 2 • (S  ^ 2 • H  • S  ^ 2 • CZ • H  • S  ^ 2 • S⁻¹ ↑) • S  ^ 2 • H • S  ^ 2 • S⁻¹ ↑ ≈⟨ general-comm auto ⟩
    S  ^ 4 • H  • S  ^ 2 • CZ • H  • S ^ 4 • S ↑ ^ 4 • H • S  ^ 2 ≈⟨ general-powers0 100 auto ⟩
    S  • H  • S  ^ 2 • CZ • H  • S • S ↑ • H • S  ^ 2 ≈⟨ general-comm auto ⟩
    (S • H • CZ • S) • (S • H • S • H • S) • S • S ↑ ≈⟨ (cright (cleft lemma-SHSHS)) ⟩
    (S • H • CZ • S) • (H ^ 3) • S • S ↑ ≈⟨ by-assoc auto ⟩
    S • H • CZ • S • (H ^ 3) • S • S ↑ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)
  lemma-CZCZH↓CZ {n@(suc _)} = begin
    CZ • CZ • H  • CZ ≈⟨ cong refl (axiom selinger-c11) ⟩
    CZ • (S  ^ 2 • H  • S  ^ 2 • CZ • H  • S  ^ 2 • S⁻¹ ↑) ≈⟨ general-comm auto ⟩
    S  ^ 2 • (CZ • H • CZ) • S  ^ 2 • H  • S  ^ 2 • S⁻¹ ↑ ≈⟨ (cright (cleft axiom selinger-c11)) ⟩
    S  ^ 2 • (S  ^ 2 • H  • S  ^ 2 • CZ • H  • S  ^ 2 • S⁻¹ ↑) • S  ^ 2 • H • S  ^ 2 • S⁻¹ ↑ ≈⟨ general-comm auto ⟩
    S  ^ 4 • H  • S  ^ 2 • CZ • H  • S ^ 4 • S ↑ ^ 4 • H • S  ^ 2 ≈⟨ general-powers0 100 auto ⟩
    S  • H  • S  ^ 2 • CZ • H  • S • S ↑ • H • S  ^ 2 ≈⟨ general-comm auto ⟩
    (S • H • CZ • S) • (S • H • S • H • S) • S • S ↑ ≈⟨ (cright (cleft lemma-SHSHS)) ⟩
    (S • H • CZ • S) • (H ^ 3) • S • S ↑ ≈⟨ by-assoc auto ⟩
    S • H • CZ • S • (H ^ 3) • S • S ↑ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)
  

  lemma-CZH↓CZCZ : let open PB ((₂₊ n) QRel,_===_) in
    CZ • H • CZ • CZ ≈ S ↑ • S  • H  ^ 3 • CZ • S  • H  • S 
  lemma-CZH↓CZCZ {n@(₀)} = begin
    CZ • H  • CZ • CZ ≈⟨ sym (trans assoc (cong refl assoc)) ⟩
    (CZ • H  • CZ) • CZ ≈⟨ cong (axiom selinger-c11) refl ⟩
    (S  ^ 2 • H  • S  ^ 2 • CZ • H  • S  ^ 2 • S⁻¹ ↑) • CZ ≈⟨ general-comm auto ⟩
    (S  ^ 2 • H  • S  ^ 2) • (CZ • H • CZ) • S  ^ 2 • S⁻¹ ↑ ≈⟨ (cright (cleft axiom selinger-c11)) ⟩
    (S  ^ 2 • H  • S  ^ 2) • (S  ^ 2 • H • S  ^ 2 • CZ • H  • S  ^ 2 • S⁻¹ ↑) • S  ^ 2 • S⁻¹ ↑ ≈⟨ rewrite-sym0 100 auto ⟩
    (S  ^ 2 • H  • S  ^ 2) • (S  ^ 2 • H  • S  ^ 2 • CZ • H  • S  • S ↑ )  ≈⟨ rewrite-sym0 100 auto ⟩
    (S  ^ 2 • H  • S  • H  • S  ^ 2 • CZ • H  • S  • S ↑ )  ≈⟨ general-comm auto ⟩
    S  • (S  • H  • S  • H  • S ) • S  • CZ • H  • S  • S ↑  ≈⟨ (cright cleft (lemma-SHSHS)) ⟩
    S  • (H  ^ 3) • S  • CZ • H  • S  • S ↑  ≈⟨ general-comm auto ⟩
    S ↑ • S  • H  ^ 3 • CZ • S  • H  • S  ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)
  lemma-CZH↓CZCZ {n@(suc _)} = begin
    CZ • H  • CZ • CZ ≈⟨ sym (trans assoc (cong refl assoc)) ⟩
    (CZ • H  • CZ) • CZ ≈⟨ cong (axiom selinger-c11) refl ⟩
    (S  ^ 2 • H  • S  ^ 2 • CZ • H  • S  ^ 2 • S⁻¹ ↑) • CZ ≈⟨ general-comm auto ⟩
    (S  ^ 2 • H  • S  ^ 2) • (CZ • H • CZ) • S  ^ 2 • S⁻¹ ↑ ≈⟨ (cright (cleft axiom selinger-c11)) ⟩
    (S  ^ 2 • H  • S  ^ 2) • (S  ^ 2 • H • S  ^ 2 • CZ • H  • S  ^ 2 • S⁻¹ ↑) • S  ^ 2 • S⁻¹ ↑ ≈⟨ rewrite-sym0 100 auto ⟩
    (S  ^ 2 • H  • S  ^ 2) • (S  ^ 2 • H  • S  ^ 2 • CZ • H  • S  • S ↑ )  ≈⟨ rewrite-sym0 100 auto ⟩
    (S  ^ 2 • H  • S  • H  • S  ^ 2 • CZ • H  • S  • S ↑ )  ≈⟨ general-comm auto ⟩
    S  • (S  • H  • S  • H  • S ) • S  • CZ • H  • S  • S ↑  ≈⟨ (cright cleft (lemma-SHSHS)) ⟩
    S  • (H  ^ 3) • S  • CZ • H  • S  • S ↑  ≈⟨ general-comm auto ⟩
    S ↑ • S  • H  ^ 3 • CZ • S  • H  • S  ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)

  lemma-SHSH' : let open PB ((₁₊ n) QRel,_===_) in

    S • H • S • H ≈ H ^ 3 • S ^ 2

  lemma-SHSH' {n} = begin
    S • H • S • H ≈⟨ (cright lemma-HSH) ⟩
    S • (S • S) • H ^ 3 • S • S ≈⟨ general-powers0 100 auto ⟩
    H ^ 3 • S ^ 2 ∎
    where
    open PB ((₁₊ n) QRel,_===_)
    open PP ((₁₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic n


  lemma-SSHSSH : let open PB ((₁₊ n) QRel,_===_) in

    S ^ 2 • H • S ^ 2 • H ≈ H • S

  lemma-SSHSSH {n} = begin
    S ^ 2 • H • S ^ 2 • H ≈⟨ (cright lemma-HSSH) ⟩
    S ^ 2 • S • H • S ≈⟨ general-powers0 100 auto ⟩
    H • S ∎
    where
    open PB ((₁₊ n) QRel,_===_)
    open PP ((₁₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic n

  lemma-SHS : let open PB ((₁₊ n) QRel,_===_) in

    S • H • S ≈ H ^ 3 • S ^ 2 • H ^ 3

  lemma-SHS {n} = begin
    S • H • S ≈⟨ general-powers0 100 auto ⟩
    (S • H • S • H) • H ^ 3 ≈⟨ (cleft lemma-SHSH') ⟩
    (H ^ 3 • S ^ 2) • H ^ 3 ≈⟨ assoc ⟩
    H ^ 3 • S ^ 2 • H ^ 3 ∎
    where
    open PB ((₁₊ n) QRel,_===_)
    open PP ((₁₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic n


  lemma-HSHSH : let open PB ((₁₊ n) QRel,_===_) in

    H • S • H • S • H ≈ S ^ 2

  lemma-HSHSH {n} = begin
    H • S • H • S • H ≈⟨ (cright lemma-SHSH') ⟩
    H • H ^ 3 • S ^ 2 ≈⟨ general-powers0 100 auto ⟩
    S ^ 2 ∎
    where
    open PB ((₁₊ n) QRel,_===_)
    open PP ((₁₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic n

  lemma-HSHS : let open PB ((₁₊ n) QRel,_===_) in

    H • S • H • S ≈ (S • S) • H ^ 3

  lemma-HSHS {n} = begin
    H • S • H • S ≈⟨ by-assoc auto ⟩
    (H • S • H) • S ≈⟨ (cleft lemma-HSH) ⟩
    ((S • S) • H ^ 3 • S • S) • S ≈⟨ general-powers0 100 auto ⟩
    (S • S) • H ^ 3 ∎
    where
    open PB ((₁₊ n) QRel,_===_)
    open PP ((₁₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic n


  -- eqn 17 in Peter's clifford supplement.
  lemma-eqn17 : let open PB ((₂₊ n) QRel,_===_) in
    H ↑ • CZ • S⁻¹ ↑ • H ↑ • H • CZ ≈ CZ • S ↑ • H ↑ • H • CZ • S ^ 2 • H • S ^ 2
  lemma-eqn17 {n@₀} = begin
        H ↑ • CZ • S⁻¹ ↑ • H ↑ • H • CZ ≈⟨ general-powers0 100 auto ⟩
        (H ↑ • CZ • S⁻¹ ↑ • H ↑ • CZ) • CZ • CZ • H • CZ ≈⟨ rewrite-sym0 100 auto ⟩
        (H ↑ • S⁻¹ ↑) • (CZ • H ↑ • CZ • CZ) • CZ • H • CZ ≈⟨ (cright (cleft lemma-CZHCZCZ)) ⟩
        (H ↑ • S⁻¹ ↑) • (S • S ↑ • H ↑ ^ 3 • CZ • S ↑ • H ↑ • S ↑) • CZ • H • CZ ≈⟨ general-comm auto ⟩
        (H ↑ • S ↑ ^ 3 • H ↑ ^ 3) • CZ • S ↑ • H ↑ • S ↑ • S • CZ • H • CZ ≈⟨ general-powers0 100 auto ⟩
        (CZ • S ↑ • H ↑ • S ↑ • S) • CZ • H • CZ ≈⟨ cong refl (axiom selinger-c11) ⟩
        (CZ • S ↑ • H ↑ • S ↑ • S) • S⁻¹ ↓ • H ↓ • S⁻¹ ↓ • CZ • H ↓ • S⁻¹ ↓ • S⁻¹ ↑ ≈⟨ general-powers0 100 auto ⟩
        (CZ • S ↑ • H ↑ • S ↑) • H ↓ • S⁻¹ ↓ • CZ • H ↓ • S⁻¹ ↓ • S⁻¹ ↑ ≈⟨ general-comm auto ⟩
        (CZ • S ↑ • H ↑) • H ↓ • S⁻¹ ↓ • CZ • H ↓ • S⁻¹ ↓ • S ↑ ^ 3 ≈⟨ general-powers0 100 auto ⟩
        (CZ • S ↑ • H ↑) • H ↓ • S⁻¹ ↓ • CZ • H ↓ • S⁻¹ ↓ ≈⟨ general-comm auto ⟩
        CZ • S ↑ • H ↑ • H • CZ • S ^ 2 • H • S ^ 2 ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)

  lemma-eqn17 {n@(suc _)} = begin
        H ↑ • CZ • S⁻¹ ↑ • H ↑ • H • CZ ≈⟨ general-powers0 100 auto ⟩
        (H ↑ • CZ • S⁻¹ ↑ • H ↑ • CZ) • CZ • CZ • H • CZ ≈⟨ rewrite-sym0 100 auto ⟩
        (H ↑ • S⁻¹ ↑) • (CZ • H ↑ • CZ • CZ) • CZ • H • CZ ≈⟨ (cright (cleft lemma-CZHCZCZ)) ⟩
        (H ↑ • S⁻¹ ↑) • (S • S ↑ • H ↑ ^ 3 • CZ • S ↑ • H ↑ • S ↑) • CZ • H • CZ ≈⟨ general-comm auto ⟩
        (H ↑ • S ↑ ^ 3 • H ↑ ^ 3) • CZ • S ↑ • H ↑ • S ↑ • S • CZ • H • CZ ≈⟨ general-powers0 100 auto ⟩
        (CZ • S ↑ • H ↑ • S ↑ • S) • CZ • H • CZ ≈⟨ cong refl (axiom selinger-c11) ⟩
        (CZ • S ↑ • H ↑ • S ↑ • S) • S⁻¹ ↓ • H ↓ • S⁻¹ ↓ • CZ • H ↓ • S⁻¹ ↓ • S⁻¹ ↑ ≈⟨ general-powers0 100 auto ⟩
        (CZ • S ↑ • H ↑ • S ↑) • H ↓ • S⁻¹ ↓ • CZ • H ↓ • S⁻¹ ↓ • S⁻¹ ↑ ≈⟨ general-comm auto ⟩
        (CZ • S ↑ • H ↑) • H ↓ • S⁻¹ ↓ • CZ • H ↓ • S⁻¹ ↓ • S ↑ ^ 3 ≈⟨ general-powers0 100 auto ⟩
        (CZ • S ↑ • H ↑) • H ↓ • S⁻¹ ↓ • CZ • H ↓ • S⁻¹ ↓ ≈⟨ general-comm auto ⟩
        CZ • S ↑ • H ↑ • H • CZ • S ^ 2 • H • S ^ 2 ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)

  -- eqn 17 in Peter's clifford supplement.
  lemma-eqn17↓ : let open PB ((₂₊ n) QRel,_===_) in
    H  • CZ • S  ^ 2 • H  • H ↑ • CZ ≈ CZ • S  • H  • H ↑ • CZ • S⁻¹ ↑ • H ↑ • S⁻¹ ↑
  lemma-eqn17↓ {n@₀} = begin
        H  • CZ • S  ^ 2 • H • H ↑ • CZ ≈⟨ general-powers0 100 auto ⟩
        (H  • CZ • S  ^ 2 • H  • CZ) • CZ • CZ • H ↑ • CZ ≈⟨ rewrite-sym0 100 auto ⟩
        (H  • S  ^ 2) • (CZ • H • CZ • CZ) • CZ • H ↑ • CZ ≈⟨ (cright (cleft lemma-CZH↓CZCZ)) ⟩
        (H  • S  ^ 2) • (S ↑ • S  • H  ^ 3 • CZ • S • H  • S) • CZ • H ↑ • CZ ≈⟨ general-comm auto ⟩
        (H  • S  ^ 3 • H  ^ 3) • CZ • S  • H  • S • S ↑ • CZ • H ↑ • CZ ≈⟨ general-powers0 100 auto ⟩
        (CZ • S  • H  • S  • S ↑) • CZ • H ↑ • CZ ≈⟨ cong refl (axiom selinger-c10) ⟩
        (CZ • S  • H  • S  • S ↑) • S⁻¹ ↑ • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑ • S⁻¹ ↓ ≈⟨ general-powers0 100 auto ⟩
        (CZ • S  • H  • S ) • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑ • S⁻¹ ↓ ≈⟨ general-comm auto ⟩
        (CZ • S  • H ) • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑ • S  ^ 3 ≈⟨ general-powers0 100 auto ⟩
        (CZ • S  • H ) • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑ ≈⟨ general-comm auto ⟩
        CZ • S  • H  • H ↑ • CZ • S⁻¹ ↑ • H ↑ • S⁻¹ ↑ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)
  lemma-eqn17↓ {n@(suc _)} = begin
        H  • CZ • S  ^ 2 • H • H ↑ • CZ ≈⟨ general-powers0 100 auto ⟩
        (H  • CZ • S  ^ 2 • H  • CZ) • CZ • CZ • H ↑ • CZ ≈⟨ rewrite-sym0 100 auto ⟩
        (H  • S  ^ 2) • (CZ • H • CZ • CZ) • CZ • H ↑ • CZ ≈⟨ (cright (cleft lemma-CZH↓CZCZ)) ⟩
        (H  • S  ^ 2) • (S ↑ • S  • H  ^ 3 • CZ • S • H  • S) • CZ • H ↑ • CZ ≈⟨ general-comm auto ⟩
        (H  • S  ^ 3 • H  ^ 3) • CZ • S  • H  • S • S ↑ • CZ • H ↑ • CZ ≈⟨ general-powers0 100 auto ⟩
        (CZ • S  • H  • S  • S ↑) • CZ • H ↑ • CZ ≈⟨ cong refl (axiom selinger-c10) ⟩
        (CZ • S  • H  • S  • S ↑) • S⁻¹ ↑ • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑ • S⁻¹ ↓ ≈⟨ general-powers0 100 auto ⟩
        (CZ • S  • H  • S ) • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑ • S⁻¹ ↓ ≈⟨ general-comm auto ⟩
        (CZ • S  • H ) • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑ • S  ^ 3 ≈⟨ general-powers0 100 auto ⟩
        (CZ • S  • H ) • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑ ≈⟨ general-comm auto ⟩
        CZ • S  • H  • H ↑ • CZ • S⁻¹ ↑ • H ↑ • S⁻¹ ↑ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)


  -- eqn 16 in Peter's clifford supplement.
  lemma-eqn16 : let open PB ((₂₊ n) QRel,_===_) in
    S • H • CZ • H • H ↑ • CZ ≈ H • CZ • H • H ↑ • CZ • S⁻¹ ↑ • H ↑ • S⁻¹ ↑
  lemma-eqn16 {n@₀} = begin
    S • H • CZ • H • H ↑ • CZ ≈⟨ general-powers0 100 auto ⟩
    S • H • (CZ • H • CZ • CZ) • CZ • H ↑ • CZ ≈⟨ (cright (cright (cleft lemma-CZH↓CZCZ))) ⟩
    S • H • (S ↑ • S  • H  ^ 3 • CZ • S  • H  • S) • CZ • H ↑ • CZ ≈⟨ by-assoc auto ⟩
    (S • H • S ↑ • S  • H  ^ 3 • CZ • S  • H  • S) • (CZ • H ↑ • CZ) ≈⟨ (cright (axiom selinger-c10)) ⟩
    (S • H • S ↑ • S  • H  ^ 3 • CZ • S  • H  • S) • (S⁻¹ ↑ • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑ • S⁻¹ ↓) ≈⟨ general-comm auto ⟩
    (S • H • S • H  ^ 3 • CZ • S • H) • (S ↑ ^ 3 • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑ • S ↓ ^ 3) ≈⟨ general-powers0 100 auto ⟩
    (S • H • S • H  ^ 3 • CZ • S • H ) • (H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑) ≈⟨ by-assoc auto ⟩
    (S • H • S • H) • H ^ 2 • CZ • S • H  • (H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑) ≈⟨ (cleft lemma-SHSH') ⟩
    (H ^ 3 • S ^ 2) • H ^ 2 • CZ • S • H  • (H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑) ≈⟨ rewrite-sym0 100 auto ⟩
    H • CZ • H • (H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑) ≈⟨ general-comm auto ⟩
    H • CZ • H • H ↑ • CZ • S⁻¹ ↑ • H ↑ • S⁻¹ ↑ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)

  lemma-eqn16 {n@(suc _)} = begin
    S • H • CZ • H • H ↑ • CZ ≈⟨ general-powers0 100 auto ⟩
    S • H • (CZ • H • CZ • CZ) • CZ • H ↑ • CZ ≈⟨ (cright (cright (cleft lemma-CZH↓CZCZ))) ⟩
    S • H • (S ↑ • S  • H  ^ 3 • CZ • S  • H  • S) • CZ • H ↑ • CZ ≈⟨ by-assoc auto ⟩
    (S • H • S ↑ • S  • H  ^ 3 • CZ • S  • H  • S) • (CZ • H ↑ • CZ) ≈⟨ (cright (axiom selinger-c10)) ⟩
    (S • H • S ↑ • S  • H  ^ 3 • CZ • S  • H  • S) • (S⁻¹ ↑ • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑ • S⁻¹ ↓) ≈⟨ general-comm auto ⟩
    (S • H • S • H  ^ 3 • CZ • S • H) • (S ↑ ^ 3 • H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑ • S ↓ ^ 3) ≈⟨ general-powers0 100 auto ⟩
    (S • H • S • H  ^ 3 • CZ • S • H ) • (H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑) ≈⟨ by-assoc auto ⟩
    (S • H • S • H) • H ^ 2 • CZ • S • H  • (H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑) ≈⟨ (cleft lemma-SHSH') ⟩
    (H ^ 3 • S ^ 2) • H ^ 2 • CZ • S • H  • (H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑) ≈⟨ rewrite-sym0 100 auto ⟩
    H • CZ • H • (H ↑ • S⁻¹ ↑ • CZ • H ↑ • S⁻¹ ↑) ≈⟨ general-comm auto ⟩
    H • CZ • H • H ↑ • CZ • S⁻¹ ↑ • H ↑ • S⁻¹ ↑ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)

  lemma-eqn16↑ : let open PB ((₂₊ n) QRel,_===_) in
    S ↑ • H ↑ • CZ • H ↑ • H • CZ ≈ H ↑ • CZ • H ↑ • H • CZ • S ^ 2 • H • S ^ 2
  lemma-eqn16↑ {n@₀} = begin
    S ↑ • H ↑ • CZ • H ↑ • H • CZ ≈⟨ general-powers0 100 auto ⟩
    S ↑ • H ↑ • (CZ • H ↑ • CZ • CZ) • CZ • H • CZ ≈⟨ (cright (cright (cleft lemma-CZHCZCZ))) ⟩
    S ↑ • H ↑ • (S • S ↑  • H ↑  ^ 3 • CZ • S ↑  • H ↑  • S ↑) • CZ • H • CZ ≈⟨ by-assoc auto ⟩
    (S ↑ • H ↑ • S • S ↑  • H ↑  ^ 3 • CZ • S ↑  • H ↑  • S ↑) • (CZ • H • CZ) ≈⟨ (cright (axiom selinger-c11)) ⟩
    (S ↑ • H ↑ • S • S ↑  • H ↑  ^ 3 • CZ • S ↑  • H ↑  • S ↑) • (S⁻¹ ↓ • H ↓ • S⁻¹ ↓ • CZ • H ↓ • S⁻¹ ↓ • S⁻¹ ↑) ≈⟨ general-comm auto ⟩
    (S ↑ • H ↑ • S ↑ • H ↑  ^ 3 • CZ • S ↑ • H ↑) • (S ^ 3 • H • S ^ 2 • CZ • H • S ^ 2 • S ↑  ^ 3) ≈⟨ general-powers0 100 auto ⟩
    (S ↑ • H ↑ • S ↑ • H ↑  ^ 3 • CZ • S ↑ • H ↑ ) • (H • S ^ 2 • CZ • H • S ^ 2) ≈⟨ by-assoc auto ⟩
    (S ↑ • H ↑ • S ↑ • H ↑) • H ↑ ^ 2 • CZ • S ↑ • H ↑  • (H • S ^ 2 • CZ • H • S ^ 2) ≈⟨ (cleft lemma-cong↑ _ _ lemma-SHSH') ⟩
    (H ↑ ^ 3 • S⁻¹ ↑) • H ↑ ^ 2 • CZ • S ↑ • H ↑  • (H • S ^ 2 • CZ • H • S ^ 2) ≈⟨ rewrite-sym0 100 auto ⟩
    H ↑ • CZ • H ↑ • (H • S ^ 2 • CZ • H • S ^ 2) ≈⟨ general-comm auto ⟩
    H ↑ • CZ • H ↑ • H • CZ • S ^ 2 • H • S ^ 2 ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)

  lemma-eqn16↑ {n@(suc _)} = begin
    S ↑ • H ↑ • CZ • H ↑ • H • CZ ≈⟨ general-powers0 100 auto ⟩
    S ↑ • H ↑ • (CZ • H ↑ • CZ • CZ) • CZ • H • CZ ≈⟨ (cright (cright (cleft lemma-CZHCZCZ))) ⟩
    S ↑ • H ↑ • (S • S ↑  • H ↑  ^ 3 • CZ • S ↑  • H ↑  • S ↑) • CZ • H • CZ ≈⟨ by-assoc auto ⟩
    (S ↑ • H ↑ • S • S ↑  • H ↑  ^ 3 • CZ • S ↑  • H ↑  • S ↑) • (CZ • H • CZ) ≈⟨ (cright (axiom selinger-c11)) ⟩
    (S ↑ • H ↑ • S • S ↑  • H ↑  ^ 3 • CZ • S ↑  • H ↑  • S ↑) • (S⁻¹ ↓ • H ↓ • S⁻¹ ↓ • CZ • H ↓ • S⁻¹ ↓ • S⁻¹ ↑) ≈⟨ general-comm auto ⟩
    (S ↑ • H ↑ • S ↑ • H ↑  ^ 3 • CZ • S ↑ • H ↑) • (S ^ 3 • H • S ^ 2 • CZ • H • S ^ 2 • S ↑  ^ 3) ≈⟨ general-powers0 100 auto ⟩
    (S ↑ • H ↑ • S ↑ • H ↑  ^ 3 • CZ • S ↑ • H ↑ ) • (H • S ^ 2 • CZ • H • S ^ 2) ≈⟨ by-assoc auto ⟩
    (S ↑ • H ↑ • S ↑ • H ↑) • H ↑ ^ 2 • CZ • S ↑ • H ↑  • (H • S ^ 2 • CZ • H • S ^ 2) ≈⟨ (cleft lemma-cong↑ _ _ lemma-SHSH') ⟩
    (H ↑ ^ 3 • S⁻¹ ↑) • H ↑ ^ 2 • CZ • S ↑ • H ↑  • (H • S ^ 2 • CZ • H • S ^ 2) ≈⟨ rewrite-sym0 100 auto ⟩
    H ↑ • CZ • H ↑ • (H • S ^ 2 • CZ • H • S ^ 2) ≈⟨ general-comm auto ⟩
    H ↑ • CZ • H ↑ • H • CZ • S ^ 2 • H • S ^ 2 ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)


  -- eqn 18 in Peter's clifford supplement.
  lemma-comm-Ex-H' : let open PB ((₂₊ n) QRel,_===_) in
    H ↓ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ ≈ (CZ • H ↑ • H • CZ • H • H ↑ • CZ) • H ↑
  lemma-comm-Ex-H' {n@₀}  = begin
    H ↓ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ ≈⟨ general-powers0 100 auto ⟩
    (H • CZ • H ↓ • H ↑) • (CZ • H ↓ • CZ • CZ) • CZ • H ↑ • CZ ≈⟨ (cright (cleft lemma-CZH↓CZCZ)) ⟩
    (H • CZ • H ↓ • H ↑) • (S ↑ • S • H  ^ 3 • CZ • S  • H  • S) • CZ • H ↑ • CZ ≈⟨ (cright rewrite-sym0 1000 auto) ⟩
    (H • CZ • H ↓ • H ↑) • S ↑ • (S • H • S) • H ^ 2 • CZ  • H  • S • CZ • H ↑ • CZ ≈⟨ rewrite-sym0 1000 auto ⟩
    (H • CZ • H ↑) • S ↑ • (H • S • H • S • H) • H • CZ  • H  • S • CZ • H ↑ • CZ ≈⟨ (cright (cright (cleft lemma-HSHSH))) ⟩
    (H • CZ • H ↑) • S ↑ • (S ^ 2) • H • CZ  • H  • S • CZ • H ↑ • CZ ≈⟨ ((cright rewrite-sym0 1000 auto)) ⟩
    (H • CZ • H ↑) • (S ^ 2) • H • CZ • S ↑ • H  • S • CZ • H ↑ • CZ ≈⟨ by-assoc auto ⟩
    (H • CZ • H ↑ • S ^ 2 • H • CZ) • S ↑ • H  • S • CZ • H ↑ • CZ ≈⟨ general-comm auto ⟩
    (H • CZ • S ^ 2 • H • H ↑ • CZ) • S ↑ • H  • S • CZ • H ↑ • CZ ≈⟨ (cleft lemma-eqn17↓) ⟩
    (CZ • S • H  • H ↑ • CZ • S⁻¹ ↑ • H ↑ • S⁻¹ ↑) • S ↑ • H  • S • CZ • H ↑ • CZ ≈⟨ general-powers0 100 auto ⟩
    CZ • S • H  • H ↑ • CZ • S⁻¹ ↑ • H ↑ • H  • S • CZ • H ↑ • CZ ≈⟨ general-comm auto ⟩
    (CZ • H ↑ • S⁻¹ ↑) • (S • H • CZ • H • H ↑ • CZ) • S • H ↑ • CZ ≈⟨ (cright (cleft lemma-eqn16)) ⟩
    (CZ • H ↑ • S⁻¹ ↑) • (H • CZ • H • H ↑ • CZ • S⁻¹ ↑ • H ↑ • S⁻¹ ↑) • S • H ↑ • CZ ≈⟨ general-comm auto ⟩
    (CZ • H ↑ • H • CZ) • (H • S⁻¹ ↑ • H ↑ • CZ) • (S⁻¹ ↑ • H ↑ • S⁻¹ ↑ • H ↑) • S • CZ ≈⟨ (cright (cright (cleft lemma-cong↑ _ _ lemma-SSHSSH))) ⟩
    (CZ • H ↑ • H • CZ) • (H • S⁻¹ ↑ • H ↑ • CZ) • (H ↑ • S ↑) • S • CZ ≈⟨ general-comm auto ⟩
    (CZ • H ↑ • H • CZ • H) • (S⁻¹ ↑ • H ↑ • CZ • H ↑) • S ↑ • S • CZ ≈⟨ (cright (cleft lemma-S↑²H↑CZ↑H)) ⟩
    (CZ • H ↑ • H • CZ • H) • (H ↑ • CZ • H ↑ • CZ ^ 2 • S⁻¹ ↓ • S⁻¹ ↑) • S ↑ • S • CZ ≈⟨ general-powers0 100 auto ⟩
    (CZ • H ↑ • H • CZ • H • H ↑ • CZ) • H ↑ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)
  lemma-comm-Ex-H' {n@(suc _)}  = begin
    H ↓ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ ≈⟨ general-powers0 100 auto ⟩
    (H • CZ • H ↓ • H ↑) • (CZ • H ↓ • CZ • CZ) • CZ • H ↑ • CZ ≈⟨ (cright (cleft lemma-CZH↓CZCZ)) ⟩
    (H • CZ • H ↓ • H ↑) • (S ↑ • S • H  ^ 3 • CZ • S  • H  • S) • CZ • H ↑ • CZ ≈⟨ (cright rewrite-sym0 1000 auto) ⟩
    (H • CZ • H ↓ • H ↑) • S ↑ • (S • H • S) • H ^ 2 • CZ  • H  • S • CZ • H ↑ • CZ ≈⟨ rewrite-sym0 1000 auto ⟩
    (H • CZ • H ↑) • S ↑ • (H • S • H • S • H) • H • CZ  • H  • S • CZ • H ↑ • CZ ≈⟨ (cright (cright (cleft lemma-HSHSH))) ⟩
    (H • CZ • H ↑) • S ↑ • (S ^ 2) • H • CZ  • H  • S • CZ • H ↑ • CZ ≈⟨ ((cright rewrite-sym0 1000 auto)) ⟩
    (H • CZ • H ↑) • (S ^ 2) • H • CZ • S ↑ • H  • S • CZ • H ↑ • CZ ≈⟨ by-assoc auto ⟩
    (H • CZ • H ↑ • S ^ 2 • H • CZ) • S ↑ • H  • S • CZ • H ↑ • CZ ≈⟨ general-comm auto ⟩
    (H • CZ • S ^ 2 • H • H ↑ • CZ) • S ↑ • H  • S • CZ • H ↑ • CZ ≈⟨ (cleft lemma-eqn17↓) ⟩
    (CZ • S • H  • H ↑ • CZ • S⁻¹ ↑ • H ↑ • S⁻¹ ↑) • S ↑ • H  • S • CZ • H ↑ • CZ ≈⟨ general-powers0 100 auto ⟩
    CZ • S • H  • H ↑ • CZ • S⁻¹ ↑ • H ↑ • H  • S • CZ • H ↑ • CZ ≈⟨ general-comm auto ⟩
    (CZ • H ↑ • S⁻¹ ↑) • (S • H • CZ • H • H ↑ • CZ) • S • H ↑ • CZ ≈⟨ (cright (cleft lemma-eqn16)) ⟩
    (CZ • H ↑ • S⁻¹ ↑) • (H • CZ • H • H ↑ • CZ • S⁻¹ ↑ • H ↑ • S⁻¹ ↑) • S • H ↑ • CZ ≈⟨ general-comm auto ⟩
    (CZ • H ↑ • H • CZ) • (H • S⁻¹ ↑ • H ↑ • CZ) • (S⁻¹ ↑ • H ↑ • S⁻¹ ↑ • H ↑) • S • CZ ≈⟨ (cright (cright (cleft lemma-cong↑ _ _ lemma-SSHSSH))) ⟩
    (CZ • H ↑ • H • CZ) • (H • S⁻¹ ↑ • H ↑ • CZ) • (H ↑ • S ↑) • S • CZ ≈⟨ general-comm auto ⟩
    (CZ • H ↑ • H • CZ • H) • (S⁻¹ ↑ • H ↑ • CZ • H ↑) • S ↑ • S • CZ ≈⟨ (cright (cleft lemma-S↑²H↑CZ↑H)) ⟩
    (CZ • H ↑ • H • CZ • H) • (H ↑ • CZ • H ↑ • CZ ^ 2 • S⁻¹ ↓ • S⁻¹ ↑) • S ↑ • S • CZ ≈⟨ general-powers0 100 auto ⟩
    (CZ • H ↑ • H • CZ • H • H ↑ • CZ) • H ↑ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)


  lemma-comm-Ex-H↑' : let open PB ((₂₊ n) QRel,_===_) in
    H ↑  • CZ • H ↑  • H • CZ • H ↑  • H • CZ ≈ (CZ • H • H ↑ • CZ • H ↑ • H • CZ) • H
  lemma-comm-Ex-H↑' {n@₀}  = begin
    H ↑  • CZ • H ↑  • H • CZ • H ↑  • H • CZ ≈⟨ general-powers0 100 auto ⟩
    (H ↑ • CZ • H ↑  • H) • (CZ • H ↑ • CZ • CZ) • CZ • H • CZ ≈⟨ (cright (cleft lemma-CZHCZCZ)) ⟩
    (H ↑ • CZ • H ↑  • H) • (S • S ↑ • H ↑ ^ 3 • CZ • S ↑ • H ↑ • S ↑) • CZ • H • CZ ≈⟨ (cright rewrite-sym0 1000 auto) ⟩
    (H ↑ • CZ • H ↑  • H) • S • (S ↑ • H ↑ • S ↑) • H ↑ ^ 2 • CZ  • H ↑  • S ↑ • CZ • H • CZ ≈⟨ rewrite-sym0 1000 auto ⟩
    (H ↑ • CZ • H) • S • (H ↑ • S ↑ • H ↑ • S ↑ • H ↑) • H ↑ • CZ  • H ↑  • S ↑ • CZ • H • CZ ≈⟨ (cright (cright (cleft lemma-cong↑ _ _ lemma-HSHSH ))) ⟩
    (H ↑ • CZ • H) • S • (S⁻¹ ↑) • H ↑ • CZ  • H ↑  • S ↑ • CZ • H • CZ ≈⟨ ((cright general-comm auto)) ⟩
    (H ↑ • CZ • H) • (S⁻¹ ↑) • H ↑ • CZ • S • H ↑  • S ↑ • CZ • H • CZ ≈⟨ by-assoc auto ⟩
    (H ↑ • CZ • H • S⁻¹ ↑ • H ↑ • CZ) • S • H ↑  • S ↑ • CZ • H • CZ ≈⟨ general-comm auto ⟩
    (H ↑ • CZ • S⁻¹ ↑ • H ↑ • H • CZ) • S • H ↑  • S ↑ • CZ • H • CZ ≈⟨ (cleft lemma-eqn17) ⟩
    (CZ • S ↑ • H ↑  • H • CZ • S ^ 2 • H • S ^ 2) • S • H ↑  • S ↑ • CZ • H • CZ ≈⟨ general-powers0 100 auto ⟩
    CZ • S ↑ • H ↑  • H • CZ • S ^ 2 • H • H ↑  • S ↑ • CZ • H • CZ ≈⟨ general-comm auto ⟩
    (CZ • H • S ^ 2) • (S ↑ • H ↑ • CZ • H ↑ • H • CZ) • S ↑ • H • CZ ≈⟨ (cright (cleft lemma-eqn16↑)) ⟩
    (CZ • H • S ^ 2) • (H ↑ • CZ • H ↑ • H • CZ • S ^ 2 • H • S ^ 2) • S ↑ • H • CZ ≈⟨ general-comm auto ⟩
    (CZ • H • H ↑ • CZ) • (H ↑ • S ^ 2 • H • CZ) • (S ^ 2 • H • S ^ 2 • H) • S ↑ • CZ ≈⟨ (cright (cright (cleft  lemma-SSHSSH ))) ⟩
    (CZ • H • H ↑ • CZ) • (H ↑ • S ^ 2 • H • CZ) • (H • S) • S ↑ • CZ ≈⟨ general-comm auto ⟩
    (CZ • H • H ↑ • CZ • H ↑) • (S ^ 2 • H • CZ • H) • S • S ↑ • CZ ≈⟨ (cright (cleft lemma-S↓²H↓CZ↓H)) ⟩
    (CZ • H • H ↑ • CZ • H ↑) • (H • CZ • H • CZ ^ 2 • S ↑  ^ 2 • S ^ 2) • S • S ↑ • CZ ≈⟨ general-powers0 100 auto ⟩
    (CZ • H • H ↑ • CZ • H ↑ • H • CZ) • H ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)

  lemma-comm-Ex-H↑' {n@(suc _)}  = begin
    H ↑  • CZ • H ↑  • H • CZ • H ↑  • H • CZ ≈⟨ general-powers0 100 auto ⟩
    (H ↑ • CZ • H ↑  • H) • (CZ • H ↑ • CZ • CZ) • CZ • H • CZ ≈⟨ (cright (cleft lemma-CZHCZCZ)) ⟩
    (H ↑ • CZ • H ↑  • H) • (S • S ↑ • H ↑ ^ 3 • CZ • S ↑ • H ↑ • S ↑) • CZ • H • CZ ≈⟨ (cright rewrite-sym0 1000 auto) ⟩
    (H ↑ • CZ • H ↑  • H) • S • (S ↑ • H ↑ • S ↑) • H ↑ ^ 2 • CZ  • H ↑  • S ↑ • CZ • H • CZ ≈⟨ rewrite-sym0 1000 auto ⟩
    (H ↑ • CZ • H) • S • (H ↑ • S ↑ • H ↑ • S ↑ • H ↑) • H ↑ • CZ  • H ↑  • S ↑ • CZ • H • CZ ≈⟨ (cright (cright (cleft lemma-cong↑ _ _ lemma-HSHSH ))) ⟩
    (H ↑ • CZ • H) • S • (S⁻¹ ↑) • H ↑ • CZ  • H ↑  • S ↑ • CZ • H • CZ ≈⟨ ((cright general-comm auto)) ⟩
    (H ↑ • CZ • H) • (S⁻¹ ↑) • H ↑ • CZ • S • H ↑  • S ↑ • CZ • H • CZ ≈⟨ by-assoc auto ⟩
    (H ↑ • CZ • H • S⁻¹ ↑ • H ↑ • CZ) • S • H ↑  • S ↑ • CZ • H • CZ ≈⟨ general-comm auto ⟩
    (H ↑ • CZ • S⁻¹ ↑ • H ↑ • H • CZ) • S • H ↑  • S ↑ • CZ • H • CZ ≈⟨ (cleft lemma-eqn17) ⟩
    (CZ • S ↑ • H ↑  • H • CZ • S ^ 2 • H • S ^ 2) • S • H ↑  • S ↑ • CZ • H • CZ ≈⟨ general-powers0 100 auto ⟩
    CZ • S ↑ • H ↑  • H • CZ • S ^ 2 • H • H ↑  • S ↑ • CZ • H • CZ ≈⟨ general-comm auto ⟩
    (CZ • H • S ^ 2) • (S ↑ • H ↑ • CZ • H ↑ • H • CZ) • S ↑ • H • CZ ≈⟨ (cright (cleft lemma-eqn16↑)) ⟩
    (CZ • H • S ^ 2) • (H ↑ • CZ • H ↑ • H • CZ • S ^ 2 • H • S ^ 2) • S ↑ • H • CZ ≈⟨ general-comm auto ⟩
    (CZ • H • H ↑ • CZ) • (H ↑ • S ^ 2 • H • CZ) • (S ^ 2 • H • S ^ 2 • H) • S ↑ • CZ ≈⟨ (cright (cright (cleft  lemma-SSHSSH ))) ⟩
    (CZ • H • H ↑ • CZ) • (H ↑ • S ^ 2 • H • CZ) • (H • S) • S ↑ • CZ ≈⟨ general-comm auto ⟩
    (CZ • H • H ↑ • CZ • H ↑) • (S ^ 2 • H • CZ • H) • S • S ↑ • CZ ≈⟨ (cright (cleft lemma-S↓²H↓CZ↓H)) ⟩
    (CZ • H • H ↑ • CZ • H ↑) • (H • CZ • H • CZ ^ 2 • S ↑  ^ 2 • S ^ 2) • S • S ↑ • CZ ≈⟨ general-powers0 100 auto ⟩
    (CZ • H • H ↑ • CZ • H ↑ • H • CZ) • H ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)


  lemma-comm-Ex-H : let open PB ((₂₊ n) QRel,_===_) in
    H ↑ • Ex ≈ Ex • H
  lemma-comm-Ex-H {n@₀}  = begin
    H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ ≈⟨ general-comm auto ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑  • H • CZ) • H ↓ • H ↑ ≈⟨ (cleft lemma-comm-Ex-H↑') ⟩
    ((CZ • H • H ↑ • CZ • H ↑ • H • CZ) • H) • H ↓ • H ↑ ≈⟨ general-comm auto ⟩
    Ex • H ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)

  lemma-comm-Ex-H {n@(suc _)}  = begin
    H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ ≈⟨ general-comm auto ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑  • H • CZ) • H ↓ • H ↑ ≈⟨ (cleft lemma-comm-Ex-H↑') ⟩
    ((CZ • H • H ↑ • CZ • H ↑ • H • CZ) • H) • H ↓ • H ↑ ≈⟨ general-comm auto ⟩
    Ex • H ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)




  lemma-comm-Ex-CZ' : let open PB ((₂₊ n) QRel,_===_) in
    CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ ≈ (H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • CZ
  lemma-comm-Ex-CZ' {n@₀} = begin
    CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ ≈⟨ general-comm auto ⟩
    ((CZ • H • H ↑ • CZ • H ↑ • H • CZ) • H) • H ↑ ≈⟨ (cleft sym lemma-comm-Ex-H↑') ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑  • H • CZ) • H ↑ ≈⟨ general-comm auto ⟩
    H ↑  • (CZ • H ↑ • H • CZ • H • H ↑ • CZ) • H ↑ ≈⟨ (cright sym lemma-comm-Ex-H') ⟩
    H ↑  • H ↓ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ ≈⟨ general-comm auto ⟩
    (H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • CZ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)
  lemma-comm-Ex-CZ' {n@(suc _)} = begin
    CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ ≈⟨ general-comm auto ⟩
    ((CZ • H • H ↑ • CZ • H ↑ • H • CZ) • H) • H ↑ ≈⟨ (cleft sym lemma-comm-Ex-H↑') ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑  • H • CZ) • H ↑ ≈⟨ general-comm auto ⟩
    H ↑  • (CZ • H ↑ • H • CZ • H • H ↑ • CZ) • H ↑ ≈⟨ (cright sym lemma-comm-Ex-H') ⟩
    H ↑  • H ↓ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ ≈⟨ general-comm auto ⟩
    (H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • CZ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)

  lemma-comm-Ex-CZ : let open PB ((₂₊ n) QRel,_===_) in
    CZ • Ex ≈ Ex • CZ
  lemma-comm-Ex-CZ {n@₀} = begin
    CZ • Ex ≈⟨ refl ⟩
    CZ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ ≈⟨ (cright lemma-comm-Ex-CZ') ⟩
    CZ • (H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • CZ ≈⟨ sym assoc ⟩
    Ex • CZ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)

  lemma-comm-Ex-CZ {n@(suc _)} = begin
    CZ • Ex ≈⟨ refl ⟩
    CZ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ ≈⟨ (cright lemma-comm-Ex-CZ') ⟩
    CZ • (H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • CZ ≈⟨ sym assoc ⟩
    Ex • CZ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)


  lemma-order-Ex : let open PB ((₂₊ n) QRel,_===_) in
    Ex ^ 2 ≈ ε
  lemma-order-Ex {n@₀} = begin
    Ex ^ 2 ≈⟨ refl ⟩
    (CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • (CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) ≈⟨ (cright lemma-comm-Ex-CZ') ⟩
    (CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • ((H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • CZ) ≈⟨ general-comm auto ⟩
    ((CZ • H • H ↑ • CZ • H ↑ • H • CZ) • H) • H ↑ ^ 2 • (H ↓ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ) ≈⟨ cong (sym lemma-comm-Ex-H↑') (cong refl lemma-comm-Ex-H') ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑  • H • CZ) • H ↑ ^ 2 • ((CZ • H ↑ • H • CZ • H • H ↑ • CZ) • H ↑) ≈⟨ general-comm auto ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑  • H) • (CZ • H ↑ ^ 2) • ((CZ • H ↑ • H • CZ • H • H ↑ • CZ) • H ↑) ≈⟨ (cright (cleft axiom semi-CZ-HH↑)) ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑  • H) • (H ↑ ^ 2 • CZ ^ 2) • ((CZ • H ↑ • H • CZ • H • H ↑ • CZ) • H ↑) ≈⟨ general-powers0 100 auto ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑  • H) • (H ↑ ^ 2 • H ↑ • H • CZ • H • H ↑ • CZ • H ↑) ≈⟨ general-comm auto ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑ ^ 4) • (H ^ 2 • CZ) • H • H ↑ • CZ • H ↑ ≈⟨ (cright (cleft rewrite-sym0 100 auto)) ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑ ^ 4) • (CZ ^ 2 • H ^ 2) • H • H ↑ • CZ • H ↑ ≈⟨ general-powers0 100 auto ⟩
    (H ↑  • CZ) • (H ↑ ^ 2 • CZ) • H ↑ ≈⟨ (cright (cleft rewrite-sym0 100 auto)) ⟩
    (H ↑  • CZ) • (CZ ^ 2 • H ↑ ^ 2) • H ↑ ≈⟨ general-powers0 100 auto ⟩
    ε ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)

  lemma-order-Ex {n@(suc _)} = begin
    Ex ^ 2 ≈⟨ refl ⟩
    (CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • (CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) ≈⟨ (cright lemma-comm-Ex-CZ') ⟩
    (CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • ((H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • CZ) ≈⟨ general-comm auto ⟩
    ((CZ • H • H ↑ • CZ • H ↑ • H • CZ) • H) • H ↑ ^ 2 • (H ↓ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ) ≈⟨ cong (sym lemma-comm-Ex-H↑') (cong refl lemma-comm-Ex-H') ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑  • H • CZ) • H ↑ ^ 2 • ((CZ • H ↑ • H • CZ • H • H ↑ • CZ) • H ↑) ≈⟨ general-comm auto ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑  • H) • (CZ • H ↑ ^ 2) • ((CZ • H ↑ • H • CZ • H • H ↑ • CZ) • H ↑) ≈⟨ (cright (cleft axiom semi-CZ-HH↑)) ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑  • H) • (H ↑ ^ 2 • CZ ^ 2) • ((CZ • H ↑ • H • CZ • H • H ↑ • CZ) • H ↑) ≈⟨ general-powers0 100 auto ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑  • H) • (H ↑ ^ 2 • H ↑ • H • CZ • H • H ↑ • CZ • H ↑) ≈⟨ general-comm auto ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑ ^ 4) • (H ^ 2 • CZ) • H • H ↑ • CZ • H ↑ ≈⟨ (cright (cleft rewrite-sym0 100 auto)) ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑ ^ 4) • (CZ ^ 2 • H ^ 2) • H • H ↑ • CZ • H ↑ ≈⟨ general-powers0 100 auto ⟩
    (H ↑  • CZ) • (H ↑ ^ 2 • CZ) • H ↑ ≈⟨ (cright (cleft rewrite-sym0 100 auto)) ⟩
    (H ↑  • CZ) • (CZ ^ 2 • H ↑ ^ 2) • H ↑ ≈⟨ general-powers0 100 auto ⟩
    ε ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)


  lemma-order-ₕ|ₕ : let open PB ((₂₊ n) QRel,_===_) in
    ₕ|ₕ ^ 2 ≈ ε
  lemma-order-ₕ|ₕ {n} = begin
    ₕ|ₕ ^ 2 ≈⟨ rewrite-sym0 100 auto ⟩
    ε ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)

  lemma-order-ʰ|ʰ : let open PB ((₂₊ n) QRel,_===_) in
    ʰ|ʰ ^ 2 ≈ ε
  lemma-order-ʰ|ʰ {n} = begin
    ʰ|ʰ ^ 2 ≈⟨ rewrite-sym0 100 auto ⟩
    ε ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (suc n)
    open Commuting-Symplectic (n)
    open Sym0-Rewriting (suc n)


  lemma-Ex-Ex↑-CZ'a : let open PB ((₃₊ n) QRel,_===_) in
    Ex ↑ • CZ • Ex ↑ ≈ ⊤⊥ ↑ • CZ ↓ • ⊥⊤ ↑
  lemma-Ex-Ex↑-CZ'a {n@₀} = begin
    (CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) ↑ • CZ • (CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) ↑ ≈⟨ (cright (cright lemma-cong↑ _ _ lemma-comm-Ex-CZ')) ⟩
    (CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) ↑ • CZ • ((H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • CZ) ↑ ≈⟨ general-comm auto ⟩
    (((CZ • H • H ↑ • CZ • H ↑ • H • CZ) • H) • H ↑) ↑ • CZ • (H ↑ • (H ↓ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ)) ↑ ≈⟨ cong (cleft (sym (lemma-cong↑ _ _ lemma-comm-Ex-H↑'))) (cright (cright lemma-cong↑ _ _ lemma-comm-Ex-H')) ⟩
    ((H ↑  • CZ • H ↑  • H • CZ • H ↑ • H • CZ) • H ↑) ↑ • CZ • (H ↑ • ((CZ • H ↑ • H • CZ • H • H ↑ • CZ) • H ↑)) ↑ ≈⟨ general-comm auto ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑ • H) ↑ • (CZ ↑ • H ↑ ↑ ^ 2) • CZ  • (((CZ • H ↑ • H • CZ • H • H ↑ • CZ) • H ↑)) ↑ ≈⟨ (cright (cleft axiom (cong↑ semi-CZ-HH↑))) ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑ • H) ↑ • (H ↑ ↑ ^ 2 • CZ ↑ ^ 2) • CZ  • (((CZ • H ↑ • H • CZ • H • H ↑ • CZ) • H ↑)) ↑ ≈⟨ general-comm auto ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑ • H) ↑ • (H ↑ ↑ ^ 2 • CZ ↑ ^ 3) • CZ  • ((( H ↑ • H • CZ • H • H ↑ • CZ) • H ↑)) ↑ ≈⟨ general-powers0 100 auto ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑ • H) ↑ • (H ↑ ↑ ^ 2) • CZ  • ((( H ↑ • H • CZ • H • H ↑ • CZ) • H ↑)) ↑ ≈⟨ general-comm auto ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H) ↑ • (H ↑ ↑ ^ 4) • CZ  • (((H • CZ • H • H ↑ • CZ) • H ↑)) ↑ ≈⟨ general-powers0 100 auto ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H) ↑ • CZ  • (((H • CZ • H • H ↑ • CZ) • H ↑)) ↑ ≈⟨ by-assoc auto ⟩
    ⊤⊥ ↑ • CZ ↓ • ⊥⊤ ↑ ∎
    where
    open PB ((₃₊ n) QRel,_===_)
    open PP ((₃₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (₂₊ n)
    open Commuting-Symplectic (suc n)
  lemma-Ex-Ex↑-CZ'a {n@(suc _)} = begin
    (CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) ↑ • CZ • (CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) ↑ ≈⟨ (cright (cright lemma-cong↑ _ _ lemma-comm-Ex-CZ')) ⟩
    (CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) ↑ • CZ • ((H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • CZ) ↑ ≈⟨ general-comm auto ⟩
    (((CZ • H • H ↑ • CZ • H ↑ • H • CZ) • H) • H ↑) ↑ • CZ • (H ↑ • (H ↓ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ)) ↑ ≈⟨ cong (cleft (sym (lemma-cong↑ _ _ lemma-comm-Ex-H↑'))) (cright (cright lemma-cong↑ _ _ lemma-comm-Ex-H')) ⟩
    ((H ↑  • CZ • H ↑  • H • CZ • H ↑ • H • CZ) • H ↑) ↑ • CZ • (H ↑ • ((CZ • H ↑ • H • CZ • H • H ↑ • CZ) • H ↑)) ↑ ≈⟨ general-comm auto ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑ • H) ↑ • (CZ ↑ • H ↑ ↑ ^ 2) • CZ  • (((CZ • H ↑ • H • CZ • H • H ↑ • CZ) • H ↑)) ↑ ≈⟨ (cright (cleft axiom (cong↑ semi-CZ-HH↑))) ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑ • H) ↑ • (H ↑ ↑ ^ 2 • CZ ↑ ^ 2) • CZ  • (((CZ • H ↑ • H • CZ • H • H ↑ • CZ) • H ↑)) ↑ ≈⟨ general-comm auto ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑ • H) ↑ • (H ↑ ↑ ^ 2 • CZ ↑ ^ 3) • CZ  • ((( H ↑ • H • CZ • H • H ↑ • CZ) • H ↑)) ↑ ≈⟨ general-powers0 100 auto ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H ↑ • H) ↑ • (H ↑ ↑ ^ 2) • CZ  • ((( H ↑ • H • CZ • H • H ↑ • CZ) • H ↑)) ↑ ≈⟨ general-comm auto ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H) ↑ • (H ↑ ↑ ^ 4) • CZ  • (((H • CZ • H • H ↑ • CZ) • H ↑)) ↑ ≈⟨ general-powers0 100 auto ⟩
    (H ↑  • CZ • H ↑  • H • CZ • H) ↑ • CZ  • (((H • CZ • H • H ↑ • CZ) • H ↑)) ↑ ≈⟨ by-assoc auto ⟩
    ⊤⊥ ↑ • CZ ↓ • ⊥⊤ ↑ ∎
    where
    open PB ((₃₊ n) QRel,_===_)
    open PP ((₃₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (₂₊ n)
    open Commuting-Symplectic (suc n)
    


  lemma-Ex-Ex↑-CZ'b : let open PB ((₃₊ n) QRel,_===_) in
    Ex • CZ ↑ • Ex ≈ ⊥⊤ ↓ • CZ ↑ • ⊤⊥ ↓
  lemma-Ex-Ex↑-CZ'b {n} = begin
    Ex • CZ ↑ • Ex ≈⟨ refl ⟩
    (CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • CZ ↑ • (CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) ≈⟨ (cright (cright lemma-comm-Ex-CZ')) ⟩
    (CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • CZ ↑  • ((H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • CZ) ≈⟨ general-comm auto ⟩
    (((CZ • H ↑ • H • CZ • H • H ↑ • CZ) • H ↑) • H) • CZ ↑ • (H • (H ↑  • CZ • H ↑  • H • CZ • H ↑  • H • CZ)) ≈⟨ cong (cleft sym lemma-comm-Ex-H') (cright (cright lemma-comm-Ex-H↑')) ⟩
    ((H ↓ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ) • H) • CZ ↑ • (H • ((CZ • H • H ↑ • CZ • H ↑ • H • CZ) • H)) ≈⟨ general-comm auto ⟩
    (H ↓ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • (CZ • H ^ 2) • CZ ↑ • (((CZ • H • H ↑ • CZ • H ↑ • H • CZ) • H)) ≈⟨ (cright (cleft axiom semi-CZ-HH↓)) ⟩
    (H ↓ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • (H ^ 2 • CZ ^ 2) • CZ ↑ • (((CZ • H • H ↑ • CZ • H ↑ • H • CZ) • H)) ≈⟨ general-comm auto ⟩
    (H ↓ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • (H ^ 2 • CZ ^ 3) • CZ ↑ • (((H • H ↑ • CZ • H ↑ • H • CZ) • H)) ≈⟨ general-powers0 100 auto ⟩
    (H ↓ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • (H ^ 2) • CZ ↑ • (((H • H ↑ • CZ • H ↑ • H • CZ) • H)) ≈⟨ general-comm auto ⟩
    (H ↓ • CZ • H ↓ • H ↑ • CZ • H ↑) • (H ^ 4) • CZ ↑ • (((H ↑ • CZ • H ↑ • H • CZ) • H)) ≈⟨ general-powers0 100 auto ⟩
    ⊥⊤ ↓ • CZ ↑ • ⊤⊥ ↓ ∎
    where
    open PB ((₃₊ n) QRel,_===_)
    open PP ((₃₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (₂₊ n)
    open Commuting-Symplectic (suc n)



  lemma-CZ02-alt : let open PB ((₃₊ n) QRel,_===_) in
    Ex ↑ • CZ • Ex ↑ ≈ Ex • CZ ↑ • Ex
  lemma-CZ02-alt {n} = begin
    Ex ↑ • CZ • Ex ↑ ≈⟨ lemma-Ex-Ex↑-CZ'a ⟩
    ⊤⊥ ↑ • CZ ↓ • ⊥⊤ ↑ ≈⟨ axiom selinger-c13 ⟩
    ⊥⊤ ↓ • CZ ↑ • ⊤⊥ ↓ ≈⟨ sym lemma-Ex-Ex↑-CZ'b ⟩
    Ex • CZ ↑ • Ex ∎
    where
    open PB ((₃₊ n) QRel,_===_)
    open PP ((₃₊ n) QRel,_===_)
    open SR word-setoid
    open Powers0-Symplectic (₂₊ n)
    open Commuting-Symplectic (suc n)



module Symplectic-Powers where

  -- This module provides a rewrite system for reducing powers of
  -- Symplectic operators (for example, S⁴ → I). It also commutes
  -- generators on different qubits (for example, H1 H0 → H0 H1).
  -- Finally, it moves scalars to the end of the word. While this is
  -- not yet a very powerful rewrite system, it is a useful
  -- bootstrapping step.
  variable
    n : ℕ

  open Symplectic
  open Rewriting
  open Lemmas0 hiding (n)
  
  -- ----------------------------------------------------------------------
  -- * Lemmas

  -- The following lemmas are needed to justify the rewrite steps.

  -- ----------------------------------------------------------------------
  -- * Rewrite rules for monoidal structure and order of generators

  step-order : let open PB ((₁₊ n) QRel,_===_) hiding (_===_) in Step-Function (Gen (₁₊ n))  ((₁₊ n) QRel,_===_)

  -- Order of generators.
  step-order ((S-gen) ∷ (S-gen) ∷ (S-gen) ∷ xs) = just (xs , at-head (PB.axiom order-S))
  step-order ((S-gen ₛ) ∷ (S-gen ₛ) ∷ (S-gen ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ order-S)))
  step-order ((S-gen ₛ ₛ) ∷ (S-gen ₛ ₛ) ∷ (S-gen ₛ ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ (cong↑ order-S))))
  step-order ((H-gen) ∷ (H-gen) ∷ (H-gen) ∷ (H-gen) ∷ xs) = just (xs , at-head (PB.axiom order-H))
  step-order ((H-gen ₛ) ∷ (H-gen ₛ) ∷ (H-gen ₛ) ∷ (H-gen ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ order-H)))
  step-order ((H-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ (cong↑ order-H))))
  step-order ((CZ-gen) ∷ (CZ-gen) ∷ (CZ-gen) ∷ xs) = just (xs , at-head (PB.axiom order-CZ))
  step-order ((CZ-gen ₛ) ∷ (CZ-gen ₛ) ∷ (CZ-gen ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ order-CZ)))

  step-order ((S-gen) ∷ (H-gen) ∷ (S-gen) ∷ (H-gen) ∷ (S-gen) ∷ (H-gen) ∷ xs) = just (xs , at-head (PB.axiom order-SH))
  step-order ((S-gen ₛ) ∷ (H-gen ₛ) ∷ (S-gen ₛ) ∷ (H-gen ₛ) ∷ (S-gen ₛ) ∷ (H-gen ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ order-SH)))
  step-order ((S-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ (S-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ (S-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ (cong↑ order-SH))))

  step-order (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs) = just (xs , at-head ( lemma-order-Ex))
  step-order (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs) = just (xs , at-head ( (lemma-cong↑ _ _ lemma-order-Ex)))
  

  step-order ((H-gen) ∷ (CZ-gen) ∷ (H-gen) ∷ (H-gen) ∷ (CZ-gen) ∷ H-gen ∷ xs) = just (xs , at-head lemma-order-ₕ|ₕ)
  step-order ((H-gen ₛ) ∷ (CZ-gen ₛ) ∷ (H-gen ₛ) ∷ (H-gen ₛ) ∷ (CZ-gen ₛ) ∷ H-gen ₛ ∷ xs) = just (xs , at-head (lemma-cong↑ _ _ lemma-order-ₕ|ₕ))

  step-order ((H-gen ₛ) ∷ (CZ-gen) ∷ (H-gen ₛ) ∷ (H-gen ₛ) ∷ (CZ-gen) ∷ H-gen ₛ ∷ xs) = just (xs , at-head lemma-order-ʰ|ʰ)
  step-order ((H-gen ₛ ₛ) ∷ (CZ-gen ₛ) ∷ (H-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ (CZ-gen ₛ) ∷ H-gen ₛ ₛ ∷ xs) = just (xs , at-head (lemma-cong↑ _ _ lemma-order-ʰ|ʰ))

  -- Commuting of generators.

  -- Catch-all
  step-order _ = nothing

  -- From this rewrite relation, we extract a tactic 'general-powers'.
module Powers-Symplectic (n : ℕ) where
  open Symplectic
  open Rewriting
  open Symplectic-Powers hiding (n)
  open Rewriting.Step (step-cong (step-order {n})) renaming (general-rewrite to general-powers) public

-- ----------------------------------------------------------------------
-- * Lemmas

module Lemmas where
  open Lemmas0 hiding (n)
  variable
    n : ℕ

  open Symplectic
  open import Zp.ModularArithmetic


  lemma-Ex-Ex↑-CZ : let open PB ((₃₊ n) QRel,_===_) in
    Ex • Ex ↑ • CZ ≈ CZ ↑ • Ex • Ex ↑
  lemma-Ex-Ex↑-CZ {n} = begin
    Ex • Ex ↑ • CZ ≈⟨ general-powers 100 auto ⟩
    Ex • (Ex ↑ • CZ • Ex ↑) • Ex ↑ ≈⟨ cong refl (cong lemma-CZ02-alt refl) ⟩
    Ex • (Ex • CZ ↑ • Ex) • Ex ↑ ≈⟨ general-powers 100 auto ⟩
    CZ ↑ • Ex • Ex ↑ ∎
    where
    open PB ((₃₊ n) QRel,_===_)
    open PP ((₃₊ n) QRel,_===_)
    open SR word-setoid
    open Powers-Symplectic (₂₊ n)

  lemma-Ex-S : let open PB ((₂₊ n) QRel,_===_) in 
    
    Ex • S ≈ S ↑ • Ex
    
  lemma-Ex-S = PB.sym (lemma-comm-Ex-S)


  lemma-comm-S-w↑ : ∀ {n} w → let open PB ((₂₊ n) QRel,_===_) in
    
    S • w ↑ ≈ w ↑ • S
    
  lemma-comm-S-w↑ {n} [ x ↑] = sym (axiom comm-S)
    where
    open PB ((₂₊ n) QRel,_===_)
  lemma-comm-S-w↑ {n} ε = trans right-unit (sym left-unit)
    where
    open PB ((₂₊ n) QRel,_===_)
  lemma-comm-S-w↑ {n} (w • w₁) = begin
    S • ((w • w₁) ↑) ≈⟨ refl ⟩
    S • (w ↑ • w₁ ↑) ≈⟨ sym assoc ⟩
    (S • w ↑) • w₁ ↑ ≈⟨ cong (lemma-comm-S-w↑ w) refl ⟩
    (w ↑ • S) • w₁ ↑ ≈⟨ assoc ⟩
    w ↑ • S • w₁ ↑ ≈⟨ cong refl (lemma-comm-S-w↑ w₁) ⟩
    w ↑ • w₁ ↑ • S ≈⟨ sym assoc ⟩
    ((w • w₁) ↑) • S ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid

  lemma-comm-Sᵏ-w↑ : ∀ {n} k w → let open PB ((₂₊ n) QRel,_===_) in
    
    S ^ k • w ↑ ≈ w ↑ • S ^ k
    
  lemma-comm-Sᵏ-w↑ {n} ₀ w = trans left-unit (sym right-unit)
    where
    open PB ((₂₊ n) QRel,_===_)
  lemma-comm-Sᵏ-w↑ {n} ₁ w = lemma-comm-S-w↑ w
    where
    open PB ((₂₊ n) QRel,_===_)
  lemma-comm-Sᵏ-w↑ {n} (₂₊ k) w = begin
    (S • S ^ ₁₊ k) • (w ↑) ≈⟨ assoc ⟩
    S • S ^ ₁₊ k • (w ↑) ≈⟨ cong refl (lemma-comm-Sᵏ-w↑ (₁₊ k) w) ⟩
    S • (w ↑) • S ^ ₁₊ k ≈⟨ sym assoc ⟩
    (S • w ↑) • S ^ ₁₊ k ≈⟨ cong (lemma-comm-S-w↑ w) refl ⟩
    (w ↑ • S) • S ^ ₁₊ k ≈⟨ assoc ⟩
    (w ↑) • S • S ^ ₁₊ k ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid



  lemma-Ex-H : let open PB ((₂₊ n) QRel,_===_) in 
    
    Ex • H ≈ H ↑ • Ex
    
  lemma-Ex-H = PB.sym (lemma-comm-Ex-H)

  lemma-Ex-Hᵏ : ∀ k → let open PB ((₂₊ n) QRel,_===_) in 
    
    Ex • H ^ k ≈ H ↑ ^ k • Ex
    
  lemma-Ex-Hᵏ {n} ₀ = trans right-unit (sym left-unit)
    where
    open PB ((₂₊ n) QRel,_===_)
  lemma-Ex-Hᵏ {n} ₁ = lemma-Ex-H
  lemma-Ex-Hᵏ {n} (₂₊ k) = begin
    Ex • H • H ^ ₁₊ k ≈⟨ sym assoc ⟩
    (Ex • H) • H ^ ₁₊ k ≈⟨ cong lemma-Ex-H refl ⟩
    (H ↑ • Ex) • H ^ ₁₊ k ≈⟨ assoc ⟩
    H ↑ • Ex • H ^ ₁₊ k ≈⟨ cong refl (lemma-Ex-Hᵏ (₁₊ k)) ⟩
    H ↑ • H ↑ ^ ₁₊ k • Ex ≈⟨ sym assoc ⟩
    ((H ↑) • (H ↑) ^ ₁₊ k) • Ex ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid

  lemma-Ex-Sᵏ : ∀ k → let open PB ((₂₊ n) QRel,_===_) in 
    
    Ex • S ^ k ≈ S ↑ ^ k • Ex
    
  lemma-Ex-Sᵏ {n} ₀ = trans right-unit (sym left-unit)
    where
    open PB ((₂₊ n) QRel,_===_)
  lemma-Ex-Sᵏ {n} ₁ = lemma-Ex-S
  lemma-Ex-Sᵏ {n} (₂₊ k) = begin
    Ex • S • S ^ ₁₊ k ≈⟨ sym assoc ⟩
    (Ex • S) • S ^ ₁₊ k ≈⟨ cong lemma-Ex-S refl ⟩
    (S ↑ • Ex) • S ^ ₁₊ k ≈⟨ assoc ⟩
    S ↑ • Ex • S ^ ₁₊ k ≈⟨ cong refl (lemma-Ex-Sᵏ (₁₊ k)) ⟩
    S ↑ • S ↑ ^ ₁₊ k • Ex ≈⟨ sym assoc ⟩
    ((S ↑) • (S ↑) ^ ₁₊ k) • Ex ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid


  lemma-comm-H↑-Sᵏ : ∀ {n} k →
    let open PB ((₂₊ n) QRel,_===_) in
    
    H ↑ • S ^ k ≈ S ^ k • H ↑
    
  lemma-comm-H↑-Sᵏ {n} ₀ = trans right-unit (sym left-unit)
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
  lemma-comm-H↑-Sᵏ {n} (₁) = axiom comm-S
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
  lemma-comm-H↑-Sᵏ {n} (₂₊ k) = begin
    (H ↑) • S ^ ₂₊ k ≈⟨ refl ⟩
    (H ↑) • S • S ^ ₁₊ k ≈⟨ sym assoc ⟩
    (H ↑ • S) • S ^ ₁₊ k ≈⟨ cong (axiom comm-S) refl ⟩
    (S • H ↑) • S ^ ₁₊ k ≈⟨ assoc ⟩
    S • H ↑ • S ^ ₁₊ k ≈⟨ cong refl (lemma-comm-H↑-Sᵏ (₁₊ k)) ⟩
    S • S ^ ₁₊ k • H ↑ ≈⟨ sym assoc ⟩
    S ^ ₂₊ k • (H ↑) ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid


  lemma-comm-H-w↑ : ∀ {n} w → let open PB ((₂₊ n) QRel,_===_) in
    
    H • w ↑ ≈ w ↑ • H
    
  lemma-comm-H-w↑ {n} [ x ↑] = sym (axiom comm-H)
    where
    open PB ((₂₊ n) QRel,_===_)
  lemma-comm-H-w↑ {n} ε = trans right-unit (sym left-unit)
    where
    open PB ((₂₊ n) QRel,_===_)
  lemma-comm-H-w↑ {n} (w • w₁) = begin
    H • ((w • w₁) ↑) ≈⟨ refl ⟩
    H • (w ↑ • w₁ ↑) ≈⟨ sym assoc ⟩
    (H • w ↑) • w₁ ↑ ≈⟨ cong (lemma-comm-H-w↑ w) refl ⟩
    (w ↑ • H) • w₁ ↑ ≈⟨ assoc ⟩
    w ↑ • H • w₁ ↑ ≈⟨ cong refl (lemma-comm-H-w↑ w₁) ⟩
    w ↑ • w₁ ↑ • H ≈⟨ sym assoc ⟩
    ((w • w₁) ↑) • H ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid


  lemma-comm-CZ-w↑↑ : ∀ {n} w → let open PB ((₂₊ n) QRel,_===_) in
    
    CZ • w ↑ ↑ ≈ w ↑ ↑ • CZ
    
  lemma-comm-CZ-w↑↑ {n} [ H-gen ↑] = PB.sym (PB.axiom comm-CZ)
  lemma-comm-CZ-w↑↑ {n} [ S-gen ↑] = PB.sym (PB.axiom comm-CZ)
  lemma-comm-CZ-w↑↑ {n} [ CZ-gen ↑] = PB.sym (PB.axiom comm-CZ)
  lemma-comm-CZ-w↑↑ {n} [ x ₛ ↑] = PB.sym (PB.axiom comm-CZ)
  lemma-comm-CZ-w↑↑ {n} ε = PB.trans PB.right-unit (PB.sym PB.left-unit)
  lemma-comm-CZ-w↑↑ {n} (w • v) = begin
    CZ • (((w • v) ↑) ↑) ≈⟨ refl ⟩
    CZ • w ↑ ↑ • v ↑ ↑ ≈⟨ sym assoc ⟩
    (CZ • w ↑ ↑) • v ↑ ↑ ≈⟨ cong (lemma-comm-CZ-w↑↑ w) refl ⟩
    (w ↑ ↑ • CZ) • v ↑ ↑ ≈⟨ assoc ⟩
    w ↑ ↑ • CZ • v ↑ ↑ ≈⟨ cong refl (lemma-comm-CZ-w↑↑ v) ⟩
    w ↑ ↑ • v ↑ ↑ • CZ ≈⟨ sym assoc ⟩
    (((w • v) ↑) ↑) • CZ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid



  lemma-comm-S-w↑↑ : ∀ {n} w → let open PB ((₂₊ n) QRel,_===_) in
    
    S • w ↑ ↑ ≈ w ↑ ↑ • S
    
  lemma-comm-S-w↑↑ {n} [ H-gen ↑] = PB.sym (PB.axiom comm-S)
  lemma-comm-S-w↑↑ {n} [ S-gen ↑] = PB.sym (PB.axiom comm-S)
  lemma-comm-S-w↑↑ {n} [ CZ-gen ↑] = PB.sym (PB.axiom comm-S)
  lemma-comm-S-w↑↑ {n} [ x ₛ ↑] = PB.sym (PB.axiom comm-S)
  lemma-comm-S-w↑↑ {n} ε = PB.trans PB.right-unit (PB.sym PB.left-unit)
  lemma-comm-S-w↑↑ {n} (w • v) = begin
    S • (((w • v) ↑) ↑) ≈⟨ refl ⟩
    S • w ↑ ↑ • v ↑ ↑ ≈⟨ sym assoc ⟩
    (S • w ↑ ↑) • v ↑ ↑ ≈⟨ cong (lemma-comm-S-w↑↑ w) refl ⟩
    (w ↑ ↑ • S) • v ↑ ↑ ≈⟨ assoc ⟩
    w ↑ ↑ • S • v ↑ ↑ ≈⟨ cong refl (lemma-comm-S-w↑↑ v) ⟩
    w ↑ ↑ • v ↑ ↑ • S ≈⟨ sym assoc ⟩
    (((w • v) ↑) ↑) • S ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid


  lemma-comm-H-w↑↑ : ∀ {n} w → let open PB ((₂₊ n) QRel,_===_) in
    
    H • w ↑ ↑ ≈ w ↑ ↑ • H
    
  lemma-comm-H-w↑↑ {n} [ H-gen ↑] = PB.sym (PB.axiom comm-H)
  lemma-comm-H-w↑↑ {n} [ S-gen ↑] = PB.sym (PB.axiom comm-H)
  lemma-comm-H-w↑↑ {n} [ CZ-gen ↑] = PB.sym (PB.axiom comm-H)
  lemma-comm-H-w↑↑ {n} [ x ₛ ↑] = PB.sym (PB.axiom comm-H)
  lemma-comm-H-w↑↑ {n} ε = PB.trans PB.right-unit (PB.sym PB.left-unit)
  lemma-comm-H-w↑↑ {n} (w • v) = begin
    H • (((w • v) ↑) ↑) ≈⟨ refl ⟩
    H • w ↑ ↑ • v ↑ ↑ ≈⟨ sym assoc ⟩
    (H • w ↑ ↑) • v ↑ ↑ ≈⟨ cong (lemma-comm-H-w↑↑ w) refl ⟩
    (w ↑ ↑ • H) • v ↑ ↑ ≈⟨ assoc ⟩
    w ↑ ↑ • H • v ↑ ↑ ≈⟨ cong refl (lemma-comm-H-w↑↑ v) ⟩
    w ↑ ↑ • v ↑ ↑ • H ≈⟨ sym assoc ⟩
    (((w • v) ↑) ↑) • H ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid

  lemma-comm-Hᵏ-w↑ : ∀ {n} k w → let open PB ((₂₊ n) QRel,_===_) in
    
    H ^ k • w ↑ ≈ w ↑ • H ^ k
    
  lemma-comm-Hᵏ-w↑ {n} ₀ w = trans left-unit (sym right-unit)
    where
    open PB ((₂₊ n) QRel,_===_)
  lemma-comm-Hᵏ-w↑ {n} ₁ w = lemma-comm-H-w↑ w
    where
    open PB ((₂₊ n) QRel,_===_)
  lemma-comm-Hᵏ-w↑ {n} (₂₊ k) w = begin
    (H • H ^ ₁₊ k) • (w ↑) ≈⟨ assoc ⟩
    H • H ^ ₁₊ k • (w ↑) ≈⟨ cong refl (lemma-comm-Hᵏ-w↑ (₁₊ k) w) ⟩
    H • (w ↑) • H ^ ₁₊ k ≈⟨ sym assoc ⟩
    (H • w ↑) • H ^ ₁₊ k ≈⟨ cong (lemma-comm-H-w↑ w) refl ⟩
    (w ↑ • H) • H ^ ₁₊ k ≈⟨ assoc ⟩
    (w ↑) • H • H ^ ₁₊ k ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid


  lemma-comm-CZᵏ-w↑↑ : ∀ {n} k w → let open PB ((₂₊ n) QRel,_===_) in
    
    CZ ^ k • w ↑ ↑ ≈ w ↑ ↑ • CZ ^ k
    
  lemma-comm-CZᵏ-w↑↑ {n} ₀ w = trans left-unit (sym right-unit)
    where
    open PB ((₂₊ n) QRel,_===_)
  lemma-comm-CZᵏ-w↑↑ {n} ₁ w = lemma-comm-CZ-w↑↑ w
    where
    open PB ((₂₊ n) QRel,_===_)
  lemma-comm-CZᵏ-w↑↑ {n} (₂₊ k) w = begin
    (CZ • CZ ^ ₁₊ k) • (w ↑ ↑) ≈⟨ assoc ⟩
    CZ • CZ ^ ₁₊ k • (w ↑ ↑) ≈⟨ cong refl (lemma-comm-CZᵏ-w↑↑ (₁₊ k) w) ⟩
    CZ • (w ↑ ↑) • CZ ^ ₁₊ k ≈⟨ sym assoc ⟩
    (CZ • w ↑ ↑) • CZ ^ ₁₊ k ≈⟨ cong (lemma-comm-CZ-w↑↑ w) refl ⟩
    (w ↑ ↑ • CZ) • CZ ^ ₁₊ k ≈⟨ assoc ⟩
    (w ↑ ↑) • CZ • CZ ^ ₁₊ k ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid

  lemma-comm-Sᵏ-w↑↑ : ∀ {n} k w → let open PB ((₂₊ n) QRel,_===_) in
    
    S ^ k • w ↑ ↑ ≈ w ↑ ↑ • S ^ k
    
  lemma-comm-Sᵏ-w↑↑ {n} ₀ w = trans left-unit (sym right-unit)
    where
    open PB ((₂₊ n) QRel,_===_)
  lemma-comm-Sᵏ-w↑↑ {n} ₁ w = lemma-comm-S-w↑↑ w
    where
    open PB ((₂₊ n) QRel,_===_)
  lemma-comm-Sᵏ-w↑↑ {n} (₂₊ k) w = begin
    (S • S ^ ₁₊ k) • (w ↑ ↑) ≈⟨ assoc ⟩
    S • S ^ ₁₊ k • (w ↑ ↑) ≈⟨ cong refl (lemma-comm-Sᵏ-w↑↑ (₁₊ k) w) ⟩
    S • (w ↑ ↑) • S ^ ₁₊ k ≈⟨ sym assoc ⟩
    (S • w ↑ ↑) • S ^ ₁₊ k ≈⟨ cong (lemma-comm-S-w↑↑ w) refl ⟩
    (w ↑ ↑ • S) • S ^ ₁₊ k ≈⟨ assoc ⟩
    (w ↑ ↑) • S • S ^ ₁₊ k ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid

  lemma-comm-Hᵏ-w↑↑ : ∀ {n} k w → let open PB ((₂₊ n) QRel,_===_) in
    
    H ^ k • w ↑ ↑ ≈ w ↑ ↑ • H ^ k
    
  lemma-comm-Hᵏ-w↑↑ {n} ₀ w = trans left-unit (sym right-unit)
    where
    open PB ((₂₊ n) QRel,_===_)
  lemma-comm-Hᵏ-w↑↑ {n} ₁ w = lemma-comm-H-w↑↑ w
    where
    open PB ((₂₊ n) QRel,_===_)
  lemma-comm-Hᵏ-w↑↑ {n} (₂₊ k) w = begin
    (H • H ^ ₁₊ k) • (w ↑ ↑) ≈⟨ assoc ⟩
    H • H ^ ₁₊ k • (w ↑ ↑) ≈⟨ cong refl (lemma-comm-Hᵏ-w↑↑ (₁₊ k) w) ⟩
    H • (w ↑ ↑) • H ^ ₁₊ k ≈⟨ sym assoc ⟩
    (H • w ↑ ↑) • H ^ ₁₊ k ≈⟨ cong (lemma-comm-H-w↑↑ w) refl ⟩
    (w ↑ ↑ • H) • H ^ ₁₊ k ≈⟨ assoc ⟩
    (w ↑ ↑) • H • H ^ ₁₊ k ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid


  lemma-CZᵏ-H↑² : ∀ k → let open PB ((₂₊ n) QRel,_===_) in
    
    CZ ^ toℕ k • H ↑ ^ 2 ≈ H ↑ ^ 2 • CZ ^ toℕ (- k)
    
  lemma-CZᵏ-H↑² {n} ₀ = trans left-unit (sym right-unit)
    where open PB ((₂₊ n) QRel,_===_)
  lemma-CZᵏ-H↑² {n} ₁ = axiom semi-CZ-HH↑
    where open PB ((₂₊ n) QRel,_===_)
  lemma-CZᵏ-H↑² {n} ₂ = begin
    CZ ^ 2 • H ↑ ^ 2 ≈⟨ by-assoc auto ⟩
    CZ • (CZ • H ↑ ^ 2) ≈⟨ cong refl (axiom semi-CZ-HH↑) ⟩
    CZ • (H ↑ ^ 2 • CZ ^ 2) ≈⟨ sym assoc ⟩
    (CZ • H ↑ ^ 2) • CZ ^ 2 ≈⟨ cong (axiom semi-CZ-HH↑) refl ⟩
    (H ↑ ^ 2 • CZ ^ 2) • CZ ^ 2 ≈⟨ by-assoc auto  ⟩
    (H ↑ ^ 2 • CZ) • CZ ^ 3 ≈⟨ cong refl (axiom order-CZ) ⟩
    (H ↑ ^ 2 • CZ) • ε ≈⟨ right-unit ⟩
    ((H ↑) • (H ↑)) • CZ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid

  aux-e+0 : ∀ e → e + ₀ ≡ e
  aux-e+0 ₀ = auto
  aux-e+0 ₁ = auto
  aux-e+0 ₂ = auto

  lemma-^-↑ : ∀ (w : Word (Gen n)) k → w ↑ ^ k ≡ (w ^ k) ↑
  lemma-^-↑ w ₀ = auto
  lemma-^-↑ w ₁ = auto
  lemma-^-↑ w (₂₊ k) = begin
    (w ↑) • (w ↑) ^ ₁₊ k ≡⟨ Eq.cong ((w ↑) •_) (lemma-^-↑ w (suc k)) ⟩
    (w ↑) • (w ^ ₁₊ k) ↑ ≡⟨ auto ⟩
    ((w • w ^ ₁₊ k) ↑) ∎
    where open ≡-Reasoning


  lemma-Ex-HᵏSˡ : let open PB ((₂₊ n) QRel,_===_) in ∀ k l →
    
    Ex • (H ^ k • S ^ l) ≈ (H ^ k • S ^ l) ↑ • Ex
    
  lemma-Ex-HᵏSˡ {n} k l = begin
    Ex • H ^ k • S ^ l ≈⟨ sym assoc ⟩
    (Ex • H ^ k) • S ^ l ≈⟨ cong (lemma-Ex-Hᵏ k) refl ⟩
    (H ↑ ^ k • Ex) • S ^ l ≈⟨ assoc ⟩
    H ↑ ^ k • Ex • S ^ l ≈⟨ cong refl (lemma-Ex-Sᵏ l) ⟩
    H ↑ ^ k • S ↑ ^ l • Ex ≈⟨ sym assoc ⟩
    (H ↑ ^ k • S ↑ ^ l) • Ex ≈⟨ cong (cong (refl' (lemma-^-↑ H k)) (refl' (lemma-^-↑ S l))) refl ⟩
    ((H ^ k) ↑ • (S ^ l) ↑) • Ex ≈⟨ cong refl refl ⟩
    ((H ) ^ k • (S ) ^ l) ↑ • Ex ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid


-- ----------------------------------------------------------------------
-- * Lemmas

module Lemmas2 where
  open Lemmas0 hiding (n)

  variable
    n : ℕ

  open Symplectic
  open import Zp.ModularArithmetic


  lemma-Ex-H↑ : let open PB ((₂₊ n) QRel,_===_) in

    Ex • H ↑ ≈ H • Ex

  lemma-Ex-H↑ {n} = begin
    Ex • (H ↑) ≈⟨ sym right-unit ⟩
    (Ex • (H ↑)) • ε ≈⟨ (cright sym lemma-order-Ex) ⟩
    (Ex • (H ↑)) • Ex ^ 2 ≈⟨ by-assoc auto ⟩
    Ex • (H ↑ • Ex) • Ex ≈⟨ cong refl (cong (lemma-comm-Ex-H) refl) ⟩
    Ex • (Ex • H) • Ex ≈⟨ by-assoc auto ⟩
    (Ex • Ex) • H • Ex ≈⟨ cong lemma-order-Ex refl ⟩
    ε • H • Ex ≈⟨ left-unit ⟩
    H • Ex ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers-Symplectic (₁₊ n)

  lemma-Ex-S↑ : let open PB ((₂₊ n) QRel,_===_) in

    Ex • S ↑ ≈ S • Ex

  lemma-Ex-S↑ {n} = begin
    Ex • (S ↑) ≈⟨ sym right-unit ⟩
    (Ex • (S ↑)) • ε ≈⟨ (cright sym lemma-order-Ex) ⟩
    (Ex • (S ↑)) • Ex ^ 2 ≈⟨ by-assoc auto ⟩
    Ex • (S ↑ • Ex) • Ex ≈⟨ cong refl (cong (lemma-comm-Ex-S) refl) ⟩
    Ex • (Ex • S) • Ex ≈⟨ by-assoc auto ⟩
    (Ex • Ex) • S • Ex ≈⟨ cong lemma-order-Ex refl ⟩
    ε • S • Ex ≈⟨ left-unit ⟩
    S • Ex ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers-Symplectic (₁₊ n)



  lemma-CZᵏ-S↑ : let open PB ((₂₊ n) QRel,_===_) in ∀  k →

    CZ ^ k • S ↑ ≈ S ↑ • CZ ^ k
    
  lemma-CZᵏ-S↑ {n} ₀ = PB.trans PB.left-unit (PB.sym PB.right-unit)
  lemma-CZᵏ-S↑ {n} ₁ = PB.axiom comm-CZ-S↑
  lemma-CZᵏ-S↑ {n} (₂₊ k) = begin
    (CZ • CZ ^ ₁₊ k) • (S ↑) ≈⟨ assoc ⟩
    CZ • CZ ^ ₁₊ k • (S ↑) ≈⟨ cong refl (lemma-CZᵏ-S↑ (₁₊ k)) ⟩
    CZ • (S ↑) • CZ ^ ₁₊ k ≈⟨ sym assoc ⟩
    (CZ • S ↑) • CZ ^ ₁₊ k ≈⟨ cong (axiom comm-CZ-S↑) refl ⟩
    (S ↑ • CZ) • CZ ^ ₁₊ k ≈⟨ assoc ⟩
    (S ↑) • CZ • CZ ^ ₁₊ k ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers-Symplectic (₁₊ n)

  lemma-CZᵏ-S↑² : let open PB ((₂₊ n) QRel,_===_) in ∀  k →

    CZ ^ k • S⁻¹ ↑ ≈ S⁻¹ ↑ • CZ ^ k
    
  lemma-CZᵏ-S↑² {n} k = begin
    CZ ^ k • (S ↑) • (S ↑) ≈⟨ sym assoc ⟩
    (CZ ^ k • S ↑) • (S ↑) ≈⟨ cong (lemma-CZᵏ-S↑ k) refl ⟩
    (S ↑ • CZ ^ k) • (S ↑) ≈⟨ assoc ⟩
    S ↑ • CZ ^ k • (S ↑) ≈⟨ cong refl (lemma-CZᵏ-S↑ k) ⟩
    S ↑ • (S ↑) • CZ ^ k ≈⟨ sym assoc ⟩
    ((S ↑) • (S ↑)) • CZ ^ k ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers-Symplectic (₁₊ n)

  lemma-CZᵏ-Ex : let open PB ((₂₊ n) QRel,_===_) in ∀  k →

    CZ ^ k • Ex ≈ Ex • CZ ^ k
    
  lemma-CZᵏ-Ex {n} ₀ = PB.trans PB.left-unit (PB.sym PB.right-unit)
  lemma-CZᵏ-Ex {n} ₁ = lemma-comm-Ex-CZ
  lemma-CZᵏ-Ex {n} (₂₊ k) = begin
    (CZ • CZ ^ ₁₊ k) • (Ex) ≈⟨ assoc ⟩
    CZ • CZ ^ ₁₊ k • (Ex) ≈⟨ cong refl (lemma-CZᵏ-Ex (₁₊ k)) ⟩
    CZ • (Ex) • CZ ^ ₁₊ k ≈⟨ sym assoc ⟩
    (CZ • Ex) • CZ ^ ₁₊ k ≈⟨ cong (lemma-comm-Ex-CZ) refl ⟩
    (Ex • CZ) • CZ ^ ₁₊ k ≈⟨ assoc ⟩
    (Ex) • CZ • CZ ^ ₁₊ k ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers-Symplectic (₁₊ n)


  lemma-CZᵏ-CZ↑ : let open PB ((₃₊ n) QRel,_===_) in ∀  k →

    CZ ^ k • CZ ↑ ≈ CZ ↑ • CZ ^ k
    
  lemma-CZᵏ-CZ↑ {n} ₀ = PB.trans PB.left-unit (PB.sym PB.right-unit)
  lemma-CZᵏ-CZ↑ {n} ₁ = PB.sym (PB.axiom selinger-c12)
  lemma-CZᵏ-CZ↑ {n} (₂₊ k) = begin
    (CZ • CZ ^ ₁₊ k) • (CZ ↑) ≈⟨ assoc ⟩
    CZ • CZ ^ ₁₊ k • (CZ ↑) ≈⟨ cong refl (lemma-CZᵏ-CZ↑ (₁₊ k)) ⟩
    CZ • (CZ ↑) • CZ ^ ₁₊ k ≈⟨ sym assoc ⟩
    (CZ • CZ ↑) • CZ ^ ₁₊ k ≈⟨ sym (cong (axiom selinger-c12) refl) ⟩
    (CZ ↑ • CZ) • CZ ^ ₁₊ k ≈⟨ assoc ⟩
    (CZ ↑) • CZ • CZ ^ ₁₊ k ∎
    where
    open PB ((₃₊ n) QRel,_===_)
    open PP ((₃₊ n) QRel,_===_)
    open SR word-setoid
    open Powers-Symplectic (₂₊ n)


  lemma-CZᵏ↑-CZ : let open PB ((₃₊ n) QRel,_===_) in ∀  k →

    (CZ ^ k) ↑ • CZ ≈ CZ • (CZ ^ k) ↑
    
  lemma-CZᵏ↑-CZ {n} ₀ = PB.trans PB.left-unit (PB.sym PB.right-unit)
  lemma-CZᵏ↑-CZ {n} ₁ = PB.axiom selinger-c12
  lemma-CZᵏ↑-CZ {n} (₂₊ k) = begin
    (CZ • CZ ^ ₁₊ k) ↑ • (CZ) ≈⟨ assoc ⟩
    CZ ↑ • (CZ ^ ₁₊ k) ↑ • (CZ) ≈⟨ cong refl (lemma-CZᵏ↑-CZ (₁₊ k)) ⟩
    CZ ↑ • (CZ) • (CZ ^ ₁₊ k) ↑ ≈⟨ sym assoc ⟩
    (CZ ↑ • CZ) • (CZ ^ ₁₊ k) ↑ ≈⟨ cong (axiom selinger-c12) refl ⟩
    (CZ • CZ ↑) • (CZ ^ ₁₊ k) ↑ ≈⟨ assoc ⟩
    (CZ) • (CZ • CZ ^ ₁₊ k) ↑ ∎
    where
    open PB ((₃₊ n) QRel,_===_)
    open PP ((₃₊ n) QRel,_===_)
    open SR word-setoid
    open Powers-Symplectic (₂₊ n)


  lemma-CZᵏ-HH↑ : let open PB ((₂₊ n) QRel,_===_) in ∀  k →

    CZ ^ toℕ k • H ↑ ^ 2 ≈ H ↑ ^ 2 • CZ ^ toℕ (- k)
    
  lemma-CZᵏ-HH↑ {n} ₀ = PB.trans PB.left-unit (PB.sym PB.right-unit)
  lemma-CZᵏ-HH↑ {n} ₁ = PB.axiom semi-CZ-HH↑
  lemma-CZᵏ-HH↑ {n} ₂ = begin
    (CZ • CZ) • (H ↑) • (H ↑) ≈⟨ assoc ⟩
    CZ • CZ • (H ↑) • (H ↑) ≈⟨ cong refl (trans (axiom semi-CZ-HH↑) assoc) ⟩
    CZ • (H ↑) • (H ↑) • CZ ^ 2 ≈⟨ by-assoc auto ⟩
    (CZ • (H ↑) • (H ↑)) • CZ ^ 2 ≈⟨ cong (trans (axiom semi-CZ-HH↑) assoc) refl ⟩
    ((H ↑) • (H ↑) • CZ ^ 2) • CZ ^ 2 ≈⟨ general-powers 100 auto ⟩
    ((H ↑) • (H ↑)) • CZ ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers-Symplectic (₁₊ n)

  open Lemmas hiding (n)
  
  lemma-Ex-HᵏSˡ' : let open PB ((₂₊ n) QRel,_===_) in ∀ k l →
    
    Ex • (H ^ k • S ^ l) ↑ ≈ (H ^ k • S ^ l) • Ex
    
  lemma-Ex-HᵏSˡ' {n} k l = begin
    Ex • ((H ^ k • S ^ l) ↑) ≈⟨ cong refl (sym right-unit) ⟩
    Ex • (H ^ k • S ^ l) ↑ • ε ≈⟨ cong refl (cong refl (general-powers 100 auto)) ⟩
    Ex • (H ^ k • S ^ l) ↑ • Ex • Ex ≈⟨ sym (cong refl assoc) ⟩
    Ex • ((H ^ k • S ^ l) ↑ • Ex) • Ex ≈⟨ cong refl (cong (sym (lemma-Ex-HᵏSˡ k l)) refl) ⟩
    Ex • (Ex • (H ^ k • S ^ l)) • Ex ≈⟨ cong refl assoc ⟩
    Ex • Ex • (H ^ k • S ^ l) • Ex ≈⟨ sym assoc ⟩
    (Ex • Ex) • (H ^ k • S ^ l) • Ex ≈⟨ cong (general-powers 100 auto) refl ⟩
    ε • (H ^ k • S ^ l) • Ex ≈⟨ left-unit ⟩
    (H ^ k • S ^ l) • Ex ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers-Symplectic (₁₊ n)

  lemma-Ex-Sᵏ↑ : ∀ k → let open PB ((₂₊ n) QRel,_===_) in 
    
    Ex • (S ^ k) ↑ ≈ (S ^ k) • Ex
    
  lemma-Ex-Sᵏ↑ {n} k = begin
    Ex • ((S ^ k) ↑) ≈⟨ cong refl (sym right-unit) ⟩
    Ex • (S ^ k) ↑ • ε ≈⟨ cong refl (cong refl (general-powers 100 auto)) ⟩
    Ex • (S ^ k) ↑ • Ex • Ex ≈⟨ sym (cong refl assoc) ⟩
    Ex • ((S ^ k) ↑ • Ex) • Ex ≈⟨ (cright (cleft (cleft sym (refl' (lemma-^-↑ S k))))) ⟩
    Ex • ((S ↑ ^ k) • Ex) • Ex ≈⟨ cong refl (cong (sym (lemma-Ex-Sᵏ k)) refl) ⟩
    Ex • (Ex • (S ^ k)) • Ex ≈⟨ cong refl assoc ⟩
    Ex • Ex • (S ^ k) • Ex ≈⟨ sym assoc ⟩
    (Ex • Ex) • (S ^ k) • Ex ≈⟨ cong (general-powers 100 auto) refl ⟩
    ε • (S ^ k) • Ex ≈⟨ left-unit ⟩
    (S ^ k) • Ex ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers-Symplectic (₁₊ n)


  lemma-Ex-S↑ᵏ : ∀ k → let open PB ((₂₊ n) QRel,_===_) in 
    
    Ex • (S ↑ ^ k) ≈ (S ^ k) • Ex
    
  lemma-Ex-S↑ᵏ {n} k = begin
    Ex • (S ↑ ^ k) ≈⟨ refl' (Eq.cong (\ xx -> Ex • xx) (lemma-^-↑ S k)) ⟩
    Ex • (S ^ k) ↑ ≈⟨ lemma-Ex-Sᵏ↑ k ⟩
    (S ^ k) • Ex ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
    open Powers-Symplectic (₁₊ n)




module Symplectic-Rewriting where

  -- This module provides a complete rewrite system for 1-qubit
  -- Symplectic operators. It is specialized toward relations on qubit 0
  -- (but can also be applied to qubit 1 via duality).
  variable
    n : ℕ

  open Symplectic
  open Rewriting
  open Lemmas0 hiding (n)
  open Lemmas2 hiding (n)
  
  -- ----------------------------------------------------------------------
  -- * Rewrite rules for 1-qubit Symplectic relations
  
  step-symplectic : let open PB ((₁₊ n) QRel,_===_) hiding (_===_) in Step-Function (Gen (₁₊ n))  ((₁₊ n) QRel,_===_)

  -- Order of generators.
  step-symplectic ((S-gen) ∷ (S-gen) ∷ (S-gen) ∷ xs) = just (xs , at-head (PB.axiom order-S))
  step-symplectic ((S-gen ₛ) ∷ (S-gen ₛ) ∷ (S-gen ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ order-S)))
  step-symplectic ((S-gen ₛ ₛ) ∷ (S-gen ₛ ₛ) ∷ (S-gen ₛ ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ (cong↑ order-S))))
  step-symplectic ((H-gen) ∷ (H-gen) ∷ (H-gen) ∷ (H-gen) ∷ xs) = just (xs , at-head (PB.axiom order-H))
  step-symplectic ((H-gen ₛ) ∷ (H-gen ₛ) ∷ (H-gen ₛ) ∷ (H-gen ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ order-H)))
  step-symplectic ((H-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ (cong↑ order-H))))
  step-symplectic ((CZ-gen) ∷ (CZ-gen) ∷ (CZ-gen) ∷ xs) = just (xs , at-head (PB.axiom order-CZ))
  step-symplectic ((CZ-gen ₛ) ∷ (CZ-gen ₛ) ∷ (CZ-gen ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ order-CZ)))

  step-symplectic ((S-gen) ∷ (H-gen) ∷ (S-gen) ∷ (H-gen) ∷ (S-gen) ∷ (H-gen) ∷ xs) = just (xs , at-head (PB.axiom order-SH))
  step-symplectic ((S-gen ₛ) ∷ (H-gen ₛ) ∷ (S-gen ₛ) ∷ (H-gen ₛ) ∷ (S-gen ₛ) ∷ (H-gen ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ order-SH)))
  step-symplectic ((S-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ (S-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ (S-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ (cong↑ order-SH))))

  step-symplectic (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs) = just (xs , at-head (lemma-order-Ex))
  step-symplectic (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs) = just (xs , at-head ( (lemma-cong↑ _ _ lemma-order-Ex)))

  -- Commuting of generators.
  step-symplectic ((S-gen) ∷ (CZ-gen) ∷ xs) = just ((CZ-gen) ∷ (S-gen) ∷ xs , at-head (PB.sym (PB.axiom comm-CZ-S↓)))
  step-symplectic ((S-gen ₛ) ∷ (CZ-gen) ∷ xs) = just ((CZ-gen) ∷ (S-gen ₛ) ∷ xs , at-head (PB.sym (PB.axiom comm-CZ-S↑)))
  step-symplectic ((S-gen ₛ) ∷ (CZ-gen ₛ) ∷ xs) = just ((CZ-gen ₛ) ∷ (S-gen ₛ) ∷ xs , at-head (PB.sym (PB.axiom (cong↑ comm-CZ-S↓))))
  step-symplectic ((S-gen ₛ ₛ) ∷ (CZ-gen ₛ) ∷ xs) = just ((CZ-gen ₛ) ∷ (S-gen ₛ ₛ) ∷ xs , at-head (PB.sym (PB.axiom (cong↑ comm-CZ-S↑))))

  step-symplectic ((H-gen ₛ ₛ) ∷ (CZ-gen) ∷ xs) = just ((CZ-gen) ∷ (H-gen ₛ ₛ) ∷ xs , at-head (PB.axiom comm-CZ))
  step-symplectic ((S-gen ₛ ₛ) ∷ (CZ-gen) ∷ xs) = just ((CZ-gen) ∷ (S-gen ₛ ₛ) ∷ xs , at-head (PB.axiom comm-CZ))

  step-symplectic ((S-gen ₛ) ∷ (S-gen) ∷ xs) = just ((S-gen) ∷ (S-gen ₛ) ∷ xs , at-head ((PB.axiom comm-S)))
  step-symplectic ((S-gen ₛ ₛ) ∷ (S-gen ₛ) ∷ xs) = just ((S-gen ₛ) ∷ (S-gen ₛ ₛ) ∷ xs , at-head ((PB.axiom (cong↑ comm-S))))
  step-symplectic ((S-gen ₛ ₛ) ∷ (S-gen) ∷ xs) = just ((S-gen) ∷ (S-gen ₛ ₛ) ∷ xs , at-head (PB.axiom comm-S))
  step-symplectic ((S-gen ₛ) ∷ (H-gen) ∷ xs) = just ((H-gen) ∷ (S-gen ₛ) ∷ xs , at-head ((PB.axiom comm-H)))
  step-symplectic ((S-gen ₛ ₛ) ∷ (H-gen ₛ) ∷ xs) = just ((H-gen ₛ) ∷ (S-gen ₛ ₛ) ∷ xs , at-head ((PB.axiom (cong↑ comm-H))))
  step-symplectic ((S-gen ₛ ₛ) ∷ (H-gen) ∷ xs) = just ((H-gen) ∷ (S-gen ₛ ₛ) ∷ xs , at-head (PB.axiom comm-H))
  step-symplectic ((H-gen ₛ) ∷ (H-gen) ∷ xs) = just ((H-gen) ∷ (H-gen ₛ) ∷ xs , at-head ((PB.axiom comm-H)))
  step-symplectic ((H-gen ₛ) ∷ (S-gen) ∷ xs) = just ((S-gen) ∷ (H-gen ₛ) ∷ xs , at-head ((PB.axiom comm-S)))
  step-symplectic ((H-gen ₛ ₛ) ∷ (H-gen ₛ) ∷ xs) = just ((H-gen ₛ) ∷ (H-gen ₛ ₛ) ∷ xs , at-head ((PB.axiom (cong↑ comm-H))))
  step-symplectic ((H-gen ₛ ₛ) ∷ (H-gen) ∷ xs) = just ((H-gen) ∷ (H-gen ₛ ₛ) ∷ xs , at-head (PB.axiom comm-H))
  step-symplectic ((H-gen ₛ ₛ) ∷ (S-gen ₛ) ∷ xs) = just ((S-gen ₛ) ∷ (H-gen ₛ ₛ) ∷ xs , at-head ((PB.axiom (cong↑ comm-S))))
  step-symplectic ((H-gen ₛ ₛ) ∷ (S-gen) ∷ xs) = just ((S-gen) ∷ (H-gen ₛ ₛ) ∷ xs , at-head (PB.axiom comm-S))

  step-symplectic ((CZ-gen ₛ ₛ) ∷ (H-gen ₛ) ∷ xs) = just ((H-gen ₛ) ∷ (CZ-gen ₛ ₛ) ∷ xs , at-head ((PB.axiom (cong↑ comm-H))))
  step-symplectic ((CZ-gen ₛ ₛ) ∷ (H-gen) ∷ xs) = just ((H-gen) ∷ (CZ-gen ₛ ₛ) ∷ xs , at-head (PB.axiom comm-H))
  step-symplectic ((CZ-gen ₛ ₛ) ∷ (S-gen ₛ) ∷ xs) = just ((S-gen ₛ) ∷ (CZ-gen ₛ ₛ) ∷ xs , at-head ((PB.axiom (cong↑ comm-S))))
  step-symplectic ((CZ-gen ₛ ₛ) ∷ (S-gen) ∷ xs) = just ((S-gen) ∷ (CZ-gen ₛ ₛ) ∷ xs , at-head (PB.axiom comm-S))

  step-symplectic ((CZ-gen ₛ ₛ) ∷ (CZ-gen) ∷ xs) = just ((CZ-gen) ∷ (CZ-gen ₛ ₛ) ∷ xs , at-head ((PB.axiom comm-CZ)))
  step-symplectic ((CZ-gen ₛ) ∷ (CZ-gen) ∷ xs) = just ((CZ-gen) ∷ (CZ-gen ₛ) ∷ xs , at-head ((PB.axiom selinger-c12)))

  step-symplectic ((S-gen) ∷ (H-gen) ∷ (H-gen) ∷ xs) = just ((H-gen) ∷ (H-gen) ∷ (S-gen) ∷ xs , at-head (PB.sym (PB.axiom comm-HHS)))
  step-symplectic ((S-gen ₛ) ∷ (H-gen ₛ) ∷ (H-gen ₛ) ∷ xs) = just ((H-gen ₛ) ∷ (H-gen ₛ) ∷ (S-gen ₛ) ∷ xs , at-head (PB.sym (PB.axiom (cong↑ comm-HHS))))
  step-symplectic ((S-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ xs) = just ((H-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ (S-gen ₛ ₛ) ∷ xs , at-head (PB.sym (PB.axiom (cong↑ (cong↑ comm-HHS)))))

  -- Others.
  step-symplectic ((CZ-gen) ∷ (H-gen) ∷ (H-gen) ∷ xs) = just ((H-gen) ∷ (H-gen) ∷ (CZ-gen) ∷ (CZ-gen) ∷ xs , at-head (PB.axiom semi-CZ-HH↓))
  step-symplectic ((CZ-gen) ∷ (H-gen ₛ) ∷ (H-gen ₛ) ∷ xs) = just ((H-gen ₛ) ∷ (H-gen ₛ) ∷ (CZ-gen) ∷ (CZ-gen) ∷ xs , at-head (PB.axiom semi-CZ-HH↑))

  step-symplectic ((CZ-gen) ∷ (H-gen) ∷ (CZ-gen) ∷ xs) = just ((S-gen) ∷ (S-gen) ∷ H-gen ∷ (S-gen) ∷ (S-gen) ∷ CZ-gen ∷ H-gen ∷ S-gen ∷ S-gen ∷ S-gen ₛ ∷ S-gen ₛ ∷ xs , at-head (PB.axiom selinger-c11 ))
  step-symplectic ((CZ-gen ₛ) ∷ (H-gen ₛ) ∷ (CZ-gen ₛ) ∷ xs) = just ((S-gen ₛ) ∷ (S-gen ₛ) ∷ H-gen ₛ ∷ (S-gen ₛ) ∷ (S-gen ₛ) ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ S-gen ₛ ∷ S-gen ₛ ∷ S-gen ₛ ₛ ∷ S-gen ₛ ₛ ∷ xs , at-head (PB.axiom (cong↑ selinger-c11 )))
  step-symplectic ((CZ-gen) ∷ (H-gen ₛ) ∷ (CZ-gen) ∷ xs) = just ((S-gen ₛ) ∷ (S-gen ₛ) ∷ H-gen ₛ ∷ (S-gen ₛ) ∷ (S-gen ₛ) ∷ CZ-gen ∷ H-gen ₛ ∷ S-gen ₛ ∷ S-gen ₛ ∷ S-gen ∷ S-gen ∷ xs , at-head (PB.axiom selinger-c10 ))
  step-symplectic ((CZ-gen ₛ) ∷ (H-gen ₛ ₛ) ∷ (CZ-gen ₛ) ∷ xs) = just ((S-gen ₛ ₛ) ∷ (S-gen ₛ ₛ) ∷ H-gen ₛ ₛ ∷ (S-gen ₛ ₛ) ∷ (S-gen ₛ ₛ) ∷ CZ-gen ₛ ∷ H-gen ₛ ₛ ∷ S-gen ₛ ₛ ∷ S-gen ₛ ₛ ∷ S-gen ₛ ∷ S-gen ₛ ∷ xs , at-head (PB.axiom (cong↑ selinger-c10 )))

  step-symplectic (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ xs) = just (CZ-gen ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs , at-head (PB.sym (lemma-comm-Ex-CZ)))
  step-symplectic (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ xs) = just (CZ-gen ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs , at-head (PB.sym ( (lemma-cong↑ _ _ lemma-comm-Ex-CZ))))

  step-symplectic (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ H-gen ∷ xs) = just (H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs , at-head (PB.sym (lemma-comm-Ex-H)))
  step-symplectic (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ H-gen ₛ ∷ xs) = just (H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs , at-head (PB.sym ( (lemma-cong↑ _ _ lemma-comm-Ex-H))))

  step-symplectic (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ S-gen ∷ xs) = just (S-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs , at-head (PB.sym (lemma-comm-Ex-S)))
  step-symplectic (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ S-gen ₛ ∷ xs) = just (S-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs , at-head (PB.sym ( (lemma-cong↑ _ _ lemma-comm-Ex-S))))

  step-symplectic {suc n} (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ S-gen ₛ ∷ xs) = just (S-gen ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs , at-head (((lemma-Ex-S↑ {n}))))
  step-symplectic (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ S-gen ₛ ₛ ∷ xs) = just (S-gen ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs , at-head (lemma-cong↑ _ _ lemma-Ex-S↑))

  step-symplectic {suc n} (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ H-gen ₛ ∷ xs) = just (H-gen ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs , at-head (((lemma-Ex-H↑ {n}))))
  step-symplectic (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ H-gen ₛ ₛ ∷ xs) = just (H-gen ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs , at-head (lemma-cong↑ _ _ lemma-Ex-H↑))



  -- Catch-all
  step-symplectic _ = nothing

module Rewriting-Symplectic (n : ℕ) where
  open Symplectic
  open Rewriting
  open Symplectic-Rewriting hiding (n)
  open Rewriting.Step (step-cong (step-symplectic {n})) renaming (general-rewrite to rewrite-sym) public


module Swap-Rewriting where

  -- This module provides a complete rewrite system for 1-qubit
  -- Swap operators. It is specialized toward relations on qubit 0
  -- (but can also be applied to qubit 1 via duality).
  variable
    n : ℕ

  open Symplectic
  open Rewriting
  open Lemmas0 hiding (n)
  open Lemmas2 hiding (n)
  
  -- ----------------------------------------------------------------------
  -- * Rewrite rules for 1-qubit Swap relations
  
  step-swap : let open PB ((₁₊ n) QRel,_===_) hiding (_===_) in Step-Function (Gen (₁₊ n))  ((₁₊ n) QRel,_===_)

  -- Order of generators.
  step-swap ((S-gen) ∷ (S-gen) ∷ (S-gen) ∷ xs) = just (xs , at-head (PB.axiom order-S))
  step-swap ((S-gen ₛ) ∷ (S-gen ₛ) ∷ (S-gen ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ order-S)))
  step-swap ((S-gen ₛ ₛ) ∷ (S-gen ₛ ₛ) ∷ (S-gen ₛ ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ (cong↑ order-S))))
  step-swap ((H-gen) ∷ (H-gen) ∷ (H-gen) ∷ (H-gen) ∷ xs) = just (xs , at-head (PB.axiom order-H))
  step-swap ((H-gen ₛ) ∷ (H-gen ₛ) ∷ (H-gen ₛ) ∷ (H-gen ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ order-H)))
  step-swap ((H-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ (cong↑ order-H))))
  step-swap ((CZ-gen) ∷ (CZ-gen) ∷ (CZ-gen) ∷ xs) = just (xs , at-head (PB.axiom order-CZ))
  step-swap ((CZ-gen ₛ) ∷ (CZ-gen ₛ) ∷ (CZ-gen ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ order-CZ)))

  step-swap ((S-gen) ∷ (H-gen) ∷ (S-gen) ∷ (H-gen) ∷ (S-gen) ∷ (H-gen) ∷ xs) = just (xs , at-head (PB.axiom order-SH))
  step-swap ((S-gen ₛ) ∷ (H-gen ₛ) ∷ (S-gen ₛ) ∷ (H-gen ₛ) ∷ (S-gen ₛ) ∷ (H-gen ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ order-SH)))
  step-swap ((S-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ (S-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ (S-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ xs) = just (xs , at-head (PB.axiom (cong↑ (cong↑ order-SH))))

  step-swap (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs) = just (xs , at-head (lemma-order-Ex))
  step-swap (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs) = just (xs , at-head ( (lemma-cong↑ _ _ lemma-order-Ex)))


  -- Commuting of generators.
  -- step-swap ((S-gen) ∷ (CZ-gen) ∷ xs) = just ((CZ-gen) ∷ (S-gen) ∷ xs , at-head (PB.sym (PB.axiom comm-CZ-S↓)))
  -- step-swap ((S-gen ₛ) ∷ (CZ-gen) ∷ xs) = just ((CZ-gen) ∷ (S-gen ₛ) ∷ xs , at-head (PB.sym (PB.axiom comm-CZ-S↑)))
  -- step-swap ((S-gen ₛ) ∷ (CZ-gen ₛ) ∷ xs) = just ((CZ-gen ₛ) ∷ (S-gen ₛ) ∷ xs , at-head (PB.sym (PB.axiom (cong↑ comm-CZ-S↓))))
  -- step-swap ((S-gen ₛ ₛ) ∷ (CZ-gen ₛ) ∷ xs) = just ((CZ-gen ₛ) ∷ (S-gen ₛ ₛ) ∷ xs , at-head (PB.sym (PB.axiom (cong↑ comm-CZ-S↑))))

  -- step-swap ((H-gen ₛ ₛ) ∷ (CZ-gen) ∷ xs) = just ((CZ-gen) ∷ (H-gen ₛ ₛ) ∷ xs , at-head (PB.axiom comm-CZ))
  -- step-swap ((S-gen ₛ ₛ) ∷ (CZ-gen) ∷ xs) = just ((CZ-gen) ∷ (S-gen ₛ ₛ) ∷ xs , at-head (PB.axiom comm-CZ))

  -- step-swap ((S-gen ₛ) ∷ (S-gen) ∷ xs) = just ((S-gen) ∷ (S-gen ₛ) ∷ xs , at-head ((PB.axiom comm-S)))
  -- step-swap ((S-gen ₛ ₛ) ∷ (S-gen ₛ) ∷ xs) = just ((S-gen ₛ) ∷ (S-gen ₛ ₛ) ∷ xs , at-head ((PB.axiom (cong↑ comm-S))))
  -- step-swap ((S-gen ₛ ₛ) ∷ (S-gen) ∷ xs) = just ((S-gen) ∷ (S-gen ₛ ₛ) ∷ xs , at-head (PB.axiom comm-S))
  -- step-swap ((S-gen ₛ) ∷ (H-gen) ∷ xs) = just ((H-gen) ∷ (S-gen ₛ) ∷ xs , at-head ((PB.axiom comm-H)))
  -- step-swap ((S-gen ₛ ₛ) ∷ (H-gen ₛ) ∷ xs) = just ((H-gen ₛ) ∷ (S-gen ₛ ₛ) ∷ xs , at-head ((PB.axiom (cong↑ comm-H))))
  -- step-swap ((S-gen ₛ ₛ) ∷ (H-gen) ∷ xs) = just ((H-gen) ∷ (S-gen ₛ ₛ) ∷ xs , at-head (PB.axiom comm-H))
  -- step-swap ((H-gen ₛ) ∷ (H-gen) ∷ xs) = just ((H-gen) ∷ (H-gen ₛ) ∷ xs , at-head ((PB.axiom comm-H)))
  -- step-swap ((H-gen ₛ) ∷ (S-gen) ∷ xs) = just ((S-gen) ∷ (H-gen ₛ) ∷ xs , at-head ((PB.axiom comm-S)))
  -- step-swap ((H-gen ₛ ₛ) ∷ (H-gen ₛ) ∷ xs) = just ((H-gen ₛ) ∷ (H-gen ₛ ₛ) ∷ xs , at-head ((PB.axiom (cong↑ comm-H))))
  -- step-swap ((H-gen ₛ ₛ) ∷ (H-gen) ∷ xs) = just ((H-gen) ∷ (H-gen ₛ ₛ) ∷ xs , at-head (PB.axiom comm-H))
  -- step-swap ((H-gen ₛ ₛ) ∷ (S-gen ₛ) ∷ xs) = just ((S-gen ₛ) ∷ (H-gen ₛ ₛ) ∷ xs , at-head ((PB.axiom (cong↑ comm-S))))
  -- step-swap ((H-gen ₛ ₛ) ∷ (S-gen) ∷ xs) = just ((S-gen) ∷ (H-gen ₛ ₛ) ∷ xs , at-head (PB.axiom comm-S))

  -- step-swap ((CZ-gen ₛ ₛ) ∷ (H-gen ₛ) ∷ xs) = just ((H-gen ₛ) ∷ (CZ-gen ₛ ₛ) ∷ xs , at-head ((PB.axiom (cong↑ comm-H))))
  -- step-swap ((CZ-gen ₛ ₛ) ∷ (H-gen) ∷ xs) = just ((H-gen) ∷ (CZ-gen ₛ ₛ) ∷ xs , at-head (PB.axiom comm-H))
  -- step-swap ((CZ-gen ₛ ₛ) ∷ (S-gen ₛ) ∷ xs) = just ((S-gen ₛ) ∷ (CZ-gen ₛ ₛ) ∷ xs , at-head ((PB.axiom (cong↑ comm-S))))
  -- step-swap ((CZ-gen ₛ ₛ) ∷ (S-gen) ∷ xs) = just ((S-gen) ∷ (CZ-gen ₛ ₛ) ∷ xs , at-head (PB.axiom comm-S))

  -- step-swap ((CZ-gen ₛ ₛ) ∷ (CZ-gen) ∷ xs) = just ((CZ-gen) ∷ (CZ-gen ₛ ₛ) ∷ xs , at-head ((PB.axiom comm-CZ)))
  -- step-swap ((CZ-gen ₛ) ∷ (CZ-gen) ∷ xs) = just ((CZ-gen) ∷ (CZ-gen ₛ) ∷ xs , at-head ((PB.axiom selinger-c12)))

  -- step-swap ((S-gen) ∷ (H-gen) ∷ (H-gen) ∷ xs) = just ((H-gen) ∷ (H-gen) ∷ (S-gen) ∷ xs , at-head (PB.sym (PB.axiom comm-HHS)))
  -- step-swap ((S-gen ₛ) ∷ (H-gen ₛ) ∷ (H-gen ₛ) ∷ xs) = just ((H-gen ₛ) ∷ (H-gen ₛ) ∷ (S-gen ₛ) ∷ xs , at-head (PB.sym (PB.axiom (cong↑ comm-HHS))))
  -- step-swap ((S-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ xs) = just ((H-gen ₛ ₛ) ∷ (H-gen ₛ ₛ) ∷ (S-gen ₛ ₛ) ∷ xs , at-head (PB.sym (PB.axiom (cong↑ (cong↑ comm-HHS)))))

  -- Others.
  -- step-swap ((CZ-gen) ∷ (H-gen) ∷ (H-gen) ∷ xs) = just ((H-gen) ∷ (H-gen) ∷ (CZ-gen) ∷ (CZ-gen) ∷ xs , at-head (PB.axiom semi-CZ-HH↓))
  -- step-swap ((CZ-gen) ∷ (H-gen ₛ) ∷ (H-gen ₛ) ∷ xs) = just ((H-gen ₛ) ∷ (H-gen ₛ) ∷ (CZ-gen) ∷ (CZ-gen) ∷ xs , at-head (PB.axiom semi-CZ-HH↑))

  -- step-swap ((CZ-gen) ∷ (H-gen) ∷ (CZ-gen) ∷ xs) = just ((S-gen) ∷ (S-gen) ∷ H-gen ∷ (S-gen) ∷ (S-gen) ∷ CZ-gen ∷ H-gen ∷ S-gen ∷ S-gen ∷ S-gen ₛ ∷ S-gen ₛ ∷ xs , at-head (PB.axiom selinger-c11 ))
  -- step-swap ((CZ-gen ₛ) ∷ (H-gen ₛ) ∷ (CZ-gen ₛ) ∷ xs) = just ((S-gen ₛ) ∷ (S-gen ₛ) ∷ H-gen ₛ ∷ (S-gen ₛ) ∷ (S-gen ₛ) ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ S-gen ₛ ∷ S-gen ₛ ∷ S-gen ₛ ₛ ∷ S-gen ₛ ₛ ∷ xs , at-head (PB.axiom (cong↑ selinger-c11 )))
  -- step-swap ((CZ-gen) ∷ (H-gen ₛ) ∷ (CZ-gen) ∷ xs) = just ((S-gen ₛ) ∷ (S-gen ₛ) ∷ H-gen ₛ ∷ (S-gen ₛ) ∷ (S-gen ₛ) ∷ CZ-gen ∷ H-gen ₛ ∷ S-gen ₛ ∷ S-gen ₛ ∷ S-gen ∷ S-gen ∷ xs , at-head (PB.axiom selinger-c10 ))
  -- step-swap ((CZ-gen ₛ) ∷ (H-gen ₛ ₛ) ∷ (CZ-gen ₛ) ∷ xs) = just ((S-gen ₛ ₛ) ∷ (S-gen ₛ ₛ) ∷ H-gen ₛ ₛ ∷ (S-gen ₛ ₛ) ∷ (S-gen ₛ ₛ) ∷ CZ-gen ₛ ∷ H-gen ₛ ₛ ∷ S-gen ₛ ₛ ∷ S-gen ₛ ₛ ∷ S-gen ₛ ∷ S-gen ₛ ∷ xs , at-head (PB.axiom (cong↑ selinger-c10 )))


  step-swap (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ xs) = just (CZ-gen ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs , at-head (PB.sym (lemma-comm-Ex-CZ)))
  step-swap (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ xs) = just (CZ-gen ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs , at-head (PB.sym ( (lemma-cong↑ _ _ lemma-comm-Ex-CZ))))

  step-swap (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ H-gen ∷ xs) = just (H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs , at-head (PB.sym (lemma-comm-Ex-H)))
  step-swap (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ H-gen ₛ ∷ xs) = just (H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs , at-head (PB.sym ( (lemma-cong↑ _ _ lemma-comm-Ex-H))))

  step-swap (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ S-gen ∷ xs) = just (S-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs , at-head (PB.sym (lemma-comm-Ex-S)))
  step-swap (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ S-gen ₛ ∷ xs) = just (S-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs , at-head (PB.sym ( (lemma-cong↑ _ _ lemma-comm-Ex-S))))

  step-swap {suc n} (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ S-gen ₛ ∷ xs) = just (S-gen ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs , at-head (((lemma-Ex-S↑ {n}))))
  step-swap (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ S-gen ₛ ₛ ∷ xs) = just (S-gen ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs , at-head (lemma-cong↑ _ _ lemma-Ex-S↑))

  step-swap {suc n} (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ H-gen ₛ ∷ xs) = just (H-gen ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs , at-head (((lemma-Ex-H↑ {n}))))
  step-swap (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ H-gen ₛ ₛ ∷ xs) = just (H-gen ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs , at-head (lemma-cong↑ _ _ lemma-Ex-H↑))


  -- Trivial commutations.
  step-swap (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ S-gen ₛ ₛ ∷ xs) = just (S-gen ₛ ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs , at-head ( (lemma-comm-Ex-S↑↑)))
  step-swap (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ S-gen ∷ xs) = just (S-gen ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs , at-head ( ( (lemma-comm-Ex↑-S))))
  step-swap (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs) = just (H-gen ₛ ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs , at-head ( (lemma-comm-Ex-H↑↑)))
  step-swap (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ H-gen ∷ xs) = just (H-gen ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs , at-head ( ( (lemma-comm-Ex↑-H))))

  -- Catch-all
  step-swap _ = nothing


module Rewriting-Swap (n : ℕ) where
  open Symplectic
  open Rewriting
  open Swap-Rewriting hiding (n)
  open Rewriting.Step (step-cong (step-swap {n})) renaming (general-rewrite to rewrite-swap) public



module Swap0-Rewriting where

  -- This module provides a complete rewrite system for 1-qubit
  -- Swap0 operators. It is specialized toward relations on qubit 0
  -- (but can also be applied to qubit 1 via duality).
  variable
    n : ℕ

  open Symplectic
  open Rewriting
  open Lemmas0 hiding (n)
  open Lemmas2 hiding (n)
  
  -- ----------------------------------------------------------------------
  -- * Rewrite rules for 1-qubit Swap0 relations
  
  step-swap0 : let open PB ((₁₊ n) QRel,_===_) hiding (_===_) in Step-Function (Gen (₁₊ n))  ((₁₊ n) QRel,_===_)

  step-swap0 (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs) = just (xs , at-head (lemma-order-Ex))
  step-swap0 (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs) = just (xs , at-head ( (lemma-cong↑ _ _ lemma-order-Ex)))


  step-swap0 (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ xs) = just (CZ-gen ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs , at-head (PB.sym (lemma-comm-Ex-CZ)))
  step-swap0 (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ xs) = just (CZ-gen ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs , at-head (PB.sym ( (lemma-cong↑ _ _ lemma-comm-Ex-CZ))))

  step-swap0 (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ H-gen ∷ xs) = just (H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs , at-head (PB.sym (lemma-comm-Ex-H)))
  step-swap0 (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ H-gen ₛ ∷ xs) = just (H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs , at-head (PB.sym ( (lemma-cong↑ _ _ lemma-comm-Ex-H))))

  step-swap0 (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ S-gen ∷ xs) = just (S-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs , at-head (PB.sym (lemma-comm-Ex-S)))
  step-swap0 (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ S-gen ₛ ∷ xs) = just (S-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs , at-head (PB.sym ( (lemma-cong↑ _ _ lemma-comm-Ex-S))))

  step-swap0 {suc n} (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ S-gen ₛ ∷ xs) = just (S-gen ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs , at-head (((lemma-Ex-S↑ {n}))))
  step-swap0 (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ S-gen ₛ ₛ ∷ xs) = just (S-gen ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs , at-head (lemma-cong↑ _ _ lemma-Ex-S↑))

  step-swap0 {suc n} (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ H-gen ₛ ∷ xs) = just (H-gen ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs , at-head (((lemma-Ex-H↑ {n}))))
  step-swap0 (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ H-gen ₛ ₛ ∷ xs) = just (H-gen ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs , at-head (lemma-cong↑ _ _ lemma-Ex-H↑))


  -- Trivial commutations.
  step-swap0 (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ S-gen ₛ ₛ ∷ xs) = just (S-gen ₛ ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs , at-head ( (lemma-comm-Ex-S↑↑)))
  step-swap0 (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ S-gen ∷ xs) = just (S-gen ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs , at-head ( ( (lemma-comm-Ex↑-S))))
  step-swap0 (CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs) = just (H-gen ₛ ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ CZ-gen ∷ H-gen ∷ H-gen ₛ ∷ xs , at-head ( (lemma-comm-Ex-H↑↑)))
  step-swap0 (CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ H-gen ∷ xs) = just (H-gen ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ CZ-gen ₛ ∷ H-gen ₛ ∷ H-gen ₛ ₛ ∷ xs , at-head ( ( (lemma-comm-Ex↑-H))))

  -- Catch-all
  step-swap0 _ = nothing


module Rewriting-Swap0 (n : ℕ) where
  open Symplectic
  open Rewriting
  open Swap0-Rewriting hiding (n)
  open Rewriting.Step (step-cong (step-swap0 {n})) renaming (general-rewrite to rewrite-swap0) public


module Lemmas3 where
  variable
    n : ℕ

  open Symplectic
  open import Zp.ModularArithmetic
  open Rewriting-Symplectic
  open Rewriting


  lemma-comm-Ex-w↑↑ : ∀ {n} w → let open PB ((₂₊ n) QRel,_===_) in
    
    Ex • w ↑ ↑ ≈ w ↑ ↑ • Ex
    
  lemma-comm-Ex-w↑↑ {n} [ H-gen ↑] = rewrite-sym (suc n) 1000 auto
  lemma-comm-Ex-w↑↑ {n} [ S-gen ↑] = rewrite-sym (suc n) 1000 auto
  lemma-comm-Ex-w↑↑ {n} [ CZ-gen ↑] = rewrite-sym (suc n) 1000 auto
  lemma-comm-Ex-w↑↑ {n} [ x ₛ ↑] = begin
    (CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • (([ x ₛ ↑] ↑) ↑) ≈⟨ by-assoc auto ⟩
    (CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓) • H ↑ • [ x ₛ ↑] ↑ ↑ ≈⟨ cong refl (sym (axiom (cong↑ comm-H))) ⟩
    (CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓) • [ x ₛ ↑] ↑ ↑ • H ↑ ≈⟨ by-assoc auto ⟩
    ((CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ) • H ↓ • [ x ₛ ↑] ↑ ↑) • H ↑ ≈⟨ cong (cong refl (sym (axiom comm-H))) refl ⟩
    ((CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ) • [ x ₛ ↑] ↑ ↑ • H ↓) • H ↑ ≈⟨ by-assoc auto ⟩
    ((CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • CZ • [ x ₛ ↑] ↑ ↑) • (H ↓ • H ↑) ≈⟨ cong (cong refl (sym (axiom comm-CZ))) refl ⟩
    ((CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) • [ x ₛ ↑] ↑ ↑ • CZ) • (H ↓ • H ↑) ≈⟨ by-assoc auto ⟩
    ((CZ • H ↓ • H ↑ • CZ • H ↓) • H ↑ • [ x ₛ ↑] ↑ ↑) • (CZ • H ↓ • H ↑) ≈⟨ cong (cong refl (sym (axiom (cong↑ comm-H)))) refl ⟩
    ((CZ • H ↓ • H ↑ • CZ • H ↓) • [ x ₛ ↑] ↑ ↑ • H ↑) • (CZ • H ↓ • H ↑) ≈⟨ by-assoc auto ⟩
    ((CZ • H ↓ • H ↑ • CZ) • H ↓ • [ x ₛ ↑] ↑ ↑) • (H ↑ • CZ • H ↓ • H ↑) ≈⟨ cong (cong refl (sym (axiom comm-H))) refl ⟩
    ((CZ • H ↓ • H ↑ • CZ) • [ x ₛ ↑] ↑ ↑ • H ↓) • (H ↑ • CZ • H ↓ • H ↑) ≈⟨ by-assoc auto ⟩
    ((CZ • H ↓ • H ↑) • CZ • [ x ₛ ↑] ↑ ↑) • (H ↓ • H ↑ • CZ • H ↓ • H ↑) ≈⟨ cong (cong refl (sym (axiom comm-CZ))) refl ⟩
    ((CZ • H ↓ • H ↑) • [ x ₛ ↑] ↑ ↑ • CZ) • (H ↓ • H ↑ • CZ • H ↓ • H ↑) ≈⟨ by-assoc auto ⟩
    ((CZ • H ↓) • H ↑ • [ x ₛ ↑] ↑ ↑) • (CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) ≈⟨ cong (cong refl (sym (axiom (cong↑ comm-H)))) refl ⟩
    ((CZ • H ↓) • [ x ₛ ↑] ↑ ↑ • H ↑) • (CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) ≈⟨ by-assoc auto ⟩
    (CZ • H ↓ • [ x ₛ ↑] ↑ ↑) • (H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) ≈⟨ cong (cong refl (sym (axiom comm-H))) refl ⟩
    (CZ • [ x ₛ ↑] ↑ ↑ • H ↓) • (H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) ≈⟨ by-assoc auto ⟩
    (CZ • [ x ₛ ↑] ↑ ↑) • (H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) ≈⟨ cong ( (sym (axiom comm-CZ))) refl ⟩
    ([ x ₛ ↑] ↑ ↑ • CZ) • (H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) ≈⟨ by-assoc auto ⟩
    [ x ₛ ↑] ↑ ↑ • (CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑ • CZ • H ↓ • H ↑) ≈⟨ refl ⟩
    (([ x ₛ ↑] ↑) ↑) • Ex ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid
  lemma-comm-Ex-w↑↑ {n} ε = PB.trans PB.right-unit (PB.sym PB.left-unit)
  lemma-comm-Ex-w↑↑ {n} (w • v) = begin
    Ex • (((w • v) ↑) ↑) ≈⟨ refl ⟩
    Ex • w ↑ ↑ • v ↑ ↑ ≈⟨ sym assoc ⟩
    (Ex • w ↑ ↑) • v ↑ ↑ ≈⟨ cong (lemma-comm-Ex-w↑↑ w) refl ⟩
    (w ↑ ↑ • Ex) • v ↑ ↑ ≈⟨ assoc ⟩
    w ↑ ↑ • Ex • v ↑ ↑ ≈⟨ cong refl (lemma-comm-Ex-w↑↑ v) ⟩
    w ↑ ↑ • v ↑ ↑ • Ex ≈⟨ sym assoc ⟩
    (((w • v) ↑) ↑) • Ex ∎
    where
    open PB ((₂₊ n) QRel,_===_)
    open PP ((₂₊ n) QRel,_===_)
    open SR word-setoid



-}



