{-# OPTIONS  --safe #-}
{-# OPTIONS  --call-by-name #-}
--{-# OPTIONS --termination-depth=2 #-}
open import Level using (0ℓ)

open import Relation.Binary using (Rel)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Binary.Morphism.Definitions using (Homomorphic₂)
open import Relation.Binary.PropositionalEquality using (_≡_ ; _≢_ ; inspect ; setoid ; module ≡-Reasoning ; _≗_) renaming ([_] to [_]')
import Relation.Binary.Reasoning.Setoid as SR
import Relation.Binary.PropositionalEquality as Eq
open import Relation.Nullary.Decidable using (yes ; no)


open import Function using (_∘_ ; id)
open import Function.Definitions using (Injective)

open import Data.Product using (_×_ ; _,_ ; proj₁ ; proj₂ ; map₁ ; ∃ ; Σ ; Σ-syntax)
open import Data.Product.Relation.Binary.Pointwise.NonDependent as PW using (≡×≡⇒≡ ; Pointwise ; ≡⇒≡×≡)
open import Data.Nat hiding (_^_ ; _+_ ; _*_)
open import Agda.Builtin.Nat using (_-_)
import Data.Nat as Nat
open import Data.Bool hiding (_<_ ; _≤_)
open import Data.List hiding ([_] ; _++_ ; last ; head ; tail ; _∷ʳ_)
open import Data.Vec hiding ([_])
import Data.Vec as Vec
open import Data.Fin hiding (_+_ ; _-_ ; _≤_ ; _<_)

open import Data.Maybe
open import Data.Sum using (_⊎_ ; inj₁ ; inj₂ ; [_,_] ; [_,_]′)
open import Data.Unit using (⊤ ; tt)
open import Data.Empty using (⊥ ; ⊥-elim)

open import Word.Base as WB hiding (wfoldl ; _* ; _^'_)
open import Word.Properties
import Presentation.Base as PB
import Presentation.Properties as PP
open PP using (NFProperty ; NFProperty')
import Presentation.CosetNF as CA
import Presentation.Reidemeister-Schreier as RS
module RSF = RS.Star-Injective-Full.Reidemeister-Schreier-Full

open import Presentation.Construct.Base hiding (_*_ ; _⊕_)
import Presentation.Construct.Properties.SemiDirectProduct2 as SDP2
import Presentation.Construct.Properties.DirectProduct as DP
import Presentation.Groups.Cyclic as Cyclic


open import Data.Fin using (Fin ; toℕ ; suc ; zero ; fromℕ)
open import Data.Fin.Properties using (suc-injective ; toℕ-inject₁ ; toℕ-fromℕ)
import Data.Nat.Properties as NP
open import Presentation.GroupLike
open import Presentation.Tactics hiding ([_])
open import Data.Nat.Primality



module N.LM-Sym (p-2 : ℕ) (p-prime : Prime (2+ p-2))  where

pattern auto = Eq.refl

pattern ₀ = zero
pattern ₁ = suc ₀
pattern ₂ = suc ₁
pattern ₃ = suc ₂
pattern ₅ = 5
pattern ₆ = 6
pattern ₇ = 7
pattern ₈ = 8
pattern ₉ = 9
pattern ₁₀ = 10
pattern ₁₁ = 11
pattern ₁₂ = 12
pattern ₁₃ = 13
pattern ₁₄ = 14
pattern ₁₅ = 15

pattern ₁₊ ⱼ = suc ⱼ
pattern ₂₊ ⱼ = suc (suc ⱼ)
pattern ₃₊ ⱼ = suc (suc (suc ⱼ))
pattern ₄₊ ⱼ = suc (suc (suc (suc ⱼ)))


open import Zp.ModularArithmetic
open PrimeModulus p-2 p-prime
open import N.Cosets p-2 p-prime
open import N.Symplectic p-2 p-prime
open Symplectic renaming (M to ZM)
open import N.NF1-Sym p-2 p-prime
open import N.Boxes p-2 p-prime public


open import N.NF2-Sym p-2 p-prime
open LM2

private
  variable
    n : ℕ


-- A box is MC.
[_]ᵃ : ∀ {n} → A → Word (Gen (₁₊ n))
[_]ᵃ {n} ((₀ , ₀), pr) = ⊥-elim (pr auto)
[_]ᵃ {n} ((₀ , b@(₁₊ b-1)), pr) = ⟦ (b , λ ()) ⁻¹ , ε ⟧ₘ₊
[_]ᵃ {n} ((a@(₁₊ a-1) , b), pr) = ⟦ (a , λ ()) ⁻¹ , HS^ -b/a ⟧ₘ₊
  where
  a⁻¹ = ((a , λ ()) ⁻¹) .proj₁
  -b/a = - b * a⁻¹

{- old
[_]ᵇ : ∀ {n} → B → Word (Gen (₂₊ n))
[_]ᵇ {n} (₀ , ₀) = Ex
[_]ᵇ {n} (a@₀ , b@(₁₊ b-1)) = Ex • CX • [ (a , b) , (λ ()) ]ᵃ ↑
[_]ᵇ {n} (a@(₁₊ a-1) , b) = Ex • CX • [ (a , b) , (λ ()) ]ᵃ ↑
-}

[_]ᵇ : ∀ {n} → B → Word (Gen (₂₊ n))
[_]ᵇ {n} (₀ , b) = Ex • CX'^ b
[_]ᵇ {n} (a@(₁₊ a-1) , b) = Ex • CX'^ a • H ↑ • S^ -b/a ↑
  where
  a⁻¹ = ((a , λ ()) ⁻¹) .proj₁
  -b/a = - b * a⁻¹


-- B'_ab sends (X^-1 Z^0, X^a Z^b) to (X^-1 Z^ab , I).
B' = B
[_]ᵇ' : ∀ {n} → B' → Word (Gen (₂₊ n))
[_]ᵇ' {n} (a , b) = CZ^ a • H • CZ^ b

{- old
[_]ᵈ : ∀ {n} → D → Word (Gen (₂₊ n))
[_]ᵈ {n} (₀ , ₀) = Ex
[_]ᵈ {n} (a@₀ , b@(₁₊ _)) = Ex • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ
[_]ᵈ {n} (a@(₁₊ _) , b) = Ex • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ
-}

[_]ᵈ : ∀ {n} → D → Word (Gen (₂₊ n))
[_]ᵈ {n} (₀ , b) = Ex • CZ^ (- b)
[_]ᵈ {n} (a@(₁₊ _) , b) = Ex • CZ^ (- a) • H • S^ -b/a
  where
  a⁻¹ = ((a , λ ()) ⁻¹) .proj₁
  -b/a = - b * a⁻¹

{- old
[_]ᵈ' : ∀ {n} → D → Word (Gen (₂₊ n))
[_]ᵈ' {n} (₀ , ₀) = Ex
[_]ᵈ' {n} (a@₀ , b@(₁₊ _)) = CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ ↑ • Ex
[_]ᵈ' {n} (a@(₁₊ _) , b) = CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ ↑ • Ex
-}

[_]ᵈ' : ∀ {n} → D → Word (Gen (₂₊ n))
[_]ᵈ' {n} (₀ , b) = CZ^ (- b) • Ex
[_]ᵈ' {n} (a@(₁₊ _) , b) = CZ^ (- a) • H ↑ • S^ -b/a ↑ • Ex
  where
  a⁻¹ = ((a , λ ()) ⁻¹) .proj₁
  -b/a = - b * a⁻¹

[_]ᵉ : ∀ {n} → E → Word (Gen (₁₊ n))
[_]ᵉ {n} b = S^ (- b)

[_]ᵛᵇ : ∀ {n} → Vec B n → Word (Gen (₁₊ n))
[_]ᵛᵇ {₀} [] = ε
[_]ᵛᵇ {suc n} (x ∷ v) = [ v ]ᵛᵇ ↑ • [ x ]ᵇ

[_]ᵛᵈ : ∀ {n} → Vec D n → Word (Gen (₁₊ n))
[_]ᵛᵈ {₀} [] = ε
[_]ᵛᵈ {suc n} (x ∷ v) = [ x ]ᵈ • [ v ]ᵛᵈ ↑

[_]ᵐ : ∀ {n} → M n → Word (Gen n)
[_]ᵐ {0} _ = ε
[_]ᵐ {1} e = [ e ]ᵉ
[_]ᵐ {₂₊ n} (e , vd) = [ e ]ᵉ • [ vd ]ᵛᵈ

jth-abox : ∀ {j n} → j ≤ n → A → Word (Gen (₁₊ n))
jth-abox {₀} {n} _ a = [ a ]ᵃ
jth-abox {₁₊ j} {₁₊ n} (s≤s j≤n) a = jth-abox {j} {n} (j≤n) a ↑


jth-bbox : ∀ {j n} → j ≤ n → B → Word (Gen (₂₊ n))
jth-bbox {₀} {n} _ a = [ a ]ᵇ
jth-bbox {₁₊ j} {₁₊ n} (s≤s j≤n) a = jth-bbox {j} {n} (j≤n) a ↑

jth-dbox : ∀ {j n} → j ≤ n → B → Word (Gen (₂₊ n))
jth-dbox {₀} {n} _ a = [ a ]ᵈ
jth-dbox {₁₊ j} {₁₊ n} (s≤s j≤n) a = jth-dbox {j} {n} (j≤n) a ↑

jth-ebox : ∀ {j n} → j ≤ n → E → Word (Gen (₁₊ n))
jth-ebox {₀} {n} _ a = [ a ]ᵉ
jth-ebox {₁₊ j} {₁₊ n} (s≤s j≤n) a = jth-ebox {j} {n} (j≤n) a ↑

jth-bboxes : ∀ {j n} → j ≤ n → Vec B (n ∸ j) → Word (Gen (₁₊ n))
jth-bboxes {₀} {n} j≤n v = [ v ]ᵛᵇ
jth-bboxes {₁₊ j} {₁₊ n} (s≤s j≤n) (v) = jth-bboxes j≤n v ↑

lemma-jth-bboxes : ∀ {n} (vb : Vec B n) → jth-bboxes (z≤n {n}) vb ≡ [ vb ]ᵛᵇ
lemma-jth-bboxes {₀} vb = auto
lemma-jth-bboxes {₁₊ j} vb = auto

jth-babox : ∀ {j n} → j ≤ n → Vec B (n ∸ j) -> A → Word (Gen (₁₊ n))
jth-babox {₀} {n} j≤n v a = [ v ]ᵛᵇ • jth-abox j≤n a
jth-babox {₁₊ j} {₁₊ n} (s≤s j≤n) v a = jth-babox j≤n v a ↑

[_]ˡ : ∀ {n} → L n → Word (Gen n)
[_]ˡ {0} _ = ε
[_]ˡ {1} a = [ a ]ᵃ
[_]ˡ {₂₊ n} ((j , j≤n) , bs , a) = jth-babox j≤n bs a

[_]ˡ' : ∀ {n} → L' n → Word (Gen n)
[_]ˡ' {0} l = ε
[_]ˡ' {1} l = [ l ]ᵃ
[_]ˡ' {2} l = ε
[_]ˡ' {₃₊ n} (vb , a) = [ vb ]ᵛᵇ • [ a ]ᵃ



[_]ˡᵐ : ∀ {n} → LM n → Word (Gen n)
[_]ˡᵐ {0} _ = ε
[_]ˡᵐ {1} lm1 = ⟦ lm1 ⟧₁
[_]ˡᵐ {2} lm2 = ⟦ lm2 ⟧₂
[_]ˡᵐ {₃₊ n} (inj₁ (m , l)) = [ m ]ᵐ • [ l ]ˡ'
[_]ˡᵐ {₃₊ n} (inj₂ (d , lm)) = [ d ]ᵈ • [ lm ]ˡᵐ ↑

[_] : ∀ {n} → NF n → Word (Gen n)
[_] {0} tt = ε
[_] {₁₊ n} (nf , lm) = [ nf ] ↑ • [ lm ]ˡᵐ


data Cosets2-noEx : Set where
  case-||ₐ : CZPowers -> Postfix -> Cosets2-noEx
  case-|| : CZPowers* -> SPowers -> Postfix -> Cosets2-noEx
  case-| : MC -> NF1 -> Cosets2-noEx
  case-nf1 : NF1 -> Cosets2-noEx

data Cosets3 : Set where
  case-I : D -> Cosets2 -> Cosets3
  case-II : D -> Cosets2-noEx -> B' -> Cosets3

c2-emb : Cosets2-noEx -> Cosets2
c2-emb (case-||ₐ x x₁) = case-||ₐ x x₁
c2-emb (case-|| x x₁ x₂) = case-|| x x₁ x₂
c2-emb (case-| x x₁) = case-| x x₁
c2-emb (case-nf1 x) = case-nf1 x

c1-emb : Cosets1-noε -> Cosets1
c1-emb (HS^ x) = HS^ x

₁* : ℤ* ₚ
₁* = (₁ , λ ())

rm-mc : Cosets2-noEx ->  Cosets2-noEx
rm-mc (case-||ₐ x x₁@(s , mc↑ , mc)) = case-||ₐ x (s , mc↑ , (₁* , ε))
rm-mc (case-|| x x₁ x₂@(s , mc↑ , mc)) = case-|| x x₁ (s , mc↑ , (₁* , ε))
rm-mc (case-| x x₁@(s , mc)) = case-| x ((s , ₁* , ε))
rm-mc (case-nf1 x@(s , mc)) = case-nf1 (s , ₁* , ε)

mc-of : Cosets2-noEx -> MC
mc-of (case-||ₐ x x₁@(s , mc↑ , mc)) = mc
mc-of (case-|| x x₁ x₂@(s , mc↑ , mc)) = mc
mc-of (case-| x x₁@(s , mc)) = mc
mc-of (case-nf1 x@(s , mc)) = mc

-- update a mc such that if it sent P to Z before updating, then it
-- send P to X^-1 after updating. But it may produce extra S's.
update-mc : MC -> SPowers × MC
update-mc (m , ε) = ₀ , (m ⁻¹ , HS^ ₀)
update-mc (m , HS^ k) = k * m ^2 , (m ⁻¹ , ε)

s-of-HM : MC -> SPowers
s-of-HM = proj₁ ∘ update-mc

mc-of-HM : MC -> MC
mc-of-HM = proj₂ ∘ update-mc

-- used in coset updating.
update-mc-in-c2 : Cosets2-noEx ->  Cosets2-noEx
update-mc-in-c2 (case-||ₐ x x₁@(s , mc↑ , mc)) = case-||ₐ x (s + s-of-HM mc , mc↑ , mc-of-HM mc)
update-mc-in-c2 (case-|| x x₁ x₂@(s , mc↑ , mc)) = case-|| x x₁ (s + s-of-HM mc , mc↑ , mc-of-HM mc)
update-mc-in-c2 (case-| x x₁@(s , mc)) = case-| x ((s + s-of-HM mc , mc-of-HM mc))
update-mc-in-c2 (case-nf1 x@(s , mc)) = case-nf1 (s + s-of-HM mc , mc-of-HM mc)

⟦_⟧₃ : Cosets3 -> Word (Gen (₃₊ n))
⟦ case-I d c2 ⟧₃ = [ d ]ᵈ • ⟦ c2 ⟧₂ ↑
⟦ case-II d c2 b ⟧₃ = [ d ]ᵈ • ⟦ c2-emb (rm-mc c2) ⟧₂ ↑ • [ b ]ᵇ • ⟦ mc-of c2 ⟧ₘ₊


LM' : (n : ℕ) → Set
LM' 0 = ⊤
LM' 1 = NF1
LM' 2 = Cosets2
LM' 3 = Cosets3
LM' (₄₊ n) = M (₄₊ n) × L' (₄₊ n) ⊎ D × LM' (₃₊ n) 

[_]ˡᵐ' : ∀ {n} → LM' n → Word (Gen n)
[_]ˡᵐ' {0} _ = ε
[_]ˡᵐ' {1} lm1 = ⟦ lm1 ⟧₁
[_]ˡᵐ' {2} lm2 = ⟦ lm2 ⟧₂
[_]ˡᵐ' {3} lm3 = ⟦ lm3 ⟧₃
[_]ˡᵐ' {₄₊ n} (inj₁ (m , l)) = [ m ]ᵐ • [ l ]ˡ'
[_]ˡᵐ' {₄₊ n} (inj₂ (d , lm)) = [ d ]ᵈ • [ lm ]ˡᵐ' ↑


data BoxType : Set where
  ᵃ : BoxType
  ᵇ : BoxType
  ᵈ : BoxType
  ᵉ : BoxType
  ˡ : BoxType
  ˡ' : BoxType
  ᵐ : BoxType
  ˡᵐ : BoxType
  ᵛᵇ : BoxType
  ᵛᵈ : BoxType
  ⁿᶠ : BoxType

Box : ∀ {n : ℕ} -> BoxType -> Set
Box ᵃ = A
Box ᵇ = B
Box ᵈ = D
Box ᵉ = E
Box {n} ˡ = L n
Box {n} ˡ' = L' n
Box {n} ᵐ = M n
Box {n} ˡᵐ = LM n
Box {n} ᵛᵇ = Vec B n
Box {n} ᵛᵈ = Vec D n
Box {n} ⁿᶠ = NF n

BIndex : BoxType -> Rel ℕ 0ℓ
BIndex ᵃ = _≤_
BIndex ᵉ = _≤_
BIndex ᵇ = _<_
BIndex ᵈ = _<_
BIndex _ = \ _ _ -> ⊤

BWidth : BoxType -> ℕ
BWidth ⁿᶠ = 0
BWidth ˡ = 0
BWidth ˡ' = 0
BWidth ᵐ = 0
BWidth ˡᵐ = 0
BWidth ᵇ = 2
BWidth ᵈ = 2
BWidth _ = 1

-- A unified way to call all box interpretation.
⟦_⟧ : ∀ {j n} (bt : BoxType) -> Box {n} bt -> BIndex bt j n -> Word (Gen (BWidth bt Nat.+ n))
⟦_⟧ {j} {n} ᵃ x j≤n = jth-abox j≤n x
⟦_⟧ {j} {₁₊ n} ᵇ x j<n = jth-bbox j<n x
⟦_⟧ {j} {n} ᵈ x j<n = jth-dbox j<n x
⟦_⟧ {j} {n} ᵉ x j≤n = jth-ebox j≤n x
⟦_⟧ {j} {n} ˡ x j≤n = [ x ]ˡ
⟦_⟧ {j} {n} ˡ' x j≤n = [ x ]ˡ'
⟦_⟧ {j} {n} ᵐ x j≤n = [ x ]ᵐ
⟦_⟧ {j} {n} ˡᵐ x j≤n = [ x ]ˡᵐ
⟦_⟧ {j} {n} ᵛᵇ x j≤n = [ x ]ᵛᵇ
⟦_⟧ {j} {n} ᵛᵈ x j≤n = [ x ]ᵛᵈ
⟦_⟧ {j} {n} ⁿᶠ x j≤n = [ x ]
