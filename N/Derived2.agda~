{-# OPTIONS  --safe #-}
{-# OPTIONS --termination-depth=2 #-}
{-# OPTIONS  --call-by-name #-}

open import Level using (0ℓ)

open import Relation.Binary using (Rel)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Binary.Morphism.Definitions using (Homomorphic₂)
open import Relation.Binary.PropositionalEquality using (_≡_ ; _≢_ ; inspect ; setoid ; module ≡-Reasoning ; _≗_) renaming ([_] to [_]')
import Relation.Binary.Reasoning.Setoid as SR
import Relation.Binary.PropositionalEquality as Eq
open import Relation.Nullary.Decidable using (yes ; no)


open import Function using (_∘_ ; id)
open import Function.Definitions using (Injective)

open import Data.Product using (_×_ ; _,_ ; proj₁ ; proj₂ ; map₁ ; ∃ ; Σ ; Σ-syntax)
open import Data.Product.Relation.Binary.Pointwise.NonDependent as PW using (≡×≡⇒≡ ; Pointwise ; ≡⇒≡×≡)
open import Data.Nat hiding (_^_ ; _+_ ; _*_)
open import Agda.Builtin.Nat using (_-_)
import Data.Nat as Nat
open import Data.Bool hiding (_<_ ; _≤_)
open import Data.List hiding ([_] ; _++_ ; last ; head ; tail ; _∷ʳ_)
open import Data.Vec hiding ([_])
import Data.Vec as Vec
open import Data.Fin hiding (_+_ ; _-_)

open import Data.Maybe
open import Data.Sum using (_⊎_ ; inj₁ ; inj₂ ; [_,_] ; [_,_]′)
open import Data.Unit using (⊤ ; tt)
open import Data.Empty using (⊥ ; ⊥-elim)

open import Word.Base as WB hiding (wfoldl ; _*)
open import Word.Properties
import Presentation.Base as PB
import Presentation.Properties as PP
open PP using (NFProperty ; NFProperty')
import Presentation.CosetNF as CA
import Presentation.Reidemeister-Schreier as RS
module RSF = RS.Star-Injective-Full.Reidemeister-Schreier-Full

open import Presentation.Construct.Base hiding (_*_ ; _⊕_)
import Presentation.Construct.Properties.SemiDirectProduct2 as SDP2
import Presentation.Construct.Properties.DirectProduct as DP
import Presentation.Groups.Cyclic as Cyclic


open import Data.Fin using (Fin ; toℕ ; suc ; zero ; fromℕ)
open import Data.Fin.Properties using (suc-injective ; toℕ-inject₁ ; toℕ-fromℕ)
import Data.Nat.Properties as NP
open import Presentation.GroupLike
open import Presentation.Tactics hiding ([_])
open import Data.Nat.Primality



module N.Derived2 (p-2 : ℕ) (p-prime : Prime (2+ p-2))  where

pattern auto = Eq.refl

pattern ₀ = zero
pattern ₁ = suc ₀
pattern ₂ = suc ₁
pattern ₃ = suc ₂
pattern ₄ = 4
pattern ₅ = 5
pattern ₆ = 6
pattern ₇ = 7
pattern ₈ = 8
pattern ₉ = 9
pattern ₁₀ = 10
pattern ₁₁ = 11
pattern ₁₂ = 12
pattern ₁₃ = 13
pattern ₁₄ = 14
pattern ₁₅ = 15

pattern ₁₊ ⱼ = suc ⱼ
pattern ₂₊ ⱼ = suc (suc ⱼ)
pattern ₃₊ ⱼ = suc (suc (suc ⱼ))


open import Zp.ModularArithmetic
open PrimeModulus p-2 p-prime
open import Zp.Mod-Lemmas p-2 p-prime
open import N.Symplectic p-2 p-prime
open import N.NF2-Sym p-2 p-prime
open import N.NF1-Sym p-2 p-prime

open Normal-Form1

open Symplectic
open Symplectic-GroupLike

private
  variable
    n : ℕ


open import Algebra.Properties.Ring (+-*-ring p-2)

import Data.Fin.Properties  as FP

lemma-nf1*nf1' : let open PB ((₁₊ n) QRel,_===_) in ∀ (s s' x' : ℤ ₚ) (m m' : ℤ* ₚ) -> (neq : s' ≢ ₀) ->
  let
  m'f = m' .proj₁ 
  mf = m .proj₁ 
  y* = m *' m' ⁻¹
  m'⁻¹ = (m' ⁻¹) .proj₁
  y = y* .proj₁
  ss'* : ℤ* ₚ
  ss'* = (s' , neq)
  [ss'*]⁻¹ = (ss'* ⁻¹) .proj₁
  k* = ss'* *' (m' ⁻¹ *' m' ⁻¹)
  k = k* .proj₁
  k⁻¹ = (k* ⁻¹) .proj₁
  -k⁻¹ = - k⁻¹
  -y/k' = ((y* *' k* ⁻¹) *' -'₁)
  -y/k = -y/k' .proj₁
  yy = (mf * mf) * (m'⁻¹ * m'⁻¹)
  in
  
  S^ s • M m • H • ⟦ (s' , m' , HS^ x') ⟧₁ ≈ S^ (s + - [ss'*]⁻¹ * m ^2 ) • M -y/k' • H • S^ (-k⁻¹ + x')

lemma-nf1*nf1' {n} s s' x' m m' neq  = begin
  S^ s • M m • H • ⟦ (s' , m' , HS^ x') ⟧₁ ≈⟨ (cright cright cright sym assoc) ⟩
  S^ s • M m • H • (S^ s' • M m') • H • S^ x' ≈⟨ special-assoc (□ • □ • □ • □) (□ ^ 3 • □) auto ⟩
  (S^ s • M m • H) • (S^ s' • M m') • H • S^ x' ≈⟨ (cright cleft lemma-S^kM (m' .proj₁) s' (m' .proj₂)) ⟩
  (S^ s • M m • H) • (M m' • S^ ((s') * (m' ⁻¹) ^2)) • H • S^ x'  ≈⟨ special-assoc (□ ^ 3 • □ ^ 2 • □) (□ ^ 2 • □ ^ 2 • □ ^ 2) auto ⟩
  (S^ s • M m) • (H • M m') • S^ ((s') * (m' ⁻¹) ^2) • H • S^ x'  ≈⟨ ((cright (cleft semi-HM m'))) ⟩
  (S^ s • M m) • (M (m' ⁻¹) • H) • S^ ((s') * (m' ⁻¹) ^2) • H • S^ x'  ≈⟨ special-assoc (□ ^ 2 • □ ^ 2 • □) (□ • □ ^ 2 • □ ^ 2) auto ⟩
  S^ s • (M m • M (m' ⁻¹)) • H • S^ ((s') * (m' ⁻¹) ^2) • H • S^ x'  ≈⟨ ((cright cleft axiom (M-mul m (m' ⁻¹)))) ⟩
  S^ s • M (m *' m' ⁻¹) • H • S^ ((s') * (m' ⁻¹) ^2) • H • S^ x'  ≈⟨ (cright special-assoc (□ ^ 5) (□ ^ 4 • □) auto) ⟩
  S^ s • (M (m *' m' ⁻¹) • H • S^ ((s') * (m' ⁻¹) ^2) • H) • S^ x'  ≈⟨ (cright cleft derived-7 k y (k* .proj₂) (y* .proj₂)) ⟩
  S^ s • (S^ (-k⁻¹ * (y * y)) • M -y/k' • (H • S^ -k⁻¹)) • S^ x'  ≈⟨ special-assoc (□ • □ ^ 4 • □) (□ ^ 2 • □ • □ • □ ^ 2) auto ⟩
  (S^ s • S^ (-k⁻¹ * (y * y))) • M -y/k' • H • S^ -k⁻¹ • S^ x'  ≈⟨ cong (lemma-S^k+l s (-k⁻¹ * (y * y))) (cright (cright lemma-S^k+l -k⁻¹ x' )) ⟩
  S^ (s + -k⁻¹ * (y * y)) • M -y/k' • H • S^ (-k⁻¹ + x')  ≈⟨ (cleft aux) ⟩
  S^ (s + - [ss'*]⁻¹ * m ^2 ) • M -y/k' • H • S^ (-k⁻¹ + x')  ∎
  where
  open PB ((₁₊ n) QRel,_===_)
  open PP ((₁₊ n) QRel,_===_)
  open SR word-setoid
  open Pattern-Assoc
  open Lemmas0 n
  m'f = m' .proj₁ 
  mf = m .proj₁ 
  y* = m *' m' ⁻¹
  m'⁻¹ = (m' ⁻¹) .proj₁
  y = y* .proj₁
  ss'* : ℤ* ₚ
  ss'* = (s' , neq)
  [ss'*]⁻¹ = (ss'* ⁻¹) .proj₁
  k* = ss'* *' (m' ⁻¹ *' m' ⁻¹)
  k = k* .proj₁
  k⁻¹ = (k* ⁻¹) .proj₁
  -k⁻¹ = - k⁻¹
  -y/k' = ((y* *' k* ⁻¹) *' -'₁)
  -y/k = -y/k' .proj₁
  yy = (mf * mf) * (m'⁻¹ * m'⁻¹)

  aux0 : y * y ≡ yy
  aux0 = Eq.trans (*-assoc mf m'⁻¹ y) (Eq.trans (Eq.cong (mf *_) (Eq.sym (*-assoc m'⁻¹ mf m'⁻¹))) (Eq.trans (Eq.cong (\ xx -> mf * (xx * m'⁻¹)) (*-comm m'⁻¹ mf)) (Eq.trans (Eq.cong (mf *_) (*-assoc mf m'⁻¹ m'⁻¹)) (Eq.sym (*-assoc mf mf (m'⁻¹ * m'⁻¹))))))
  aux : S^ (s + -k⁻¹ * (y * y)) ≈ S^ (s + - [ss'*]⁻¹ * m ^2 )
  aux = begin
    S^ (s + -k⁻¹ * (y * y)) ≈⟨ refl' (Eq.cong S^ (Eq.cong (s +_) auto)) ⟩
    S^ (s + - ((ss'* *' (m' ⁻¹ *' m' ⁻¹)) ⁻¹) .proj₁ * (y * y)) ≈⟨ refl' (Eq.cong S^ (Eq.cong (s +_) (Eq.cong ( _* (y * y)) (Eq.cong -_ (inv-distrib ss'* (m' ⁻¹ *' m' ⁻¹)))))) ⟩
    S^ (s + - ((ss'* ⁻¹ *' (m' ⁻¹ *' m' ⁻¹) ⁻¹)) .proj₁ * (y * y)) ≈⟨ refl' (Eq.cong S^ (Eq.cong (s +_) (Eq.cong ( _* (y * y)) (Eq.cong -_ (Eq.cong ([ss'*]⁻¹ *_) (inv-distrib (m' ⁻¹) (m' ⁻¹))))))) ⟩
    S^ (s + - ((ss'* ⁻¹ *' (m' ⁻¹ ⁻¹ *' m' ⁻¹ ⁻¹))) .proj₁ * (y * y)) ≈⟨ refl' (Eq.cong S^ (Eq.cong (s +_) (Eq.cong ( _* (y * y)) (Eq.cong -_ (Eq.cong ([ss'*]⁻¹ *_) (Eq.cong₂ _*_ (inv-involutive m') (inv-involutive m') )))))) ⟩
    S^ (s + - (([ss'*]⁻¹ * (m' .proj₁ * m' .proj₁)))  * (y * y)) ≈⟨ refl' (Eq.cong S^ (Eq.cong (s +_) (Eq.sym (-‿distribˡ-* ((([ss'*]⁻¹ * (m' .proj₁ * m' .proj₁)))) (y * y))))) ⟩
    S^ (s + - ((([ss'*]⁻¹ * (m'f * m'f))) * (y * y))) ≈⟨ refl' (Eq.cong S^ (Eq.cong (s +_) (Eq.cong -_ (*-assoc [ss'*]⁻¹ (m'f * m'f) (y * y))))) ⟩
    S^ (s + - ([ss'*]⁻¹ * ((m'f * m'f) * (y * y)))) ≈⟨ refl' (Eq.cong S^ (Eq.cong (s +_) (Eq.cong -_  (Eq.cong ([ss'*]⁻¹ *_) (*-comm (m'f * m'f) (y * y)))))) ⟩
    S^ (s + - ([ss'*]⁻¹ * ((y * y) * (m'f * m'f) ))) ≈⟨ refl' (Eq.cong S^ (Eq.cong (s +_) (Eq.cong -_  (Eq.cong ([ss'*]⁻¹ *_) (Eq.cong (_* (m'f * m'f)) aux0))))) ⟩
    S^ (s + - ([ss'*]⁻¹ * (yy * (m'f * m'f) ))) ≈⟨ refl' (Eq.cong S^ (Eq.cong (s +_) (Eq.cong -_  (Eq.cong ([ss'*]⁻¹ *_) (*-assoc (mf * mf) (m'⁻¹ * m'⁻¹) (m'f * m'f)))))) ⟩
    S^ (s + - ([ss'*]⁻¹ * ((mf * mf) * ((m'⁻¹ * m'⁻¹) * (m'f * m'f)) ))) ≈⟨ refl' (Eq.cong S^ (Eq.cong (s +_) (Eq.cong -_  (Eq.cong ([ss'*]⁻¹ *_) (Eq.cong ((mf * mf) *_) (aux-xxxx m')))))) ⟩
    S^ (s + - ([ss'*]⁻¹ * ((mf * mf) * ₁ ))) ≈⟨ refl' (Eq.cong S^ (Eq.cong (s +_) (Eq.cong -_  (Eq.cong ([ss'*]⁻¹ *_) (*-identityʳ (mf * mf)))))) ⟩
    S^ (s + - ([ss'*]⁻¹ * (mf * mf))) ≈⟨ refl' (Eq.cong S^ (Eq.cong (s +_) (-‿distribˡ-* [ss'*]⁻¹ (mf * mf)))) ⟩
    S^ (s + - [ss'*]⁻¹ * m ^2 ) ∎




