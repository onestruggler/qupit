{-# OPTIONS  --safe #-}
{-# OPTIONS  --call-by-name #-}
{-# OPTIONS --termination-depth=4 #-}
open import Level using (0ℓ)

open import Relation.Binary using (Rel)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Binary.Morphism.Definitions using (Homomorphic₂)
open import Relation.Binary.PropositionalEquality using (_≡_ ; _≢_ ; inspect ; setoid ; module ≡-Reasoning ; _≗_) renaming ([_] to [_]')
import Relation.Binary.Reasoning.Setoid as SR
import Relation.Binary.PropositionalEquality as Eq
open import Relation.Nullary.Decidable using (yes ; no)


open import Function using (_∘_ ; id)
open import Function.Definitions using (Injective)

open import Data.Product using (_×_ ; _,_ ; proj₁ ; proj₂ ; map₁ ; ∃ ; Σ ; Σ-syntax)
open import Data.Product.Relation.Binary.Pointwise.NonDependent as PW using (≡×≡⇒≡ ; Pointwise ; ≡⇒≡×≡)
open import Data.Nat hiding (_^_ ; _+_ ; _*_)
open import Agda.Builtin.Nat using (_-_)
import Data.Nat as Nat
open import Data.Bool hiding (_<_ ; _≤_)
--open import Data.List using () hiding ([_] ; _++_ ; last ; head ; tail ; _∷ʳ_)
open import Data.Vec hiding ([_])
open import Data.Vec as V
open import Data.Fin hiding (_+_ ; _-_ ; _≤_ ; _<_)

open import Data.Maybe
open import Data.Sum using (_⊎_ ; inj₁ ; inj₂ ; [_,_] ; [_,_]′)
open import Data.Unit using (⊤ ; tt)
open import Data.Empty using (⊥ ; ⊥-elim)

open import Word.Base as WB hiding (wfoldl ; _* ; _^'_)
open import Word.Properties
import Presentation.Base as PB
import Presentation.Properties as PP
open PP using (NFProperty ; NFProperty')
import Presentation.CosetNF as CA
import Presentation.Reidemeister-Schreier as RS
module RSF = RS.Star-Injective-Full.Reidemeister-Schreier-Full

open import Presentation.Construct.Base hiding (_*_ ; _⊕_)
import Presentation.Construct.Properties.SemiDirectProduct2 as SDP2
import Presentation.Construct.Properties.DirectProduct as DP
import Presentation.Groups.Cyclic as Cyclic


open import Data.Fin using (Fin ; toℕ ; suc ; zero ; fromℕ)
open import Data.Fin.Properties using (suc-injective ; toℕ-inject₁ ; toℕ-fromℕ)
import Data.Nat.Properties as NP
open import Presentation.GroupLike
open import Presentation.Tactics using ()
open import Data.Nat.Primality



module N.Pushing.DS (p-2 : ℕ) (p-prime : Prime (2+ p-2))  where

private
  variable
    n : ℕ
    
pattern auto = Eq.refl

pattern ₀ = zero
pattern ₁ = suc ₀
pattern ₂ = suc ₁
pattern ₃ = suc ₂
pattern ₅ = 5
pattern ₆ = 6
pattern ₇ = 7
pattern ₈ = 8
pattern ₉ = 9
pattern ₁₀ = 10
pattern ₁₁ = 11
pattern ₁₂ = 12
pattern ₁₃ = 13
pattern ₁₄ = 14
pattern ₁₅ = 15

pattern ₁₊ ⱼ = suc ⱼ
pattern ₂₊ ⱼ = suc (suc ⱼ)
pattern ₃₊ ⱼ = suc (suc (suc ⱼ))
pattern ₄₊ ⱼ = suc (suc (suc (suc ⱼ)))


open import Zp.ModularArithmetic
open PrimeModulus p-2 p-prime
open import N.Cosets p-2 p-prime
open import N.Symplectic p-2 p-prime
open Symplectic renaming (M to ZM)
open import N.NF1-Sym p-2 p-prime
open import N.LM-Sym p-2 p-prime

open import N.Action p-2 p-prime
open import N.Action-Lemmas p-2 p-prime
open import Algebra.Properties.Ring (+-*-ring p-2)
open import N.NF2-Sym p-2 p-prime
open LM2


open import Zp.ModularArithmetic
open import N.Lemmas-2Qupit-Sym p-2 p-prime
open import N.NF2-Sym p-2 p-prime
--open Lemmas-2Q 2

open import N.NF1 p-2 p-prime
open import N.Ex-Sym p-2 p-prime
open import N.Ex-Sym1 p-2 p-prime
open import N.Ex-Sym2 p-2 p-prime
open import N.Ex-Sym3 p-2 p-prime
open import N.Ex-Sym4 p-2 p-prime
open import N.Ex-Sym5 p-2 p-prime hiding (module L0)
open import N.Ex-Sym2n p-2 p-prime
open import N.Ex-Sym3n p-2 p-prime

open import N.Lemma-Comm-n p-2 p-prime
open import N.Completeness1-Sym p-2 p-prime renaming (module Completeness to Cp1)
open Lemmas0a
open Lemmas0a1
open Lemmas0b
open Lemmas0c
open Lemmas-Sym
open Duality

open import N.Completeness1-Sym p-2 p-prime renaming (module Completeness to CP1) using ()
open import N.Coset2-Update-Sym p-2 p-prime renaming (module Completeness to CP2) using ()
open import N.Lemmas4-Sym p-2 p-prime
open import N.Pushing.DH p-2 p-prime
open import N.Pushing.AS p-2 p-prime



dir-of-DS : D -> Word (Gen (₁₊ n))
dir-of-DS (₀ , ₀) = S
dir-of-DS (₀ , b@(₁₊ _)) = S^ (b⁻¹ ^2)
  where
  b* : ℤ* ₚ
  b* = (b , λ ())

  b⁻¹ : ℤ* ₚ
  b⁻¹ = b* ⁻¹
dir-of-DS (₁₊ _ , _) = ε

d-of-DS : D -> D
d-of-DS (₀ , ₀) = ₀ , ₀
d-of-DS (₀ , b@(₁₊ _)) = ₀ , b
d-of-DS (a@(₁₊ _) , b) = a , b + - a

aux-DS : let open PB ((₂₊ n) QRel,_===_) in

  ∀ d ->
  let
  d' = d-of-DS d
  w = dir-of-DS d
  in
  [ d ]ᵈ • S ≈ w ↑ • [ d' ]ᵈ

aux-DS {n} d@(₀ , ₀) = lemma-Ex-S

aux-DS {n} d@(a@₀ , b@(₁₊ _)) = claim
  where
  open PB ((₂₊ n) QRel,_===_)  
  open PP ((₂₊ n) QRel,_===_)
  open SR word-setoid
  open Lemmas0 (₁₊ n)
  open Pattern-Assoc
  open Lemmas-2Q n

  b* : ℤ* ₚ
  b* = (b , λ ())
  nz : b ≢ ₀
  nz = λ ()

  b⁻¹ : ℤ* ₚ
  b⁻¹ = b* ⁻¹
  b⁻¹' = b⁻¹ .proj₁

  w = S^ (b⁻¹ ^2)
  d' = (a , b)
  claim : [ d ]ᵈ • S ≈ w ↑ • [ d' ]ᵈ
  claim = begin
    ([ d ]ᵈ • S) ≈⟨ ( trans assoc (cong refl assoc)) ⟩
    (Ex • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ • S) ≈⟨ ( cright cright cleft aux-abox-nzb b nz) ⟩
    (Ex • CZ^ (- ₁) • ⟦ (b , nz) ⁻¹ ⟧ₘ • S) ≈⟨ ( cright cright axiom (semi-MS ((b , nz) ⁻¹))) ⟩
    (Ex • CZ^ (- ₁) • S^ (b⁻¹ ^2) • ⟦ (b , nz) ⁻¹ ⟧ₘ) ≈⟨ ( cright sym assoc) ⟩
    (Ex • (CZ^ (- ₁) • S^ (b⁻¹ ^2)) • ⟦ (b , nz) ⁻¹ ⟧ₘ) ≈⟨ ( cright cleft word-comm (toℕ (- ₁)) (toℕ (b⁻¹ ^2)) (axiom comm-CZ-S↓)) ⟩
    (Ex • (S^ (b⁻¹ ^2) • CZ^ (- ₁)) • ⟦ (b , nz) ⁻¹ ⟧ₘ) ≈⟨ special-assoc (□ • □ ^ 2 • □ ) (□ ^ 2 • □ ^ 2) auto ⟩
    (Ex • S^ (b⁻¹ ^2)) • CZ^ (- ₁) • ⟦ (b , nz) ⁻¹ ⟧ₘ ≈⟨ (cleft lemma-Induction lemma-Ex-S (toℕ (b⁻¹ ^2))) ⟩
    (S ↑ ^ toℕ (b⁻¹ ^2) • Ex) • CZ^ (- ₁) • ⟦ (b , nz) ⁻¹ ⟧ₘ ≈⟨ (cleft cleft refl' (lemma-^-↑ S (toℕ (b⁻¹ ^2)))) ⟩
    ((S  ^ toℕ (b⁻¹ ^2)) ↑ • Ex) • CZ^ (- ₁) • ⟦ (b , nz) ⁻¹ ⟧ₘ ≈⟨ assoc ⟩
    (S  ^ toℕ (b⁻¹ ^2)) ↑ • (Ex • CZ^ (- ₁) • ⟦ (b , nz) ⁻¹ ⟧ₘ) ≈⟨ (cright  sym (aux-dbox-nzb' b nz)) ⟩
    (S^ (b⁻¹ ^2)) ↑ • [ a , b ]ᵈ  ∎

aux-DS {n} d@(a@(₁₊ _) , b) = claim
  where
  a⁻¹ = ((a , λ ()) ⁻¹) .proj₁
  -b/a = - b * a⁻¹
  aux : -b/a + ₁ ≡ - (b + - a) * a⁻¹
  aux = Eq.sym ( begin
    - (b + - a) * a⁻¹ ≡⟨ Eq.cong (_* a⁻¹) (Eq.sym (-‿+-comm b (- a))) ⟩
    (- b + - - a) * a⁻¹ ≡⟨ Eq.cong (\ xx -> (- b + xx) * a⁻¹) (-‿involutive a) ⟩
    (- b + a) * a⁻¹ ≡⟨ *-distribʳ-+ a⁻¹ (- b) a ⟩
    - b * a⁻¹ + a * a⁻¹ ≡⟨ Eq.cong (- b * a⁻¹ +_) (lemma-⁻¹ʳ a {{nztoℕ {y = a} {neq0 = λ ()}}}) ⟩
    - b * a⁻¹ + ₁ ≡⟨ auto ⟩
    -b/a + ₁ ∎
    )
    where
    open ≡-Reasoning

  
  open PB ((₂₊ n) QRel,_===_)  
  open PP ((₂₊ n) QRel,_===_)
  open SR word-setoid
  open Lemmas0 (₁₊ n)
  open Pattern-Assoc

  w = S
  d' = (a , b + - a)
  
  claim : [ d ]ᵈ • S ≈ (ε ↑) • [ d' ]ᵈ
  claim = begin
    ([ d ]ᵈ • S) ≈⟨ ( trans assoc (cong refl assoc)) ⟩
    (Ex • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ • S) ≈⟨ ( cright cright sym refl) ⟩
    (Ex • CZ^ (- ₁) • (ZM ((a , λ ()) ⁻¹) • H • S^ -b/a) • S) ≈⟨ ( cright cright special-assoc (□ ^ 3 • □) (□ ^ 2 • □ ^ 2) auto) ⟩
    (Ex • CZ^ (- ₁) • (ZM ((a , λ ()) ⁻¹) • H) • S^ -b/a • S) ≈⟨ ( cright cright cright lemma-S^k+l -b/a ₁) ⟩
    (Ex • CZ^ (- ₁) • (ZM ((a , λ ()) ⁻¹) • H) • S^ (-b/a + ₁)) ≈⟨ ( (cright cright assoc)) ⟩
    (Ex • CZ^ (- ₁) • ZM ((a , λ ()) ⁻¹) • H • S^ (-b/a + ₁)) ≡⟨ Eq.cong (\ xx -> (Ex • CZ^ (- ₁) • ZM ((a , λ ()) ⁻¹) • H • S^ xx)) aux ⟩
    (Ex • CZ^ (- ₁) • [ (a , (b + - a)) , (λ ()) ]ᵃ) ≈⟨ refl ⟩
    ([ (a , (b + - a)) ]ᵈ) ≈⟨ sym left-unit ⟩
    ε • ([ (a , (b + - a)) ]ᵈ)  ∎



aux-DS↑ : let open PB ((₂₊ n) QRel,_===_) in

  ∀ d -> [ d ]ᵈ • S ↑ ≈ S • [ d ]ᵈ

aux-DS↑ {n} d@(₀ , ₀) = lemma-Ex-Sᵏ↑ 1
aux-DS↑ {n} d@(a@₀ , b@(₁₊ _)) = begin
  [ d ]ᵈ • S ↑ ≈⟨ refl ⟩
  (Ex • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ) • S ↑ ≈⟨ special-assoc (□ ^ 3 • □) (□ ^ 2 • □ ^ 2) auto ⟩
  (Ex • CZ^ (- ₁)) • [ (a , b) , (λ ()) ]ᵃ • S ↑ ≈⟨ (cright aux-AS↑ ((a , b) , (λ ()))) ⟩
  (Ex • CZ^ (- ₁)) • S ↑ • [ (a , b) , (λ ()) ]ᵃ ≈⟨ special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ⟩
  Ex • (CZ^ (- ₁) • S ↑) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ (cright cleft word-comm (toℕ (- ₁)) 1 (axiom comm-CZ-S↑)) ⟩
  Ex • (S ↑ • CZ^ (- ₁)) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ sym (special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ) ⟩
  (Ex • S ↑) • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ (cleft lemma-Ex-Sᵏ↑ 1) ⟩
  (S • Ex) • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ assoc ⟩
  S • [ d ]ᵈ ∎
  where
  
  open PB ((₂₊ n) QRel,_===_)  
  open PP ((₂₊ n) QRel,_===_)
  open SR word-setoid
  open Lemmas0 (₁₊ n)
  open Pattern-Assoc
  
aux-DS↑ {n} d@(a@(₁₊ _) , b) = begin
  [ d ]ᵈ • S ↑ ≈⟨ refl ⟩
  (Ex • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ) • S ↑ ≈⟨ special-assoc (□ ^ 3 • □) (□ ^ 2 • □ ^ 2) auto ⟩
  (Ex • CZ^ (- ₁)) • [ (a , b) , (λ ()) ]ᵃ • S ↑ ≈⟨ (cright aux-AS↑ ((a , b) , (λ ()))) ⟩
  (Ex • CZ^ (- ₁)) • S ↑ • [ (a , b) , (λ ()) ]ᵃ ≈⟨ special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ⟩
  Ex • (CZ^ (- ₁) • S ↑) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ (cright cleft word-comm (toℕ (- ₁)) 1 (axiom comm-CZ-S↑)) ⟩
  Ex • (S ↑ • CZ^ (- ₁)) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ sym (special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ) ⟩
  (Ex • S ↑) • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ (cleft lemma-Ex-Sᵏ↑ 1) ⟩
  (S • Ex) • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ assoc ⟩
  S • [ d ]ᵈ ∎
  where
  
  open PB ((₂₊ n) QRel,_===_)  
  open PP ((₂₊ n) QRel,_===_)
  open SR word-setoid
  open Lemmas0 (₁₊ n)
  open Pattern-Assoc
  
