{-# OPTIONS  --safe #-}
{-# OPTIONS  --call-by-name #-}
{-# OPTIONS --termination-depth=4 #-}
open import Level using (0ℓ)

open import Relation.Binary using (Rel)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Binary.Morphism.Definitions using (Homomorphic₂)
open import Relation.Binary.PropositionalEquality using (_≡_ ; _≢_ ; inspect ; setoid ; module ≡-Reasoning ; _≗_) renaming ([_] to [_]')
import Relation.Binary.Reasoning.Setoid as SR
import Relation.Binary.PropositionalEquality as Eq
open import Relation.Nullary.Decidable using (yes ; no)


open import Function using (_∘_ ; id)
open import Function.Definitions using (Injective)

open import Data.Product using (_×_ ; _,_ ; proj₁ ; proj₂ ; map₁ ; ∃ ; Σ ; Σ-syntax)
open import Data.Product.Relation.Binary.Pointwise.NonDependent as PW using (≡×≡⇒≡ ; Pointwise ; ≡⇒≡×≡)
open import Data.Nat hiding (_^_ ; _+_ ; _*_)
open import Agda.Builtin.Nat using (_-_)
import Data.Nat as Nat
open import Data.Bool hiding (_<_ ; _≤_)
--open import Data.List using () hiding ([_] ; _++_ ; last ; head ; tail ; _∷ʳ_)
open import Data.Vec hiding ([_])
open import Data.Vec as V
open import Data.Fin hiding (_+_ ; _-_ ; _≤_ ; _<_)

open import Data.Maybe
open import Data.Sum using (_⊎_ ; inj₁ ; inj₂ ; [_,_] ; [_,_]′)
open import Data.Unit using (⊤ ; tt)
open import Data.Empty using (⊥ ; ⊥-elim)

open import Word.Base as WB hiding (wfoldl ; _* ; _^'_)
open import Word.Properties
import Presentation.Base as PB
import Presentation.Properties as PP
open PP using (NFProperty ; NFProperty')
import Presentation.CosetNF as CA
import Presentation.Reidemeister-Schreier as RS
module RSF = RS.Star-Injective-Full.Reidemeister-Schreier-Full

open import Presentation.Construct.Base hiding (_*_ ; _⊕_)
import Presentation.Construct.Properties.SemiDirectProduct2 as SDP2
import Presentation.Construct.Properties.DirectProduct as DP
import Presentation.Groups.Cyclic as Cyclic


open import Data.Fin using (Fin ; toℕ ; suc ; zero ; fromℕ)
open import Data.Fin.Properties using (suc-injective ; toℕ-inject₁ ; toℕ-fromℕ)
import Data.Nat.Properties as NP
open import Presentation.GroupLike
open import Presentation.Tactics using ()
open import Data.Nat.Primality



module N.BR.Two.A-CZ (p-2 : ℕ) (p-prime : Prime (2+ p-2)) where

n : ℕ
n = 0
    
pattern auto = Eq.refl

pattern ₀ = zero
pattern ₁ = suc ₀
pattern ₂ = suc ₁
pattern ₃ = suc ₂
pattern ₅ = 5
pattern ₆ = 6
pattern ₇ = 7
pattern ₈ = 8
pattern ₉ = 9
pattern ₁₀ = 10
pattern ₁₁ = 11
pattern ₁₂ = 12
pattern ₁₃ = 13
pattern ₁₄ = 14
pattern ₁₅ = 15

pattern ₁₊ ⱼ = suc ⱼ
pattern ₂₊ ⱼ = suc (suc ⱼ)
pattern ₃₊ ⱼ = suc (suc (suc ⱼ))
pattern ₄₊ ⱼ = suc (suc (suc (suc ⱼ)))


open import Zp.ModularArithmetic
open PrimeModulus p-2 p-prime
open import N.Cosets p-2 p-prime
open import N.Symplectic p-2 p-prime
open Symplectic renaming (M to ZM)
open import N.NF1-Sym p-2 p-prime
open import N.LM-Sym p-2 p-prime

open import N.Action p-2 p-prime
open import N.Action-Lemmas p-2 p-prime
open import Algebra.Properties.Ring (+-*-ring p-2)
open import N.NF2-Sym p-2 p-prime
open LM2


open import Zp.ModularArithmetic
open import N.Lemmas-2Qupit-Sym p-2 p-prime
open import N.NF2-Sym p-2 p-prime
--open Lemmas-2Q 2

open import N.NF1 p-2 p-prime
open import N.Ex-Sym p-2 p-prime
open import N.Ex-Sym1 p-2 p-prime
open import N.Ex-Sym2 p-2 p-prime
open import N.Ex-Sym3 p-2 p-prime
open import N.Ex-Sym4 p-2 p-prime
open import N.Ex-Sym5 p-2 p-prime hiding (module L0)
open import N.Ex-Sym2n p-2 p-prime
open import N.Ex-Sym3n p-2 p-prime

open import N.Lemma-Comm-n p-2 p-prime 0
open import N.Completeness1-Sym p-2 p-prime renaming (module Completeness to Cp1)
open Lemmas0a
open Lemmas0a1
open Lemmas0b
open Lemmas0c
open Lemmas-Sym
open Duality

open import N.Completeness1-Sym p-2 p-prime renaming (module Completeness to CP1) using ()
open import N.Coset2-Update-Sym p-2 p-prime renaming (module Completeness to CP2) using ()
open import N.Lemmas4-Sym p-2 p-prime
open import N.Lemmas-3Q p-2 p-prime
open import N.Pushing.DH p-2 p-prime
open import N.Duality p-2 p-prime
open import N.BR.Calculations p-2 p-prime


open PB ((₂₊ n) QRel,_===_)
open PP ((₂₊ n) QRel,_===_)
open SR word-setoid
open Pattern-Assoc
open Lemmas0 n
module L01 = Lemmas0 1
open Lemmas-2Q n
open Sym0-Rewriting (₁₊ n)
open Rewriting-Swap 1


lemma-A-CZ-1 : ∀ (b*@(b , nzb) : ℤ* ₚ) ->
  let
  b⁻¹ = (b* ⁻¹) .proj₁
  nz = aux-b≠0⇒ab≠0 ₀ b nzb
  in
  
  [ (₀ , b) , nz ]ᵃ ↑ • CZ ≈ CZ^ b⁻¹ • [ (₀ , b) , nz ]ᵃ ↑

lemma-A-CZ-1 b*@(b , nzb) = begin
  [ (₀ , b) , nz ]ᵃ ↑ • CZ ≈⟨ cleft lemma-cong↑ _ _ (aux-abox-nzb b nzb) ⟩
  ⟦ (b , nzb) ⁻¹ ⟧ₘ ↑ • CZ ≈⟨ axiom (semi-M↑CZ ((b , nzb) ⁻¹)) ⟩
  CZ^ b⁻¹ • ⟦ (b , nzb) ⁻¹ ⟧ₘ ↑ ≈⟨ cright sym (lemma-cong↑ _ _ (aux-abox-nzb b nzb)) ⟩
  CZ^ b⁻¹ • [ (₀ , b) , nz ]ᵃ ↑ ∎
  where
  b⁻¹ = (b* ⁻¹) .proj₁
  nz = aux-b≠0⇒ab≠0 ₀ b nzb



lemma-A-CZ-2 : ∀ (a*@(a , nza) : ℤ* ₚ) (b : ℤ ₚ) ->
  let
  a⁻¹ = (a* ⁻¹) .proj₁
  -b/a = - b * a⁻¹
  nz : (a , b) ≢ (₀ , ₀)
  nz = aux-a≠0⇒ab≠0 a b nza
  nz' : (₀ , - a) ≢ (₀ , ₀)
  nz' = aux-b≠0⇒ab≠0 ₀ (- a) ((-' a*) .proj₂)
  in
  
  [ (a , b) , nz ]ᵃ ↑ • CZ ≈ (ZM a* • H • CZ • H ^ 3) • [ a , b ]ᵇ • [ (₀ , - a) , nz' ]ᵃ

lemma-A-CZ-2 a*@(a , nza) b = begin
  [ (a , b) , nz ]ᵃ ↑ • CZ ≈⟨ cleft lemma-cong↑ _ _ (aux-abox-nza a b nza) ⟩
  ⟦ (a , nza) ⁻¹ , HS^ -b/a ⟧ₘ₊ ↑ • CZ ≈⟨ special-assoc (□ ^ 3 • □) (□ ^ 2 • □ ^ 2) auto ⟩
  (ZM (a* ⁻¹) ↑ • H ↑) • S^ -b/a ↑ • CZ ≈⟨ sym (cleft lemma-cong↑ _ _ (semi-HM a*)) ⟩
  (H ↑ • ZM (a*) ↑) • S^ -b/a ↑ • CZ ≈⟨ cleft cright sym (lemma-cong↑ _ _ (aux-MM ((-'₁ *' -' a*) .proj₂) nza (Eq.trans (-1*x≈-x (- a)) (-‿involutive a)))) ⟩
  (H ↑ • ZM (-'₁ *' -' a*) ↑) • S^ -b/a ↑ • CZ ≈⟨ cleft cright sym (axiom (cong↑ (M-mul -'₁ (-' a*)))) ⟩
  (H ↑ • ZM -'₁ ↑ • ZM (-' a*) ↑) • S^ -b/a ↑ • CZ ≈⟨ cong (cright cleft sym (lemma-cong↑ _ _ lemma-HH-M-1)) (sym (aux-comm-CZ-S^k↑ -b/a)) ⟩
  (H ↑ • H ↑ ^ 2 • ZM (-' a*) ↑) • CZ • S^ -b/a ↑ ≈⟨ special-assoc ((□ • □ ^ 2 • □) • □ ^ 2) (□ ^ 3 • □ ^ 2 • □)  auto ⟩
  H ↑ ^ 3 • (ZM (-' a*) ↑ • CZ) • S^ -b/a ↑ ≈⟨ cright cleft cright sym (refl' (Eq.cong CZ^ (lemma-⁻¹ʳ (- a) {{nztoℕ {y = - a} {neq0 = (-' a*) .proj₂}}}))) ⟩
  H ↑ ^ 3 • (ZM (-' a*) ↑ • CZ^ (- a * -a⁻¹)) • S^ -b/a ↑ ≈⟨ cright cleft sym (lemma-CZ^kM↑ (- a) (- a) ((-' a*) .proj₂)) ⟩
  H ↑ ^ 3 • (CZ^ (- a) • ZM (-' a*) ↑) • S^ -b/a ↑ ≈⟨ special-assoc (□ • □ ^ 2 • □) (□ ^ 4) auto ⟩
  H ↑ ^ 3 • CZ^ (- a) • ZM (-' a*) ↑ • S^ -b/a ↑ ≈⟨ cright cright cleft sym (lemma-cong↑ _ _ (aux-MM ((a* *' -'₁) .proj₂) ((-' a*) .proj₂) (Eq.trans (*-comm (a) (- ₁)) (-1*x≈-x a)))) ⟩
  H ↑ ^ 3 • CZ^ (- a) • ZM (a* *' -'₁) ↑ • S^ -b/a ↑ ≈⟨ cright cright cleft sym (axiom (cong↑ (M-mul a* -'₁))) ⟩
  H ↑ ^ 3 • CZ^ (- a) • (⟦ a* ⟧ₘ ↑ • ZM -'₁ ↑) • S^ -b/a ↑ ≈⟨ cright cright assoc ⟩
  H ↑ ^ 3 • CZ^ (- a) • (⟦ a* ⟧ₘ ↑ • ZM -'₁ ↑ • S^ -b/a ↑) ≈⟨ cright cright  cright cleft sym (lemma-cong↑ _ _ lemma-HH-M-1) ⟩
  H ↑ ^ 3 • CZ^ (- a) • (⟦ a* ⟧ₘ ↑ • H ↑ ^ 2 • S^ -b/a ↑) ≈⟨ cright cright sym left-unit ⟩
  H ↑ ^ 3 • CZ^ (- a) • ε • (⟦ a* ⟧ₘ ↑ • H ↑ ^ 2 • S^ -b/a ↑) ≈⟨ cright cright cleft L01.lemma-M1 ⟩
  H ↑ ^ 3 • CZ^ (- a) • ZM (₁ , λ ()) • (⟦ a* ⟧ₘ ↑ • H ↑ ^ 2 • S^ -b/a ↑) ≈⟨ cright cright cleft L01.aux-MM (λ ()) ((-' a* *' (-' a*) ⁻¹) .proj₂) (Eq.sym (lemma-⁻¹ʳ (- a) {{nztoℕ {y = (- a)} {neq0 = ((-' a*) .proj₂)}}})) ⟩
  H ↑ ^ 3 • CZ^ (- a) • ZM (-' a* *' (-' a*) ⁻¹) • (⟦ a* ⟧ₘ ↑ • H ↑ ^ 2 • S^ -b/a ↑) ≈⟨ cright cright cleft sym (axiom (M-mul (-' a*) ((-' a*) ⁻¹))) ⟩
  H ↑ ^ 3 • CZ^ (- a) • (ZM (-' a*) • ⟦ (-' a*) ⁻¹ ⟧ₘ) • (⟦ a* ⟧ₘ ↑ • H ↑ ^ 2 • S^ -b/a ↑) ≈⟨ cright special-assoc (□ • □ ^ 2 • □) (□ ^ 2 • □ ^ 2) auto ⟩
  H ↑ ^ 3 • (CZ^ (- a) • ZM (-' a*) ) • ⟦ (-' a*) ⁻¹ ⟧ₘ • (⟦ a* ⟧ₘ ↑ • H ↑ ^ 2 • S^ -b/a ↑) ≈⟨ cright cleft sym (axiom (semi-M↓CZ (-' a*))) ⟩
  H ↑ ^ 3 • (ZM (-' a*) • CZ) • ⟦ (-' a*) ⁻¹ ⟧ₘ • (⟦ a* ⟧ₘ ↑ • H ↑ ^ 2 • S^ -b/a ↑) ≈⟨ cright cleft cleft L01.aux-MM ((-' a*) .proj₂) ((a* *' -'₁) .proj₂) (Eq.sym (Eq.trans (*-comm (a) (- ₁)) (-1*x≈-x a))) ⟩
  H ↑ ^ 3 • (ZM (a* *' -'₁) • CZ) • ⟦ (-' a*) ⁻¹ ⟧ₘ • (⟦ a* ⟧ₘ ↑ • H ↑ ^ 2 • S^ -b/a ↑) ≈⟨ special-assoc (□ • □ ^ 2 • □) (□ ^ 2 • □ ^ 2) auto ⟩

  (H ↑ ^ 3 • ZM (a* *' -'₁)) • CZ • ⟦ (-' a*) ⁻¹ ⟧ₘ • (⟦ a* ⟧ₘ ↑ • H ↑ ^ 2 • S^ -b/a ↑) ≈⟨ cong (sym (aux-comm-m-w↑ (a* *' -'₁) (H ^ 3))) (cright aux-comm-m-w↑ ((-' a*) ⁻¹) (⟦ a* ⟧ₘ  • H  ^ 2 • S^ -b/a)) ⟩
  (ZM (a* *' -'₁) • H ↑ ^ 3) • CZ • (⟦ a* ⟧ₘ ↑ • H ↑ ^ 2 • S^ -b/a ↑) • ⟦ (-' a*) ⁻¹ ⟧ₘ ≈⟨ special-assoc (□ ^ 2 • □ • □ ^ 3 • □) (□ • □ • □ ^ 2 • □ ^ 3) auto ⟩
  ZM (a* *' -'₁) • H ↑ ^ 3 • (CZ • ⟦ a* ⟧ₘ ↑) • H ↑ ^ 2 • S^ -b/a ↑ • ⟦ (-' a*) ⁻¹ ⟧ₘ ≈⟨ cong (sym (axiom (M-mul a* -'₁))) (special-assoc (□ • □ ^ 2 • □ ^ 2 • □ ^ 2) (□ ^ 2 • □ ^ 2 • □ ^ 3) auto) ⟩
  (ZM a* • ZM -'₁) • (H ↑ ^ 3 • CZ) • (⟦ a* ⟧ₘ ↑ • H ↑) • H ↑ • S^ -b/a ↑ • ⟦ (-' a*) ⁻¹ ⟧ₘ ≈⟨ cong (cright sym L01.lemma-HH-M-1) (cright cleft sym ( lemma-cong↑ _ _ (semi-HM' a*) )) ⟩
  (ZM a* • H • H) • (H ↑ ^ 3 • CZ) • (H ↑ • ⟦ a* ⁻¹ ⟧ₘ ↑) • H ↑ • S^ -b/a ↑ • ⟦ (-' a*) ⁻¹ ⟧ₘ ≈⟨ special-assoc (□ ^ 3 • □ ^ 2 • □ ^ 2 • □ ^ 3) (□ • □ ^ 5 • □ ^ 3 • □) auto ⟩
  ZM a* • (H • H • H ↑ ^ 3 • CZ • H ↑) • ⟦ a* ⁻¹ , HS^ -b/a ⟧ₘ₊ ↑ • ⟦ (- a , (-' a*) .proj₂) ⁻¹ ⟧ₘ ≈⟨ sym (cright cright cleft lemma-cong↑ _ _ (aux-abox-nza a b nza)) ⟩
  ZM a* • (H • H • H ↑ ^ 3 • CZ • H ↑) • [ (a , b) , nz ]ᵃ ↑ • ⟦ (- a , (-' a*) .proj₂) ⁻¹ ⟧ₘ ≈⟨ cright cleft rewrite-swap 100 auto ⟩
  ZM a* • (H • Ex • H ↑ • H ^ 3 • CZ • H • Ex) • [ (a , b) , nz ]ᵃ ↑ • ⟦ (- a , (-' a*) .proj₂) ⁻¹ ⟧ₘ ≈⟨ cright cleft (cright cright sym aux-hEx) ⟩
  ZM a* • (H • Ex • CZ • H ↑ ^ 3 • CX) • [ (a , b) , nz ]ᵃ ↑ • ⟦ (- a , (-' a*) .proj₂) ⁻¹ ⟧ₘ ≈⟨ cright cleft rewrite-swap 100 auto ⟩
  ZM a* • (H • CZ • H ^ 3 • Ex • CX) • [ (a , b) , nz ]ᵃ ↑ • ⟦ (- a , (-' a*) .proj₂) ⁻¹ ⟧ₘ ≈⟨ special-assoc (□ • □ ^ 5 • □ ^ 2 ) (□ ^ 4 • □ ^ 3 • □) auto ⟩
  (ZM a* • H • CZ • H ^ 3) • (Ex • CX • [ (a , b) , nz ]ᵃ ↑) • ⟦ (- a , (-' a*) .proj₂) ⁻¹ ⟧ₘ ≈⟨ cright cong (sym ({!!} a b nza)) (sym (aux-abox-nzb (- a) ((-' a*) .proj₂))) ⟩
  
  (ZM a* • H • CZ • H ^ 3) • [ a , b ]ᵇ • [ (₀ , - a) , nz' ]ᵃ ∎
  where
  a⁻¹ = (a* ⁻¹) .proj₁
  -a⁻¹ = ((-' a*) ⁻¹) .proj₁
  -b/a = - b * a⁻¹
  nz : (a , b) ≢ (₀ , ₀)
  nz = aux-a≠0⇒ab≠0 a b nza
  nz' : (₀ , - a) ≢ (₀ , ₀)
  nz' = aux-b≠0⇒ab≠0 ₀ (- a) ((-' a*) .proj₂)




lemma-A-CZ-1-dual : ∀ (b*@(b , nzb) : ℤ* ₚ) ->
  let
  b⁻¹ = (b* ⁻¹) .proj₁
  nz = aux-b≠0⇒ab≠0 ₀ b nzb
  in
  
  [ (₀ , b) , nz ]ᵃ  • CZ ≈ CZ^ b⁻¹ • [ (₀ , b) , nz ]ᵃ 

lemma-A-CZ-1-dual b*@(b , nzb) = begin
  [ (₀ , b) , nz ]ᵃ  • CZ ≈⟨ cleft (aux-abox-nzb b nzb) ⟩
  ⟦ (b , nzb) ⁻¹ ⟧ₘ  • CZ ≈⟨ axiom (semi-M↓CZ ((b , nzb) ⁻¹)) ⟩
  CZ^ b⁻¹ • ⟦ (b , nzb) ⁻¹ ⟧ₘ  ≈⟨ cright sym ((aux-abox-nzb b nzb)) ⟩
  CZ^ b⁻¹ • [ (₀ , b) , nz ]ᵃ  ∎
  where
  b⁻¹ = (b* ⁻¹) .proj₁
  nz = aux-b≠0⇒ab≠0 ₀ b nzb


