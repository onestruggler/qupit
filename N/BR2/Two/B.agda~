{-# OPTIONS  --safe #-}
{-# OPTIONS  --call-by-name #-}
{-# OPTIONS --termination-depth=4 #-}
open import Level using (0ℓ)

open import Relation.Binary using (Rel)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Binary.Morphism.Definitions using (Homomorphic₂)
open import Relation.Binary.PropositionalEquality using (_≡_ ; _≢_ ; inspect ; setoid ; module ≡-Reasoning ; _≗_) renaming ([_] to [_]')
import Relation.Binary.Reasoning.Setoid as SR
import Relation.Binary.PropositionalEquality as Eq
open import Relation.Nullary.Decidable using (yes ; no)


open import Function using (_∘_ ; id)
open import Function.Definitions using (Injective)

open import Data.Product using (_×_ ; _,_ ; proj₁ ; proj₂ ; map₁ ; ∃ ; Σ ; Σ-syntax)
open import Data.Product.Relation.Binary.Pointwise.NonDependent as PW using (≡×≡⇒≡ ; Pointwise ; ≡⇒≡×≡)
open import Data.Nat hiding (_^_ ; _+_ ; _*_)
open import Agda.Builtin.Nat using (_-_)
import Data.Nat as Nat
open import Data.Bool hiding (_<_ ; _≤_)
--open import Data.List using () hiding ([_] ; _++_ ; last ; head ; tail ; _∷ʳ_)
open import Data.Vec hiding ([_])
open import Data.Vec as V
open import Data.Fin hiding (_+_ ; _-_ ; _≤_ ; _<_)

open import Data.Maybe
open import Data.Sum using (_⊎_ ; inj₁ ; inj₂ ; [_,_] ; [_,_]′)
open import Data.Unit using (⊤ ; tt)
open import Data.Empty using (⊥ ; ⊥-elim)

open import Word.Base as WB hiding (wfoldl ; _* ; _^'_)
open import Word.Properties
import Presentation.Base as PB
import Presentation.Properties as PP
open PP using (NFProperty ; NFProperty')
import Presentation.CosetNF as CA
import Presentation.Reidemeister-Schreier as RS
module RSF = RS.Star-Injective-Full.Reidemeister-Schreier-Full

open import Presentation.Construct.Base hiding (_*_ ; _⊕_)
import Presentation.Construct.Properties.SemiDirectProduct2 as SDP2
import Presentation.Construct.Properties.DirectProduct as DP
import Presentation.Groups.Cyclic as Cyclic


open import Data.Fin using (Fin ; toℕ ; suc ; zero ; fromℕ)
open import Data.Fin.Properties using (suc-injective ; toℕ-inject₁ ; toℕ-fromℕ)
import Data.Nat.Properties as NP
open import Presentation.GroupLike
open import Presentation.Tactics using ()
open import Data.Nat.Primality



module N.BR.Two.D (p-2 : ℕ) (p-prime : Prime (2+ p-2)) where

n : ℕ
n = 0
    
pattern auto = Eq.refl

pattern ₀ = zero
pattern ₁ = suc ₀
pattern ₂ = suc ₁
pattern ₃ = suc ₂
pattern ₅ = 5
pattern ₆ = 6
pattern ₇ = 7
pattern ₈ = 8
pattern ₉ = 9
pattern ₁₀ = 10
pattern ₁₁ = 11
pattern ₁₂ = 12
pattern ₁₃ = 13
pattern ₁₄ = 14
pattern ₁₅ = 15

pattern ₁₊ ⱼ = suc ⱼ
pattern ₂₊ ⱼ = suc (suc ⱼ)
pattern ₃₊ ⱼ = suc (suc (suc ⱼ))
pattern ₄₊ ⱼ = suc (suc (suc (suc ⱼ)))


open import Zp.ModularArithmetic
open import Zp.Mod-Lemmas p-2 p-prime
open PrimeModulus p-2 p-prime
open import N.Cosets p-2 p-prime
open import N.Symplectic p-2 p-prime
open Symplectic renaming (M to ZM)
open import N.NF1-Sym p-2 p-prime
open import N.LM-Sym p-2 p-prime

open import N.Action p-2 p-prime
open import N.Action-Lemmas p-2 p-prime
open import Algebra.Properties.Ring (+-*-ring p-2)
open import N.NF2-Sym p-2 p-prime
open LM2


open import Zp.ModularArithmetic
open import N.Lemmas-2Qupit-Sym p-2 p-prime
open import N.NF2-Sym p-2 p-prime
--open Lemmas-2Q 2

open import N.NF1 p-2 p-prime
open import N.Ex-Sym p-2 p-prime
open import N.Ex-Sym1 p-2 p-prime
open import N.Ex-Sym2 p-2 p-prime
open import N.Ex-Sym3 p-2 p-prime
open import N.Ex-Sym4 p-2 p-prime
open import N.Ex-Sym5 p-2 p-prime hiding (module L0)
open import N.Ex-Sym2n p-2 p-prime
open import N.Ex-Sym3n p-2 p-prime

open import N.Lemma-Comm-n p-2 p-prime 0
open import N.Completeness1-Sym p-2 p-prime renaming (module Completeness to Cp1)
open Lemmas0a
open Lemmas0a1
open Lemmas0b
open Lemmas0c
open Lemmas-Sym
open Duality

open import N.Completeness1-Sym p-2 p-prime renaming (module Completeness to CP1) using ()
open import N.Coset2-Update-Sym p-2 p-prime renaming (module Completeness to CP2) using ()
open import N.Lemmas4-Sym p-2 p-prime
open import N.Lemmas-3Q p-2 p-prime
open import N.Pushing.DH p-2 p-prime
open import N.Duality p-2 p-prime
open import N.BR.Calculations p-2 p-prime
open import N.BR.One.A p-2 p-prime
open import N.BR.TwoQupit p-2 p-prime hiding (n)
open import N.BR.Two.Lemmas p-2 p-prime hiding (n ; module L01)


open PB ((₂₊ n) QRel,_===_)
open PP ((₂₊ n) QRel,_===_)
open SR word-setoid
open Pattern-Assoc
open Lemmas0 n
module L01 = Lemmas0 (₁₊ n)
open Lemmas-2Q n
open Sym0-Rewriting (₁₊ n)
open Rewriting-Swap 1



dir-and-d' : ∀ (d : D) (g : Gen 2) (neq : g ≢ H-gen ↥) -> ℤ ₚ × Word (Gen 1) × D

dir-and-d' d@(a@₀ , b@₀)               H-gen neq = ₀ , H              ,   (₀ , ₀)
dir-and-d' d@(a@₀ , b@(₁₊ _))          H-gen neq = ₀ , ε              ,   (b , ₀)
dir-and-d' d@(a@(₁₊ _) , b@₀)          H-gen neq = ₀ , ε              ,   (₀ , - a)
dir-and-d' d@(a@(₁₊ _) , b@(₁₊ _))     H-gen neq = ₀ , S^ [ab]⁻¹      ,   (b , - a)
  where
  [ab]⁻¹ = (((a , λ ()) *' (b , λ ())) ⁻¹) .proj₁
dir-and-d' d@(a@₀ , b@₀)               S-gen neq = ₀ , S              ,   (₀ , ₀)
dir-and-d' d@(a@₀ , b@(₁₊ _))          S-gen neq = ₀ , S^ b⁻²         ,   (₀ , b)
  where
  b* = (b , λ ())
  b⁻² = ((b* ⁻¹) .proj₁) * ((b* ⁻¹) .proj₁)
dir-and-d' d@(a@(₁₊ _) , b)            S-gen neq = ₀ , ε              ,   (a , b + - a)
dir-and-d' d@(a , b)               (S-gen ↥) neq = ₁ , ε              ,   (a , b)

dir-and-d' d@(a@₀ , b@₀)              CZ-gen neq = a , ZM -'₁         ,   (a , b + - ₁)
dir-and-d' d@(a@₀ , b@₁)              CZ-gen neq = a , ε              ,   (a , b + - ₁)
dir-and-d' d@(a@₀ , b@(₂₊ _))         CZ-gen neq = a , ZM (-' ob*)    ,   (a , b + - ₁)
  where
  b⁻¹ = ((b , λ ()) ⁻¹) .proj₁
  ob* : ℤ* ₚ
  ob* = b⁻¹ + - ₁ , aux4a' (b , (λ ())) (λ ())
dir-and-d' d@(a@(₁₊ _) , b)           CZ-gen neq = a , dir            ,   (a , b + - ₁)
  where  dir = H • S^ (- a) • H ^ 3
dir-and-d' d@(a , b)               (H-gen ↥) neq = ⊥-elim (neq auto)

lemma-D-br : ∀ (d : D) (g : Gen 2) (neq : g ≢ H-gen ↥) -> let (e , dir , d') = dir-and-d' d g neq in

  [ d ]ᵈ • [ g ]ʷ ≈ S^ e ↓ • dir ↑ • [ d' ]ᵈ

lemma-D-br d@(a , b) g@(H-gen ↥) neq = ⊥-elim (neq auto)

lemma-D-br d@(a@(₁₊ _) , b@₀) g@CZ-gen neq = begin
  (Ex • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ) • CZ ≈⟨ special-assoc (□ ^ 3 • □) (□ ^ 2 • □ ^ 2) auto ⟩
  (Ex • CZ^ (- ₁)) • ⟦ (a , λ ()) ⁻¹ , HS^ -b/a ⟧ₘ₊ • CZ ≈⟨ cright special-assoc (□ ^ 3 • □) (□ ^ 2 • □ ^ 2) auto ⟩
  (Ex • CZ^ (- ₁)) • (⟦ (a , λ ()) ⁻¹ ⟧ₘ • H) • S^ -b/a • CZ ≈⟨ cright cong (sym (L01.semi-HM (a , λ ()))) (word-comm (toℕ (-b/a)) 1 (sym (axiom comm-CZ-S↓))) ⟩
  (Ex • CZ^ (- ₁)) • (H • ⟦ (a , λ ()) ⟧ₘ) • CZ • S^ -b/a ≈⟨ cright special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ⟩
  (Ex • CZ^ (- ₁)) • H • (⟦ (a , λ ()) ⟧ₘ • CZ) • S^ -b/a ≈⟨ cright cright cleft axiom (semi-M↓CZ (a , λ ())) ⟩
  (Ex • CZ^ (- ₁)) • H • (CZ^ a • ⟦ (a , λ ()) ⟧ₘ) • S^ -b/a ≈⟨ special-assoc (□ ^ 2 • □ • □ ^ 2 • □) (□ • □ ^ 3 • □ ^ 2) auto ⟩
  Ex • (CZ^ (- ₁) • H • CZ^ a) • ⟦ (a , λ ()) ⟧ₘ • S^ -b/a ≈⟨ cright cleft aux-CZ⁻¹-H-CZ^k a ⟩
  Ex • (H • S^ a ↑ • S^ (- a) • CX^ (- ₁) • S^ a) • ⟦ (a , λ ()) ⟧ₘ • S^ -b/a ≈⟨ special-assoc (□ • □ ^ 5 • □ ^ 2) (□ ^ 2 • □ ^ 3 • □ ^ 2 • □) auto ⟩
  (Ex • H) • (S^ a ↑ • S^ (- a) • CX^ (- ₁)) • (S^ a • ⟦ (a , λ ()) ⟧ₘ) • S^ -b/a ≈⟨ cong (rewrite-swap 100 auto) (cright cleft L01.lemma-S^kM a a (λ ())) ⟩
  (H ↑ • Ex) • (S^ a ↑ • S^ (- a) • CX^ (- ₁)) • (⟦ (a , λ ()) ⟧ₘ • S^ (a * (a⁻¹ * a⁻¹))) • S^ -b/a ≈⟨ cright cright cleft cright refl' (Eq.cong S^ (Eq.trans (Eq.sym (*-assoc a a⁻¹ a⁻¹)) (Eq.trans (Eq.cong (_* a⁻¹) (lemma-⁻¹ʳ a {{nztoℕ {y = a} {neq0 = λ ()}}})) (*-identityˡ a⁻¹)))) ⟩
  (H ↑ • Ex) • (S^ a ↑ • S^ (- a) • CX^ (- ₁)) • (⟦ (a , λ ()) ⟧ₘ • S^ a⁻¹) • S^ -b/a ≈⟨ cright cleft cright cright aux-CX^-CX'^ (- ₁) ⟩
  (H ↑ • Ex) • (S^ a ↑ • S^ (- a) • CX'^ (- ₁)) • (⟦ (a , λ ()) ⟧ₘ • S^ a⁻¹) • S^ -b/a ≈⟨ special-assoc (□ ^ 2 • □ ^ 5 • □ ^ 2 • □) (□ • □ ^ 2 • □ ^ 3 • □ ^ 2 • □ ^ 2) auto ⟩
  H ↑ • (Ex • S^ a ↑) • (S^ (- a) • H ^ 3 • CZ^ (- ₁)) • (H • ⟦ (a , λ ()) ⟧ₘ) • S^ a⁻¹ • S^ -b/a ≈⟨ cright cong (lemma-Ex-S^ᵏ↑ a) (cright cleft L01.semi-HM (a , λ ())) ⟩
  H ↑ • (S^ a • Ex) • (S^ (- a) • H ^ 3 • CZ^ (- ₁)) • (⟦ (a , λ ()) ⁻¹ ⟧ₘ • H) • S^ a⁻¹ • S^ -b/a ≈⟨ cright cright cright cright L01.lemma-S^k+l a⁻¹ -b/a ⟩
  H ↑ • (S^ a • Ex) • (S^ (- a) • H ^ 3 • CZ^ (- ₁)) • (⟦ (a , λ ()) ⁻¹ ⟧ₘ • H) • S^ (a⁻¹ + -b/a) ≈⟨ special-assoc (□ • □ ^ 2 • □ ^ 3 • □) (□ ^ 2 • □ ^ 2 • □ ^ 2 • □) auto ⟩
  (H ↑ • S^ a) • (Ex • S^ (- a)) • (H ^ 3 • CZ^ (- ₁)) • (⟦ (a , λ ()) ⁻¹ ⟧ₘ • H) • S^ (a⁻¹ + -b/a) ≈⟨ cright cong (lemma-Ex-S^ᵏ (- a)) (cright (cright refl' (Eq.cong S^ aux))) ⟩
  (H ↑ • S^ a) • (S^ (- a) ↑ • Ex) • (H ^ 3 • CZ^ (- ₁)) • (⟦ (a , λ ()) ⁻¹ ⟧ₘ • H) • S^ (- (b + - ₁) * a⁻¹) ≈⟨ cright special-assoc (□ ^ 2 • □ ^ 2 • □) (□ • □ ^ 2 • □ ^ 2) auto ⟩
  (H ↑ • S^ a) • S^ (- a) ↑ • (Ex • H ^ 3) • CZ^ (- ₁) • (⟦ (a , λ ()) ⁻¹ ⟧ₘ • H) • S^ (- (b + - ₁) * a⁻¹) ≈⟨ cright cright cleft rewrite-swap 100 auto ⟩
  (H ↑ • S^ a) • S^ (- a) ↑ • (H ↑ ^ 3 • Ex) • CZ^ (- ₁) • (⟦ (a , λ ()) ⁻¹ ⟧ₘ • H) • S^ (- (b + - ₁) * a⁻¹) ≈⟨ cleft sym (lemma-comm-Sᵏ-w↑ (toℕ a) H) ⟩
  (S^ a • H ↑) • S^ (- a) ↑ • (H ↑ ^ 3 • Ex) • CZ^ (- ₁) • (⟦ (a , λ ()) ⁻¹ ⟧ₘ • H) • S^ (- (b + - ₁) * a⁻¹) ≈⟨ special-assoc (□ ^ 2 • □ • □ ^ 2 • □ • □ ^ 2 • □) (□ • □ ^ 3 • □ ^ 5) auto ⟩
  S^ a • (H ↑ • S^ (- a) ↑ • H ↑ ^ 3) • Ex • CZ^ (- ₁) • ⟦ (a , λ ()) ⁻¹ ⟧ₘ • H • S^ (- (b + - ₁) * a⁻¹) ≈⟨ refl ⟩
  S^ a • (H ↑ • S^ (- a) ↑ • H ↑ ^ 3) • [ a , b + - ₁ ]ᵈ ≈⟨ refl ⟩
  S^ e • dir ↑ • [ d' ]ᵈ ∎
  where
  edd = dir-and-d' d g neq
  e = edd .proj₁
  dir = edd .proj₂ .proj₁
  d' = edd .proj₂ .proj₂
  a⁻¹ = ((a , λ ()) ⁻¹) .proj₁
  -b/a = - b * a⁻¹
  aux : a⁻¹ + -b/a ≡ - (b + - ₁) * a⁻¹
  aux = Eq.trans (Eq.cong (_+ -b/a) (Eq.sym (*-identityˡ a⁻¹))) (Eq.trans (Eq.sym (*-distribʳ-+ a⁻¹ ₁ (- b))) (Eq.trans (Eq.cong (_* a⁻¹) (+-comm ₁ (- b))) (Eq.trans (Eq.cong (_* a⁻¹) (Eq.cong (- b +_) (Eq.sym (-‿involutive ₁)))) (Eq.cong (_* a⁻¹) ( (-‿+-comm b (- ₁)))))))


lemma-D-br d@(a@(₁₊ _) , b@(₁₊ _)) g@CZ-gen neq = begin
  (Ex • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ) • CZ ≈⟨ special-assoc (□ ^ 3 • □) (□ ^ 2 • □ ^ 2) auto ⟩
  (Ex • CZ^ (- ₁)) • ⟦ (a , λ ()) ⁻¹ , HS^ -b/a ⟧ₘ₊ • CZ ≈⟨ cright special-assoc (□ ^ 3 • □) (□ ^ 2 • □ ^ 2) auto ⟩
  (Ex • CZ^ (- ₁)) • (⟦ (a , λ ()) ⁻¹ ⟧ₘ • H) • S^ -b/a • CZ ≈⟨ cright cong (sym (L01.semi-HM (a , λ ()))) (word-comm (toℕ (-b/a)) 1 (sym (axiom comm-CZ-S↓))) ⟩
  (Ex • CZ^ (- ₁)) • (H • ⟦ (a , λ ()) ⟧ₘ) • CZ • S^ -b/a ≈⟨ cright special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ⟩
  (Ex • CZ^ (- ₁)) • H • (⟦ (a , λ ()) ⟧ₘ • CZ) • S^ -b/a ≈⟨ cright cright cleft axiom (semi-M↓CZ (a , λ ())) ⟩
  (Ex • CZ^ (- ₁)) • H • (CZ^ a • ⟦ (a , λ ()) ⟧ₘ) • S^ -b/a ≈⟨ special-assoc (□ ^ 2 • □ • □ ^ 2 • □) (□ • □ ^ 3 • □ ^ 2) auto ⟩
  Ex • (CZ^ (- ₁) • H • CZ^ a) • ⟦ (a , λ ()) ⟧ₘ • S^ -b/a ≈⟨ cright cleft aux-CZ⁻¹-H-CZ^k a ⟩
  Ex • (H • S^ a ↑ • S^ (- a) • CX^ (- ₁) • S^ a) • ⟦ (a , λ ()) ⟧ₘ • S^ -b/a ≈⟨ special-assoc (□ • □ ^ 5 • □ ^ 2) (□ ^ 2 • □ ^ 3 • □ ^ 2 • □) auto ⟩
  (Ex • H) • (S^ a ↑ • S^ (- a) • CX^ (- ₁)) • (S^ a • ⟦ (a , λ ()) ⟧ₘ) • S^ -b/a ≈⟨ cong (rewrite-swap 100 auto) (cright cleft L01.lemma-S^kM a a (λ ())) ⟩
  (H ↑ • Ex) • (S^ a ↑ • S^ (- a) • CX^ (- ₁)) • (⟦ (a , λ ()) ⟧ₘ • S^ (a * (a⁻¹ * a⁻¹))) • S^ -b/a ≈⟨ cright cright cleft cright refl' (Eq.cong S^ (Eq.trans (Eq.sym (*-assoc a a⁻¹ a⁻¹)) (Eq.trans (Eq.cong (_* a⁻¹) (lemma-⁻¹ʳ a {{nztoℕ {y = a} {neq0 = λ ()}}})) (*-identityˡ a⁻¹)))) ⟩
  (H ↑ • Ex) • (S^ a ↑ • S^ (- a) • CX^ (- ₁)) • (⟦ (a , λ ()) ⟧ₘ • S^ a⁻¹) • S^ -b/a ≈⟨ cright cleft cright cright aux-CX^-CX'^ (- ₁) ⟩
  (H ↑ • Ex) • (S^ a ↑ • S^ (- a) • CX'^ (- ₁)) • (⟦ (a , λ ()) ⟧ₘ • S^ a⁻¹) • S^ -b/a ≈⟨ special-assoc (□ ^ 2 • □ ^ 5 • □ ^ 2 • □) (□ • □ ^ 2 • □ ^ 3 • □ ^ 2 • □ ^ 2) auto ⟩
  H ↑ • (Ex • S^ a ↑) • (S^ (- a) • H ^ 3 • CZ^ (- ₁)) • (H • ⟦ (a , λ ()) ⟧ₘ) • S^ a⁻¹ • S^ -b/a ≈⟨ cright cong (lemma-Ex-S^ᵏ↑ a) (cright cleft L01.semi-HM (a , λ ())) ⟩
  H ↑ • (S^ a • Ex) • (S^ (- a) • H ^ 3 • CZ^ (- ₁)) • (⟦ (a , λ ()) ⁻¹ ⟧ₘ • H) • S^ a⁻¹ • S^ -b/a ≈⟨ cright cright cright cright L01.lemma-S^k+l a⁻¹ -b/a ⟩
  H ↑ • (S^ a • Ex) • (S^ (- a) • H ^ 3 • CZ^ (- ₁)) • (⟦ (a , λ ()) ⁻¹ ⟧ₘ • H) • S^ (a⁻¹ + -b/a) ≈⟨ special-assoc (□ • □ ^ 2 • □ ^ 3 • □) (□ ^ 2 • □ ^ 2 • □ ^ 2 • □) auto ⟩
  (H ↑ • S^ a) • (Ex • S^ (- a)) • (H ^ 3 • CZ^ (- ₁)) • (⟦ (a , λ ()) ⁻¹ ⟧ₘ • H) • S^ (a⁻¹ + -b/a) ≈⟨ cright cong (lemma-Ex-S^ᵏ (- a)) (cright (cright refl' (Eq.cong S^ aux))) ⟩
  (H ↑ • S^ a) • (S^ (- a) ↑ • Ex) • (H ^ 3 • CZ^ (- ₁)) • (⟦ (a , λ ()) ⁻¹ ⟧ₘ • H) • S^ (- (b + - ₁) * a⁻¹) ≈⟨ cright special-assoc (□ ^ 2 • □ ^ 2 • □) (□ • □ ^ 2 • □ ^ 2) auto ⟩
  (H ↑ • S^ a) • S^ (- a) ↑ • (Ex • H ^ 3) • CZ^ (- ₁) • (⟦ (a , λ ()) ⁻¹ ⟧ₘ • H) • S^ (- (b + - ₁) * a⁻¹) ≈⟨ cright cright cleft rewrite-swap 100 auto ⟩
  (H ↑ • S^ a) • S^ (- a) ↑ • (H ↑ ^ 3 • Ex) • CZ^ (- ₁) • (⟦ (a , λ ()) ⁻¹ ⟧ₘ • H) • S^ (- (b + - ₁) * a⁻¹) ≈⟨ cleft sym (lemma-comm-Sᵏ-w↑ (toℕ a) H) ⟩
  (S^ a • H ↑) • S^ (- a) ↑ • (H ↑ ^ 3 • Ex) • CZ^ (- ₁) • (⟦ (a , λ ()) ⁻¹ ⟧ₘ • H) • S^ (- (b + - ₁) * a⁻¹) ≈⟨ special-assoc (□ ^ 2 • □ • □ ^ 2 • □ • □ ^ 2 • □) (□ • □ ^ 3 • □ ^ 5) auto ⟩
  S^ a • (H ↑ • S^ (- a) ↑ • H ↑ ^ 3) • Ex • CZ^ (- ₁) • ⟦ (a , λ ()) ⁻¹ ⟧ₘ • H • S^ (- (b + - ₁) * a⁻¹) ≈⟨ refl ⟩
  S^ a • (H ↑ • S^ (- a) ↑ • H ↑ ^ 3) • [ a , b + - ₁ ]ᵈ ≈⟨ refl ⟩
  S^ e • dir ↑ • [ d' ]ᵈ ∎
  where
  edd = dir-and-d' d g neq
  e = edd .proj₁
  dir = edd .proj₂ .proj₁
  d' = edd .proj₂ .proj₂
  a⁻¹ = ((a , λ ()) ⁻¹) .proj₁
  -b/a = - b * a⁻¹
  aux : a⁻¹ + -b/a ≡ - (b + - ₁) * a⁻¹
  aux = Eq.trans (Eq.cong (_+ -b/a) (Eq.sym (*-identityˡ a⁻¹))) (Eq.trans (Eq.sym (*-distribʳ-+ a⁻¹ ₁ (- b))) (Eq.trans (Eq.cong (_* a⁻¹) (+-comm ₁ (- b))) (Eq.trans (Eq.cong (_* a⁻¹) (Eq.cong (- b +_) (Eq.sym (-‿involutive ₁)))) (Eq.cong (_* a⁻¹) ( (-‿+-comm b (- ₁)))))))



lemma-D-br d@(a@₀ , b@₀) g@CZ-gen neq = begin
  [ d ]ᵈ • CZ ≈⟨ cong refl (sym left-unit) ⟩
  [ d ]ᵈ • ε • CZ ≈⟨ cright cleft sym (L01.aux-M-mul -'₁) ⟩
  [ d ]ᵈ • (ZM -'₁ • ZM (-'₁ ⁻¹)) • CZ ≈⟨ sym (special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto) ⟩
  ([ d ]ᵈ • ZM -'₁) • ZM (-'₁ ⁻¹) • CZ ≈⟨ cong (lemma-Ex-M -'₁) (axiom (semi-M↓CZ (-'₁ ⁻¹))) ⟩
  (ZM -'₁ ↑ • [ d ]ᵈ ) • CZ^ ((-'₁ ⁻¹) .proj₁) • ZM (-'₁ ⁻¹) ≈⟨ cright cleft refl' (Eq.cong CZ^ aux-₁⁻¹) ⟩
  (ZM -'₁ ↑ • [ d ]ᵈ ) • CZ^ (- ₁) • ZM (-'₁ ⁻¹) ≈⟨ assoc ⟩
  ZM -'₁ ↑ • [ d ]ᵈ  • CZ^ (- ₁) • ZM (-'₁ ⁻¹) ≈⟨ cright sym (aux-dbox-nzb' (- ₁) ((-' (₁ , λ ())) .proj₂)) ⟩
  ZM -'₁ ↑ • [ ₀ , - ₁ ]ᵈ  ≈⟨ cright refl' (Eq.cong (\ xx -> [ ₀ , xx ]ᵈ) (Eq.sym (+-identityˡ (- ₁)))) ⟩
  ZM -'₁ ↑ • [ ₀ , b + - ₁ ]ᵈ  ≈⟨ sym left-unit ⟩
  S^ e • dir ↑ • [ d' ]ᵈ ∎
  where
  edd = dir-and-d' d g neq
  e = edd .proj₁
  dir = edd .proj₂ .proj₁
  d' = edd .proj₂ .proj₂


lemma-D-br d@(a@₀ , b@₁) g@CZ-gen neq = begin
  [ d ]ᵈ • CZ ≈⟨ cleft aux-dbox-nzb' b (λ ()) ⟩
  (Ex • CZ^ (- ₁) • ⟦ (b , λ ()) ⁻¹ ⟧ₘ) • CZ ≈⟨ special-assoc (□ ^ 3 • □) (□ ^ 2 • □ ^ 2) auto ⟩
  (Ex • CZ^ (- ₁)) • ⟦ (b , λ ()) ⁻¹ ⟧ₘ • CZ ≈⟨ cright axiom (semi-M↓CZ ((b , λ ()) ⁻¹)) ⟩
  (Ex • CZ^ (- ₁)) • CZ^ b⁻¹ • ⟦ (b , λ ()) ⁻¹ ⟧ₘ ≈⟨ cright cright sym right-unit ⟩
  (Ex • CZ^ (- ₁)) • CZ^ b⁻¹ • [ (a , b) , (λ ()) ]ᵃ ≈⟨ special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ⟩
  Ex • (CZ^ (- ₁) • CZ^ b⁻¹) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ cright cleft lemma-CZ^k+l (- ₁) b⁻¹ ⟩
  Ex • CZ^ (- ₁ + b⁻¹) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ cright cleft refl' (Eq.cong CZ^ (Eq.cong (- ₁ +_) aux₁⁻¹')) ⟩
  Ex • CZ^ (- ₁ + ₁) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ cright cleft refl' (Eq.cong CZ^ (+-inverseˡ ₁)) ⟩
  Ex • CZ^ ₀ • [ (a , b) , (λ ()) ]ᵃ ≈⟨ cright left-unit ⟩
  Ex • [ (a , b) , (λ ()) ]ᵃ ≈⟨ cright right-unit ⟩
  Ex • ⟦ (b , λ ()) ⁻¹ ⟧ₘ ≈⟨ lemma-Ex-M ((b , λ ()) ⁻¹) ⟩
  ⟦ (b , λ ()) ⁻¹ ⟧ₘ ↑ • Ex ≈⟨ cleft lemma-cong↑ _ _ (aux-MM (((b , λ ()) ⁻¹) .proj₂) (λ ()) aux₁⁻¹') ⟩
  ⟦ (b , λ ()) ⟧ₘ ↑ • Ex ≈⟨ cleft sym (lemma-cong↑ _ _ lemma-M1) ⟩
  ε ↑ • Ex ≈⟨ left-unit ⟩
  [ a , ₀ ]ᵈ ≈⟨ refl' (Eq.cong (\ xx -> [ a , xx ]ᵈ) (Eq.sym (+-inverseʳ ₁))) ⟩
  [ a , b + - ₁ ]ᵈ ≈⟨ sym (trans left-unit left-unit) ⟩
  S^ e • dir ↑ • [ d' ]ᵈ ∎
  where
  edd = dir-and-d' d g neq
  e = edd .proj₁
  dir = edd .proj₂ .proj₁
  d' = edd .proj₂ .proj₂
  b⁻¹ = ((b , λ ()) ⁻¹) .proj₁


lemma-D-br d@(a@₀ , b@(₂₊ _)) g@CZ-gen neq = begin
  (Ex • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ) • CZ ≈⟨ special-assoc (□ ^ 3 • □) (□ ^ 2 • □ ^ 2) auto ⟩
  (Ex • CZ^ (- ₁)) • ⟦ (b , λ ()) ⁻¹ , ε ⟧ₘ₊ • CZ ≈⟨ cright cleft right-unit ⟩
  (Ex • CZ^ (- ₁)) • ⟦ (b , λ ()) ⁻¹ ⟧ₘ • CZ ≈⟨ cright axiom (semi-M↓CZ ((b , λ ()) ⁻¹)) ⟩
  (Ex • CZ^ (- ₁)) • CZ^ b⁻¹ • ⟦ (b , λ ()) ⁻¹ ⟧ₘ ≈⟨ cright cright sym right-unit ⟩
  (Ex • CZ^ (- ₁)) • CZ^ b⁻¹ • [ (a , b) , (λ ()) ]ᵃ ≈⟨ special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ⟩
  Ex • (CZ^ (- ₁) • CZ^ b⁻¹) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ cright cleft lemma-CZ^k+l (- ₁) b⁻¹ ⟩
  Ex • CZ^ (- ₁ + b⁻¹) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ cright cleft refl' (Eq.cong CZ^ (+-comm (- ₁) b⁻¹)) ⟩
  Ex • CZ^ (b⁻¹ + - ₁) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ cright sym left-unit ⟩
  Ex • ε • CZ^ (b⁻¹ + - ₁) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ cright cleft sym (L01.aux-M-mul (-' ob*)) ⟩
  Ex • (ZM (-' ob*) • ZM ((-' ob*) ⁻¹ )) • CZ^ (b⁻¹ + - ₁) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ cright special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ⟩
  Ex • ZM (-' ob*) • (ZM ((-' ob*) ⁻¹ ) • CZ^ (b⁻¹ + - ₁)) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ cright cright cleft lemma-M↓CZ^k -ob⁻¹ (b⁻¹ + - ₁) (((-' ob*) ⁻¹ ) .proj₂) ⟩
  Ex • ZM (-' ob*) • (CZ^ ((b⁻¹ + - ₁) * -ob⁻¹) • ZM ((-' ob*) ⁻¹ )) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ sym assoc ⟩
  (Ex • ZM (-' ob*)) • (CZ^ ((b⁻¹ + - ₁) * -ob⁻¹) • ZM ((-' ob*) ⁻¹ )) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ cong (lemma-Ex-M (-' ob*)) (cleft cleft refl' (Eq.cong CZ^ aux)) ⟩
  (ZM (-' ob*) ↑ • Ex) • (CZ^ (- ₁) • ZM ((-' ob*) ⁻¹ )) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ cright assoc ⟩
  (ZM (-' ob*) ↑ • Ex) • CZ^ (- ₁) • ZM ((-' ob*) ⁻¹ ) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ cright cright cright right-unit ⟩
  (ZM (-' ob*) ↑ • Ex) • CZ^ (- ₁) • ZM ((-' ob*) ⁻¹ ) • ⟦ (b , λ ()) ⁻¹ ⟧ₘ ≈⟨ cright cright axiom (M-mul ((-' ob*) ⁻¹) ((b , λ ()) ⁻¹)) ⟩
  (ZM (-' ob*) ↑ • Ex) • CZ^ (- ₁) • ZM ((-' ob*) ⁻¹ *' (b , λ ()) ⁻¹) ≈⟨ cright cright L01.aux-MM (((-' ob*) ⁻¹ *' (b , λ ()) ⁻¹) .proj₂) (((-' ob*  *' (b , λ ()) ) ⁻¹) .proj₂) (Eq.sym (inv-distrib (-' ob*) ((b , λ ())))) ⟩
  (ZM (-' ob*) ↑ • Ex) • CZ^ (- ₁) • ZM ((-' ob*  *' (b , λ ()) ) ⁻¹) ≈⟨ cright cright L01.aux-MM (((-' ob*  *' (b , λ ()) ) ⁻¹) .proj₂) ((( b + - ₁ , nz') ⁻¹) .proj₂) (inv-cong ((-' ob*  *' (b , λ ()) )) (( b + - ₁ , nz')) aux2) ⟩
  (ZM (-' ob*) ↑ • Ex) • CZ^ (- ₁) • ZM (( b + - ₁ , nz') ⁻¹) ≈⟨ assoc ⟩
  ZM (-' ob*) ↑ • Ex • CZ^ (- ₁) • ZM (( b + - ₁ , nz') ⁻¹) ≈⟨ cright sym (aux-dbox-nzb' (b + - ₁) nz') ⟩
  ZM (-' ob*) ↑ • [ ₀ , b + - ₁ ]ᵈ ≈⟨ sym left-unit ⟩
  S^ e • dir ↑ • [ d' ]ᵈ ∎
  where
  edd = dir-and-d' d g neq
  e = edd .proj₁
  dir = edd .proj₂ .proj₁
  d' = edd .proj₂ .proj₂
  b⁻¹ = ((b , λ ()) ⁻¹) .proj₁
  nz : b⁻¹ + - ₁ ≢ ₀
  nz = aux4a' (b , (λ ())) (λ ())
  nz' : b + - ₁ ≢ ₀
  nz' = aux4a'' (b , (λ ())) (λ ())
  ob* : ℤ* ₚ
  ob* = b⁻¹ + - ₁ , nz
  -ob⁻¹ = ((-' ob*) ⁻¹ ) .proj₁
  aux : (b⁻¹ + - ₁) * -ob⁻¹ ≡ - ₁
  aux = proj₁ (aux-ob1 (b , λ ()) λ ())
  aux2 : (-' ob*  *' (b , λ ())) .proj₁ ≡ b + - ₁
  aux2 = proj₂ (aux-ob1 (b , λ ()) λ ())



lemma-D-br d@(a@₀ , b@₀) g@(S-gen ↥) neq = begin
  [ d ]ᵈ • S ↑ ≈⟨ lemma-Ex-S↑ ⟩
  S • [ d ]ᵈ ≈⟨ sym (cong refl left-unit) ⟩
  S^ e • dir ↑ • [ d' ]ᵈ ∎
  where
  edd = dir-and-d' d g neq
  e = edd .proj₁
  dir = edd .proj₂ .proj₁
  d' = edd .proj₂ .proj₂


lemma-D-br d@(a@₀ , b@(₁₊ _)) g@(S-gen ↥) neq = begin
  (Ex • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ) • S ↑ ≈⟨ special-assoc (□ ^ 3 • □) (□ ^ 2 • □ ^ 2) auto ⟩
  (Ex • CZ^ (- ₁)) • [ (a , b) , (λ ()) ]ᵃ • S ↑ ≈⟨ cright comm-abox-w↑ ((a , b) , (λ ())) S ⟩
  (Ex • CZ^ (- ₁)) • S ↑ • [ (a , b) , (λ ()) ]ᵃ ≈⟨ special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ⟩
  Ex • (CZ^ (- ₁) • S ↑) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ cright cleft word-comm (toℕ (- 1ₚ)) 1 (axiom comm-CZ-S↑) ⟩
  Ex • (S ↑ • CZ^ (- ₁)) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ sym (special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto) ⟩
  (Ex • S ↑) • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ cleft lemma-Ex-S↑ ⟩
  (S • Ex) • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ assoc ⟩
  S • Ex • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ sym (cong refl left-unit) ⟩
  S^ e • dir ↑ • [ d' ]ᵈ ∎
  where
  edd = dir-and-d' d g neq
  e = edd .proj₁
  dir = edd .proj₂ .proj₁
  d' = edd .proj₂ .proj₂


lemma-D-br d@(a@(₁₊ _) , b@₀) g@(S-gen ↥) neq = begin
  (Ex • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ) • S ↑ ≈⟨ special-assoc (□ ^ 3 • □) (□ ^ 2 • □ ^ 2) auto ⟩
  (Ex • CZ^ (- ₁)) • [ (a , b) , (λ ()) ]ᵃ • S ↑ ≈⟨ cright comm-abox-w↑ ((a , b) , (λ ())) S ⟩
  (Ex • CZ^ (- ₁)) • S ↑ • [ (a , b) , (λ ()) ]ᵃ ≈⟨ special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ⟩
  Ex • (CZ^ (- ₁) • S ↑) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ cright cleft word-comm (toℕ (- 1ₚ)) 1 (axiom comm-CZ-S↑) ⟩
  Ex • (S ↑ • CZ^ (- ₁)) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ sym (special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto) ⟩
  (Ex • S ↑) • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ cleft lemma-Ex-S↑ ⟩
  (S • Ex) • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ assoc ⟩
  S • Ex • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ sym (cong refl left-unit) ⟩
  S^ e • dir ↑ • [ d' ]ᵈ ∎
  where
  edd = dir-and-d' d g neq
  e = edd .proj₁
  dir = edd .proj₂ .proj₁
  d' = edd .proj₂ .proj₂

lemma-D-br d@(a@(₁₊ _) , b@(₁₊ _)) g@(S-gen ↥) neq = begin
  (Ex • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ) • S ↑ ≈⟨ special-assoc (□ ^ 3 • □) (□ ^ 2 • □ ^ 2) auto ⟩
  (Ex • CZ^ (- ₁)) • [ (a , b) , (λ ()) ]ᵃ • S ↑ ≈⟨ cright comm-abox-w↑ ((a , b) , (λ ())) S ⟩
  (Ex • CZ^ (- ₁)) • S ↑ • [ (a , b) , (λ ()) ]ᵃ ≈⟨ special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ⟩
  Ex • (CZ^ (- ₁) • S ↑) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ cright cleft word-comm (toℕ (- 1ₚ)) 1 (axiom comm-CZ-S↑) ⟩
  Ex • (S ↑ • CZ^ (- ₁)) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ sym (special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto) ⟩
  (Ex • S ↑) • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ cleft lemma-Ex-S↑ ⟩
  (S • Ex) • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ assoc ⟩
  S • Ex • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ ≈⟨ sym (cong refl left-unit) ⟩
  S^ e • dir ↑ • [ d' ]ᵈ ∎
  where
  edd = dir-and-d' d g neq
  e = edd .proj₁
  dir = edd .proj₂ .proj₁
  d' = edd .proj₂ .proj₂


lemma-D-br d@(a@₀ , b@₀) g@(S-gen) neq = begin
  [ d ]ᵈ • S ≈⟨ lemma-Ex-S ⟩
  S ↑ • [ d ]ᵈ ≈⟨ sym left-unit ⟩
  S^ e • dir ↑ • [ d' ]ᵈ ∎
  where
  edd = dir-and-d' d g neq
  e = edd .proj₁
  dir = edd .proj₂ .proj₁
  d' = edd .proj₂ .proj₂

lemma-D-br d@(a@₀ , b@(₁₊ _)) g@(S-gen) neq = begin
  (Ex • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ) • S ≈⟨ special-assoc (□ ^ 3 • □) (□ ^ 2 • □ ^ 2) auto ⟩
  (Ex • CZ^ (- ₁)) • [ (a , b) , (λ ()) ]ᵃ • S ≈⟨ cright lemma-single-qupit-br-A 1 ((a , b) , (λ ())) S-gen tt ⟩
  (Ex • CZ^ (- ₁)) • S^ b⁻² • [ (₀ , b) , (λ ()) ]ᵃ ≈⟨ special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ⟩
  Ex • (CZ^ (- ₁) • S^ b⁻²) • [ (₀ , b) , (λ ()) ]ᵃ ≈⟨ cright cleft word-comm (toℕ (- 1ₚ)) (toℕ b⁻²) (axiom comm-CZ-S↓) ⟩
  Ex • (S^ b⁻² • CZ^ (- ₁)) • [ (₀ , b) , (λ ()) ]ᵃ ≈⟨ sym (special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto) ⟩
  (Ex • S^ b⁻²) • CZ^ (- ₁) • [ (₀ , b) , (λ ()) ]ᵃ ≈⟨ cleft lemma-Ex-S^ᵏ b⁻² ⟩
  (S^ b⁻² ↑ • Ex) • CZ^ (- ₁) • [ (₀ , b) , (λ ()) ]ᵃ ≈⟨ assoc ⟩
  S^ b⁻² ↑ • Ex • CZ^ (- ₁) • [ (₀ , b) , (λ ()) ]ᵃ ≈⟨ sym left-unit ⟩
  S^ e • dir ↑ • [ d' ]ᵈ ∎
  where
  edd = dir-and-d' d g neq
  e = edd .proj₁
  dir = edd .proj₂ .proj₁
  d' = edd .proj₂ .proj₂
  b* = (b , λ ())
  b⁻² = ((b* ⁻¹) .proj₁) * ((b* ⁻¹) .proj₁)


lemma-D-br d@(a@(₁₊ _) , b@₀) g@(S-gen) neq = begin
  (Ex • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ) • S ≈⟨ special-assoc (□ ^ 3 • □) (□ ^ 2 • □ ^ 2) auto ⟩
  (Ex • CZ^ (- ₁)) • [ (a , b) , (λ ()) ]ᵃ • S ≈⟨ cright lemma-single-qupit-br-A 1 ((a , b) , (λ ())) S-gen tt ⟩
  (Ex • CZ^ (- ₁)) • ε • [ (a , b + - a) , nz' ]ᵃ ≈⟨ cong refl left-unit ⟩
  (Ex • CZ^ (- ₁)) • [ (a , b + - a) , nz' ]ᵃ ≈⟨ assoc ⟩
  Ex • CZ^ (- ₁) • [ (a , b + - a) , nz' ]ᵃ ≈⟨ refl ⟩
  [ d' ]ᵈ ≈⟨ sym (trans left-unit left-unit) ⟩
  S^ e • dir ↑ • [ d' ]ᵈ ∎
  where
  edd = dir-and-d' d g neq
  e = edd .proj₁
  dir = edd .proj₂ .proj₁
  d' = edd .proj₂ .proj₂
  nz' = aux-a≠0⇒ab≠0 a (b + - a) λ ()

lemma-D-br d@(a@(₁₊ _) , b@(₁₊ _)) g@(S-gen) neq = begin
  (Ex • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ) • S ≈⟨ special-assoc (□ ^ 3 • □) (□ ^ 2 • □ ^ 2) auto ⟩
  (Ex • CZ^ (- ₁)) • [ (a , b) , (λ ()) ]ᵃ • S ≈⟨ cright lemma-single-qupit-br-A 1 ((a , b) , (λ ())) S-gen tt ⟩
  (Ex • CZ^ (- ₁)) • ε • [ (a , b + - a) , nz' ]ᵃ ≈⟨ cong refl left-unit ⟩
  (Ex • CZ^ (- ₁)) • [ (a , b + - a) , nz' ]ᵃ ≈⟨ assoc ⟩
  Ex • CZ^ (- ₁) • [ (a , b + - a) , nz' ]ᵃ ≈⟨ refl ⟩
  [ d' ]ᵈ ≈⟨ sym (trans left-unit left-unit) ⟩
  S^ e • dir ↑ • [ d' ]ᵈ ∎
  where
  edd = dir-and-d' d g neq
  e = edd .proj₁
  dir = edd .proj₂ .proj₁
  d' = edd .proj₂ .proj₂
  nz' = aux-a≠0⇒ab≠0 a (b + - a) λ ()


lemma-D-br d@(a@₀ , b@₀) g@(H-gen) neq = begin
  [ d ]ᵈ • H ≈⟨ lemma-Ex-H ⟩
  H ↑ • [ d ]ᵈ ≈⟨ sym left-unit ⟩
  S^ e • dir ↑ • [ d' ]ᵈ ∎
  where
  edd = dir-and-d' d g neq
  e = edd .proj₁
  dir = edd .proj₂ .proj₁
  d' = edd .proj₂ .proj₂

lemma-D-br d@(a@₀ , b@(₁₊ _)) g@(H-gen) neq = begin
  (Ex • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ) • H ≈⟨ special-assoc (□ ^ 3 • □) (□ ^ 2 • □ ^ 2) auto ⟩
  (Ex • CZ^ (- ₁)) • [ (a , b) , (λ ()) ]ᵃ • H ≈⟨ cright lemma-single-qupit-br-A 1 ((a , b) , (λ ())) H-gen tt ⟩
  (Ex • CZ^ (- ₁)) • ε • [ (b , ₀) , (λ ()) ]ᵃ ≈⟨ cong refl left-unit ⟩
  (Ex • CZ^ (- ₁)) • [ (b , ₀) , (λ ()) ]ᵃ ≈⟨ assoc ⟩
  Ex • CZ^ (- ₁) • [ (b , ₀) , (λ ()) ]ᵃ ≈⟨ sym (trans left-unit left-unit) ⟩
  S^ e • dir ↑ • [ d' ]ᵈ ∎
  where
  edd = dir-and-d' d g neq
  e = edd .proj₁
  dir = edd .proj₂ .proj₁
  d' = edd .proj₂ .proj₂


lemma-D-br d@(a@(₁₊ _) , b@₀) g@(H-gen) neq = begin
  (Ex • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ) • H ≈⟨ special-assoc (□ ^ 3 • □) (□ ^ 2 • □ ^ 2) auto ⟩
  (Ex • CZ^ (- ₁)) • [ (a , b) , (λ ()) ]ᵃ • H ≈⟨ cright  lemma-single-qupit-br-A 1 ((a , b) , (λ ())) H-gen tt ⟩
  (Ex • CZ^ (- ₁)) • ε • [ (₀ , - a) , nz' ]ᵃ ≈⟨ cong refl left-unit ⟩
  (Ex • CZ^ (- ₁)) • [ (₀ , - a) , nz' ]ᵃ ≈⟨ assoc ⟩
  Ex • CZ^ (- ₁) • [ (₀ , - a) , nz' ]ᵃ ≈⟨ sym (aux-dbox-nzb (- a) (((-' (a , λ ())) .proj₂))) ⟩
  [ d' ]ᵈ ≈⟨ sym (trans left-unit left-unit) ⟩
  S^ e • dir ↑ • [ d' ]ᵈ ∎
  where
  edd = dir-and-d' d g neq
  e = edd .proj₁
  dir = edd .proj₂ .proj₁
  d' = edd .proj₂ .proj₂
  nz' = aux-b≠0⇒ab≠0 ₀ (- a) ((-' (a , λ ())) .proj₂)

lemma-D-br d@(a@(₁₊ _) , b@(₁₊ _)) g@(H-gen) neq = begin
  (Ex • CZ^ (- ₁) • [ (a , b) , (λ ()) ]ᵃ) • H ≈⟨ special-assoc (□ ^ 3 • □) (□ ^ 2 • □ ^ 2) auto ⟩
  (Ex • CZ^ (- ₁)) • [ (a , b) , (λ ()) ]ᵃ • H ≈⟨ cright  lemma-single-qupit-br-A 1 ((a , b) , (λ ())) H-gen tt ⟩
  (Ex • CZ^ (- ₁)) • S^ [ab]⁻¹ • [ (b , - a) , nz' ]ᵃ ≈⟨ special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ⟩
  Ex • (CZ^ (- ₁) • S^ [ab]⁻¹) • [ (b , - a) , nz' ]ᵃ ≈⟨ cright cleft word-comm (toℕ (- 1ₚ)) (toℕ [ab]⁻¹) (axiom comm-CZ-S↓) ⟩
  Ex • (S^ [ab]⁻¹ • CZ^ (- ₁)) • [ (b , - a) , nz' ]ᵃ ≈⟨ sym (special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto) ⟩
  (Ex • S^ [ab]⁻¹) • CZ^ (- ₁) • [ (b , - a) , nz' ]ᵃ ≈⟨ cleft lemma-Ex-S^ᵏ [ab]⁻¹ ⟩
  (S^ [ab]⁻¹ ↑ • Ex) • CZ^ (- ₁) • [ (b , - a) , nz' ]ᵃ ≈⟨ assoc ⟩
  S^ [ab]⁻¹ ↑ • Ex • CZ^ (- ₁) • [ (b , - a) , nz' ]ᵃ ≈⟨ refl ⟩
  S^ [ab]⁻¹ ↑ • [ (b , - a) ]ᵈ ≈⟨ sym left-unit ⟩
  S^ e • dir ↑ • [ d' ]ᵈ ∎
  where
  edd = dir-and-d' d g neq
  e = edd .proj₁
  dir = edd .proj₂ .proj₁
  d' = edd .proj₂ .proj₂
  nz' = aux-a≠0⇒ab≠0 b (- a) λ ()
  [ab]⁻¹ = ((  (a , λ ()) *' (b , λ ())  ) ⁻¹) .proj₁
