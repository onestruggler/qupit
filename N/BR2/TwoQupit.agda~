{-# OPTIONS  --safe #-}
{-# OPTIONS  --call-by-name #-}
{-# OPTIONS --termination-depth=4 #-}
open import Level using (0ℓ)

open import Relation.Binary using (Rel)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Binary.Morphism.Definitions using (Homomorphic₂)
open import Relation.Binary.PropositionalEquality using (_≡_ ; _≢_ ; inspect ; setoid ; module ≡-Reasoning ; _≗_) renaming ([_] to [_]')
import Relation.Binary.Reasoning.Setoid as SR
import Relation.Binary.PropositionalEquality as Eq
open import Relation.Nullary.Decidable using (yes ; no)


open import Function using (_∘_ ; id)
open import Function.Definitions using (Injective)

open import Data.Product using (_×_ ; _,_ ; proj₁ ; proj₂ ; map₁ ; ∃ ; Σ ; Σ-syntax)
open import Data.Product.Relation.Binary.Pointwise.NonDependent as PW using (≡×≡⇒≡ ; Pointwise ; ≡⇒≡×≡)
open import Data.Nat hiding (_^_ ; _+_ ; _*_)
open import Agda.Builtin.Nat using (_-_)
import Data.Nat as Nat
open import Data.Bool hiding (_<_ ; _≤_)
--open import Data.List using () hiding ([_] ; _++_ ; last ; head ; tail ; _∷ʳ_)
open import Data.Vec hiding ([_])
open import Data.Vec as V
open import Data.Fin hiding (_+_ ; _-_ ; _≤_ ; _<_)

open import Data.Maybe
open import Data.Sum using (_⊎_ ; inj₁ ; inj₂ ; [_,_] ; [_,_]′)
open import Data.Unit using (⊤ ; tt)
open import Data.Empty using (⊥ ; ⊥-elim)

open import Word.Base as WB hiding (wfoldl ; _* ; _^'_)
open import Word.Properties
import Presentation.Base as PB
import Presentation.Properties as PP
open PP using (NFProperty ; NFProperty')
import Presentation.CosetNF as CA
import Presentation.Reidemeister-Schreier as RS
module RSF = RS.Star-Injective-Full.Reidemeister-Schreier-Full

open import Presentation.Construct.Base hiding (_*_ ; _⊕_)
import Presentation.Construct.Properties.SemiDirectProduct2 as SDP2
import Presentation.Construct.Properties.DirectProduct as DP
import Presentation.Groups.Cyclic as Cyclic


open import Data.Fin using (Fin ; toℕ ; suc ; zero ; fromℕ)
open import Data.Fin.Properties using (suc-injective ; toℕ-inject₁ ; toℕ-fromℕ)
import Data.Nat.Properties as NP
open import Presentation.GroupLike
open import Presentation.Tactics using ()
open import Data.Nat.Primality



module N.BR2.TwoQupit (p-2 : ℕ) (p-prime : Prime (2+ p-2)) where

n : ℕ
n = 0
    
pattern auto = Eq.refl

pattern ₀ = zero
pattern ₁ = suc ₀
pattern ₂ = suc ₁
pattern ₃ = suc ₂
pattern ₅ = 5
pattern ₆ = 6
pattern ₇ = 7
pattern ₈ = 8
pattern ₉ = 9
pattern ₁₀ = 10
pattern ₁₁ = 11
pattern ₁₂ = 12
pattern ₁₃ = 13
pattern ₁₄ = 14
pattern ₁₅ = 15

pattern ₁₊ ⱼ = suc ⱼ
pattern ₂₊ ⱼ = suc (suc ⱼ)
pattern ₃₊ ⱼ = suc (suc (suc ⱼ))
pattern ₄₊ ⱼ = suc (suc (suc (suc ⱼ)))


open import Zp.ModularArithmetic
open PrimeModulus p-2 p-prime
open import N.Cosets p-2 p-prime
open import N.Symplectic p-2 p-prime
open Symplectic renaming (M to ZM)
open import N.NF1-Sym p-2 p-prime
open import N.LM-Sym p-2 p-prime

open import N.Action p-2 p-prime
open import N.Action-Lemmas p-2 p-prime
open import Algebra.Properties.Ring (+-*-ring p-2)
open import N.NF2-Sym p-2 p-prime
open LM2


open import Zp.ModularArithmetic
open import N.Lemmas-2Qupit-Sym p-2 p-prime
open import N.NF2-Sym p-2 p-prime
--open Lemmas-2Q 2

open import N.NF1 p-2 p-prime
open import N.Ex-Sym p-2 p-prime
open import N.Ex-Sym1 p-2 p-prime
open import N.Ex-Sym2 p-2 p-prime
open import N.Ex-Sym3 p-2 p-prime
open import N.Ex-Sym4 p-2 p-prime
open import N.Ex-Sym5 p-2 p-prime hiding (module L0)
open import N.Ex-Sym2n p-2 p-prime
open import N.Ex-Sym3n p-2 p-prime

open import N.Lemma-Comm-n p-2 p-prime 0
open import N.Completeness1-Sym p-2 p-prime renaming (module Completeness to Cp1)
open Lemmas0a
open Lemmas0a1
open Lemmas0b
open Lemmas0c
open Lemmas-Sym
open Duality

open import N.Completeness1-Sym p-2 p-prime renaming (module Completeness to CP1) using ()
open import N.Coset2-Update-Sym p-2 p-prime renaming (module Completeness to CP2) using ()
open import N.Lemmas4-Sym p-2 p-prime
open import N.Lemmas-3Q p-2 p-prime
open import N.Pushing.DH p-2 p-prime
open import N.Duality p-2 p-prime
open import N.BR2.Calculations p-2 p-prime


open PB ((₂₊ n) QRel,_===_)
open PP ((₂₊ n) QRel,_===_)
open SR word-setoid
open Pattern-Assoc
open Lemmas0 n
open Lemmas-2Q n
open Sym0-Rewriting (₁₊ n)


fig-27-1 : ∀ (b*@(b , nzb) : ℤ* ₚ) ->
  let
  b⁻¹ = (b* ⁻¹) .proj₁
  nz = aux-b≠0⇒ab≠0 ₀ b nzb
  in
  
  [ (₀ , b) , nz ]ᵃ ↑ • CZ ≈ CZ^ b⁻¹ • [ (₀ , b) , nz ]ᵃ ↑

fig-27-1 b*@(b , nzb) = begin
  [ (₀ , b) , nz ]ᵃ ↑ • CZ ≈⟨ cleft lemma-cong↑ _ _ (aux-abox-nzb b nzb) ⟩
  ⟦ (b , nzb) ⁻¹ ⟧ₘ ↑ • CZ ≈⟨ axiom (semi-M↑CZ ((b , nzb) ⁻¹)) ⟩
  CZ^ b⁻¹ • ⟦ (b , nzb) ⁻¹ ⟧ₘ ↑ ≈⟨ cright sym (lemma-cong↑ _ _ (aux-abox-nzb b nzb)) ⟩
  CZ^ b⁻¹ • [ (₀ , b) , nz ]ᵃ ↑ ∎
  where
  b⁻¹ = (b* ⁻¹) .proj₁
  nz = aux-b≠0⇒ab≠0 ₀ b nzb


fig-27-1-dual : ∀ (b*@(b , nzb) : ℤ* ₚ) ->
  let
  b⁻¹ = (b* ⁻¹) .proj₁
  nz = aux-b≠0⇒ab≠0 ₀ b nzb
  in
  
  [ (₀ , b) , nz ]ᵃ  • CZ ≈ CZ^ b⁻¹ • [ (₀ , b) , nz ]ᵃ 

fig-27-1-dual b*@(b , nzb) = begin
  [ (₀ , b) , nz ]ᵃ  • CZ ≈⟨ cleft (aux-abox-nzb b nzb) ⟩
  ⟦ (b , nzb) ⁻¹ ⟧ₘ  • CZ ≈⟨ axiom (semi-M↓CZ ((b , nzb) ⁻¹)) ⟩
  CZ^ b⁻¹ • ⟦ (b , nzb) ⁻¹ ⟧ₘ  ≈⟨ cright sym ((aux-abox-nzb b nzb)) ⟩
  CZ^ b⁻¹ • [ (₀ , b) , nz ]ᵃ  ∎
  where
  b⁻¹ = (b* ⁻¹) .proj₁
  nz = aux-b≠0⇒ab≠0 ₀ b nzb


{-
fig-27-2 : ∀ (a*@(a , nza) : ℤ* ₚ) (b : ℤ ₚ) ->
  let
  a⁻¹ = (a* ⁻¹) .proj₁
  -b/a = - b * a⁻¹
  nz : (a , b) ≢ (₀ , ₀)
  nz = aux-a≠0⇒ab≠0 a b nza
  nz' : (₀ , - a) ≢ (₀ , ₀)
  nz' = aux-b≠0⇒ab≠0 ₀ (- a) ((-' a*) .proj₂)
  in
  
  [ (a , b) , nz ]ᵃ ↑ • CZ ≈ CZ^ a⁻¹ • [ a , b ]ᵇ • [ (₀ , - a) , nz' ]ᵃ

fig-27-2 a*@(a , nza) b = begin
  [ (a , b) , nz ]ᵃ ↑ • CZ ≈⟨ cleft lemma-cong↑ _ _ (aux-abox-nza a b nza) ⟩
  ⟦ (a , nza) ⁻¹ , HS^ -b/a ⟧ₘ₊ ↑ • CZ ≈⟨ refl ⟩
  ⟦ (a , nza) ⁻¹ , HS^ -b/a ⟧ₘ₊ ↑ • CZ ≈⟨ {!!} ⟩
  CZ^ a⁻¹ • (Ex • CX • [ (a , b) , nz ]ᵃ ↑) • ⟦ (- a , (-' a*) .proj₂) ⁻¹ ⟧ₘ ≈⟨ cright cong (sym (aux-bbox-nza a b nza)) (sym (aux-abox-nzb (- a) ((-' a*) .proj₂))) ⟩
  CZ^ a⁻¹ • [ a , b ]ᵇ • [ (₀ , - a) , nz' ]ᵃ ∎
  where
  a⁻¹ = (a* ⁻¹) .proj₁
  -b/a = - b * a⁻¹
  nz : (a , b) ≢ (₀ , ₀)
  nz = aux-a≠0⇒ab≠0 a b nza
  nz' : (₀ , - a) ≢ (₀ , ₀)
  nz' = aux-b≠0⇒ab≠0 ₀ (- a) ((-' a*) .proj₂)

-}

fig-28-1 : ∀ (b*@(b , nzb) : ℤ* ₚ) ->
  let
  b⁻¹ = (b* ⁻¹) .proj₁
  nz = aux-b≠0⇒ab≠0 ₀ b nzb
  in
  
  [ ₀ , ₀ ]ᵇ • [ (₀ , b) , nz ]ᵃ • CZ ≈ CZ^ b⁻¹ • [ ₀ , ₀ ]ᵇ • [ (₀ , b) , nz ]ᵃ

fig-28-1 b*@(b , nzb) = begin
  [ ₀ , ₀ ]ᵇ • [ (₀ , b) , nz ]ᵃ  • CZ ≈⟨ cright fig-27-1-dual b* ⟩
  [ ₀ , ₀ ]ᵇ • CZ^ b⁻¹ • [ (₀ , b) , nz ]ᵃ  ≈⟨ sym assoc ⟩  
  ([ ₀ , ₀ ]ᵇ • CZ^ b⁻¹) • [ (₀ , b) , nz ]ᵃ  ≈⟨ cleft word-comm 1 (toℕ b⁻¹) (sym lemma-comm-Ex-CZ-n) ⟩  
  (CZ^ b⁻¹ • [ ₀ , ₀ ]ᵇ) • [ (₀ , b) , nz ]ᵃ  ≈⟨ assoc ⟩  
  CZ^ b⁻¹ • [ ₀ , ₀ ]ᵇ • [ (₀ , b) , nz ]ᵃ  ∎
  where
  b⁻¹ = (b* ⁻¹) .proj₁
  nz = aux-b≠0⇒ab≠0 ₀ b nzb



fig-28-2 : ∀ (b*@(b , nzb) d*@(d , nzd) : ℤ* ₚ) ->
  let
  b⁻¹ = (b* ⁻¹) .proj₁
  d⁻¹ = (d* ⁻¹) .proj₁
  [bd]⁻¹ = b⁻¹ * d⁻¹
  -2[bd]⁻¹ = - [bd]⁻¹ + - [bd]⁻¹
  nz = aux-b≠0⇒ab≠0 ₀ b nzb
  in
  
  [ ₀ , d ]ᵇ • [ (₀ , b) , nz ]ᵃ • CZ ≈ (S^ -2[bd]⁻¹ • CZ^ [bd]⁻¹) • [ ₀ , d ]ᵇ • [ (₀ , b) , nz ]ᵃ

fig-28-2 b*@(b , nzb) d*@(d , nzd) = begin
  [ ₀ , d ]ᵇ • [ (₀ , b) , nz ]ᵃ  • CZ ≈⟨ cright fig-27-1-dual b* ⟩
  [ ₀ , d ]ᵇ • CZ^ b⁻¹ • [ (₀ , b) , nz ]ᵃ  ≈⟨ sym assoc ⟩  
  ([ ₀ , d ]ᵇ • CZ^ b⁻¹) • [ (₀ , b) , nz ]ᵃ  ≈⟨ cleft cleft aux-bbox-nzb' d nzd ⟩
  ((Ex • CX • ⟦ (d , nzd) ⁻¹ ⟧ₘ ↑) • CZ^ b⁻¹) • [ (₀ , b) , nz ]ᵃ  ≈⟨ special-assoc ((□ ^ 3 • □) • □) (□ ^ 2 • □ ^ 2 • □) auto ⟩
  (Ex • CX) • (⟦ (d , nzd) ⁻¹ ⟧ₘ ↑ • CZ^ b⁻¹) • [ (₀ , b) , nz ]ᵃ  ≈⟨ cright cleft lemma-M↑CZ^k d⁻¹ b⁻¹ (((d , nzd) ⁻¹) .proj₂) ⟩
  (Ex • CX) • (CZ^ (b⁻¹ * d⁻¹) • ⟦ (d , nzd) ⁻¹ ⟧ₘ ↑) • [ (₀ , b) , nz ]ᵃ  ≈⟨ special-assoc (□ ^ 2 • □ ^ 2 • □) (□ • □ ^ 2 • □ ^ 2) auto ⟩
  Ex • (CX • CZ^ (b⁻¹ * d⁻¹)) • ⟦ (d , nzd) ⁻¹ ⟧ₘ ↑ • [ (₀ , b) , nz ]ᵃ  ≈⟨ cright cleft lemma-semi-CXCZ^k k* ⟩
  Ex • (S^ -2k ↑ • CZ^ k • CX) • ⟦ (d , nzd) ⁻¹ ⟧ₘ ↑ • [ (₀ , b) , nz ]ᵃ  ≈⟨ special-assoc (□ • □ ^ 3 • □) (□ ^ 2 • □ ^ 3) auto ⟩
  (Ex • S^ -2k ↑) • CZ^ k • CX • ⟦ (d , nzd) ⁻¹ ⟧ₘ ↑ • [ (₀ , b) , nz ]ᵃ  ≈⟨ cleft cright sym (refl' (lemma-^-↑ S (toℕ -2k))) ⟩
  (Ex • S ↑ ^ toℕ -2k) • CZ^ k • CX • ⟦ (d , nzd) ⁻¹ ⟧ₘ ↑ • [ (₀ , b) , nz ]ᵃ  ≈⟨ cleft lemma-Induction lemma-Ex-S↑-n (toℕ -2k) ⟩
  (S^ -2k • Ex) • CZ^ k • CX • ⟦ (d , nzd) ⁻¹ ⟧ₘ ↑ • [ (₀ , b) , nz ]ᵃ  ≈⟨ special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ⟩
  S^ -2k • (Ex • CZ^ k) • CX • ⟦ (d , nzd) ⁻¹ ⟧ₘ ↑ • [ (₀ , b) , nz ]ᵃ  ≈⟨ cright cleft word-comm 1 (toℕ k) (sym lemma-comm-Ex-CZ-n) ⟩
  S^ -2k • (CZ^ k • Ex) • CX • ⟦ (d , nzd) ⁻¹ ⟧ₘ ↑ • [ (₀ , b) , nz ]ᵃ  ≈⟨ special-assoc (□ • □ ^ 2 • □ ^ 3) (□ ^ 2 • □ ^ 3 • □) auto ⟩
  (S^ -2k • CZ^ k) • (Ex • CX • ⟦ (d , nzd) ⁻¹ ⟧ₘ ↑) • [ (₀ , b) , nz ]ᵃ  ≈⟨ cright cleft sym (aux-bbox-nzb' d nzd) ⟩
  (S^ -2k • CZ^ k) • [ ₀ , d ]ᵇ • [ (₀ , b) , nz ]ᵃ  ≈⟨ refl ⟩
  (S^ -2[bd]⁻¹ • CZ^ [bd]⁻¹) • [ ₀ , d ]ᵇ • [ (₀ , b) , nz ]ᵃ  ∎
  where
  b⁻¹ = (b* ⁻¹) .proj₁
  d⁻¹ = (d* ⁻¹) .proj₁
  nz = aux-b≠0⇒ab≠0 ₀ b nzb
  k* : ℤ* ₚ
  k* = (b* ⁻¹ *' d* ⁻¹)
  
  k : ℤ ₚ
  k = k* .proj₁
  -k : ℤ ₚ
  -k = - k
  k⁻¹ : ℤ ₚ
  k⁻¹ = ((k* ⁻¹) .proj₁)
  -k⁻¹ : ℤ ₚ
  -k⁻¹ = - k⁻¹
  -2k = -k + -k
  [bd]⁻¹ = b⁻¹ * d⁻¹
  -2[bd]⁻¹ = - [bd]⁻¹ + - [bd]⁻¹


aux-HH↑-CZ⁻¹ : H ↑ ^ 2 • CZ⁻¹ ≈ CZ • H ↑ ^ 2
aux-HH↑-CZ⁻¹ = begin
  H ↑ ^ 2 • CZ⁻¹ ≈⟨ lemma-semi-HH↑-CZ^k′ p-1 ⟩
  (CZ^ ₋₁) ^ p-1 • H ↑ ^ 2 ≈⟨ cleft lemma-^-cong _ _ p-1 (refl' (Eq.cong (CZ ^_) lemma-toℕ₋₁)) ⟩
  (CZ ^ p-1) ^ p-1 • H ↑ ^ 2 ≈⟨ cleft aux-CZ⁻¹⁻¹ ⟩
  CZ • H ↑ ^ 2 ∎


fig-28-3 : ∀ (b*@(b , nzb) : ℤ* ₚ) (d : ℤ ₚ) ->
  let
  b⁻¹ = (b* ⁻¹) .proj₁
  nz : (₀ , b) ≢ (₀ , ₀)
  nz = aux-b≠0⇒ab≠0 ₀ b nzb
  nz' : (b , d) ≢ (₀ , ₀)
  nz' = aux-a≠0⇒ab≠0 b d nzb
  in
  
  [ b , d ]ᵇ • [ (₀ , b) , nz ]ᵃ • CZ ≈ (H ^ 3 • CZ • H ^ 3 • ZM (b* ⁻¹)) • [ (b , d) , nz' ]ᵃ ↑

fig-28-3 b*@(b , nzb) d = begin
  [ b , d ]ᵇ • [ (₀ , b) , nz ]ᵃ • CZ ≈⟨ cright cleft aux-abox-nzb b nzb ⟩
  [ b , d ]ᵇ • ⟦ (b , nzb) ⁻¹ ⟧ₘ • CZ ≈⟨ cright axiom (semi-M↓CZ ((b , nzb) ⁻¹)) ⟩
  [ b , d ]ᵇ • CZ^ b⁻¹ • ⟦ (b , nzb) ⁻¹ ⟧ₘ ≈⟨ cleft aux-bbox-nza' b d nzb ⟩
  (Ex • CX • ⟦ (b , nzb) ⁻¹ , HS^ -d/b ⟧ₘ₊ ↑) • CZ^ b⁻¹ • ⟦ (b , nzb) ⁻¹ ⟧ₘ ≈⟨ special-assoc (□ ^ 5 • □ ^ 2) (□ ^ 4 • □ ^ 2 • □) auto ⟩
  (Ex • CX • ⟦ (b , nzb) ⁻¹ ⟧ₘ ↑ • H ↑) • (S^ -d/b ↑ • CZ^ b⁻¹) • ⟦ (b , nzb) ⁻¹ ⟧ₘ ≈⟨ cright cleft sym (word-comm (toℕ b⁻¹) 1 (aux-comm-CZ-S^k↑ (-d/b))) ⟩
  (Ex • CX • ⟦ (b , nzb) ⁻¹ ⟧ₘ ↑ • H ↑) • (CZ^ b⁻¹ • S^ -d/b ↑) • ⟦ (b , nzb) ⁻¹ ⟧ₘ ≈⟨ sym (cleft cright cright lemma-cong↑ _ _ (semi-HM (b , nzb))) ⟩
  (Ex • CX • H ↑ • ⟦ (b , nzb) ⟧ₘ ↑) • (CZ^ b⁻¹ • S^ -d/b ↑) • ⟦ (b , nzb) ⁻¹ ⟧ₘ ≈⟨ special-assoc (□ ^ 4 • □ ^ 2 • □) (□ ^ 3 • □ ^ 2 • □ ^ 2) auto ⟩
  (Ex • CX • H ↑) • (⟦ (b , nzb) ⟧ₘ ↑ • CZ^ b⁻¹) • S^ -d/b ↑ • ⟦ (b , nzb) ⁻¹ ⟧ₘ ≈⟨ cright cleft lemma-M↑CZ^k b b⁻¹ nzb ⟩
  (Ex • CX • H ↑) • (CZ^ (b⁻¹ * b) • ⟦ (b , nzb) ⟧ₘ ↑) • S^ -d/b ↑ • ⟦ (b , nzb) ⁻¹ ⟧ₘ ≈⟨ cright cleft cleft refl' (Eq.cong CZ^ (lemma-⁻¹ˡ b {{nztoℕ {y = b} {neq0 = nzb}}})) ⟩
  (Ex • CX • H ↑) • (CZ • ⟦ (b , nzb) ⟧ₘ ↑) • S^ -d/b ↑ • ⟦ (b , nzb) ⁻¹ ⟧ₘ ≈⟨ special-assoc ((□ • □ ^ 3 • □) • □ ^ 2 • □) (□ ^ 6 • □ ^ 2) auto ⟩
  (Ex • H ^ 3 • CZ • H • H ↑ • CZ) • ⟦ (b , nzb) ⟧ₘ ↑ • S^ -d/b ↑ • ⟦ (b , nzb) ⁻¹ ⟧ₘ ≈⟨ cleft cright cright aux-hEx' ⟩
  (Ex • H ^ 3 • H ↑ ^ 3 • H ^ 3 • CZ⁻¹ • H ↑ ^ 3 • H ^ 3 • Ex) • ⟦ (b , nzb) ⟧ₘ ↑ • S^ -d/b ↑ • ⟦ (b , nzb) ⁻¹ ⟧ₘ ≈⟨ cleft special-assoc (□ ^ 8) (□ • □ ^ 6 • □) auto ⟩
  (Ex • (H ^ 3 • H ↑ ^ 3 • H ^ 3 • CZ⁻¹ • H ↑ ^ 3 • H ^ 3) • Ex) • ⟦ (b , nzb) ⟧ₘ ↑ • S^ -d/b ↑ • ⟦ (b , nzb) ⁻¹ ⟧ₘ ≈⟨ cleft sym (lemma-Ex-dual ((H ^ 3 • H ↑ ^ 3 • H ^ 3 • CZ⁻¹ • H ↑ ^ 3 • H ^ 3))) ⟩
  ((H ↑ ^ 3 • H ^ 3 • H ↑ ^ 3 • dual CZ⁻¹ • H ^ 3 • H ↑ ^ 3)) • ⟦ (b , nzb) ⟧ₘ ↑ • S^ -d/b ↑ • ⟦ (b , nzb) ⁻¹ ⟧ₘ ≈⟨ cleft special-assoc (□ ^ 4 ) (□ ^ 3 • □) auto ⟩
  ((H ↑ ^ 3 • H ^ 3 • H ↑ ^ 3) • dual CZ⁻¹ • H ^ 3 • H ↑ ^ 3) • ⟦ (b , nzb) ⟧ₘ ↑ • S^ -d/b ↑ • ⟦ (b , nzb) ⁻¹ ⟧ₘ ≈⟨ cleft cong (rewrite-sym0 100 auto) (cleft refl' (aux-dual-CZ^k p-1)) ⟩
  ((H ^ 3 • H ↑ ^ 2) • CZ⁻¹ • H ^ 3 • H ↑ ^ 3) • ⟦ (b , nzb) ⟧ₘ ↑ • S^ -d/b ↑ • ⟦ (b , nzb) ⁻¹ ⟧ₘ ≈⟨ cleft special-assoc (□ ^ 2 • □ ^ 3) (□ • □ ^ 2 • □ ^ 2) auto ⟩
  (H ^ 3 • (H ↑ ^ 2 • CZ⁻¹) • H ^ 3 • H ↑ ^ 3) • ⟦ (b , nzb) ⟧ₘ ↑ • S^ -d/b ↑ • ⟦ (b , nzb) ⁻¹ ⟧ₘ ≈⟨ cleft cright cleft aux-HH↑-CZ⁻¹ ⟩
  (H ^ 3 • (CZ • H ↑ ^ 2) • H ^ 3 • H ↑ ^ 3) • ⟦ (b , nzb) ⟧ₘ ↑ • S^ -d/b ↑ • ⟦ (b , nzb) ⁻¹ ⟧ₘ ≈⟨ cleft cright assoc ⟩
  (H ^ 3 • CZ • H ↑ ^ 2 • H ^ 3 • H ↑ ^ 3) • ⟦ (b , nzb) ⟧ₘ ↑ • S^ -d/b ↑ • ⟦ (b , nzb) ⁻¹ ⟧ₘ ≈⟨ cleft rewrite-sym0 100 auto ⟩
  (H ^ 3 • CZ • H ^ 3 • H ↑) • ⟦ (b , nzb) ⟧ₘ ↑ • S^ -d/b ↑ • ⟦ (b , nzb) ⁻¹ ⟧ₘ ≈⟨ special-assoc (□ ^ 4 • □ ^ 3) (□ ^ 3 • □ ^ 2 • □ ^ 2) auto ⟩
  (H ^ 3 • CZ • H ^ 3) • (H ↑ • ⟦ (b , nzb) ⟧ₘ ↑) • S^ -d/b ↑ • ⟦ (b , nzb) ⁻¹ ⟧ₘ ≈⟨ cright cleft lemma-cong↑ _ _ (semi-HM (b , nzb)) ⟩
  (H ^ 3 • CZ • H ^ 3) • (⟦ (b , nzb) ⁻¹ ⟧ₘ ↑ • H ↑) • S^ -d/b ↑ • ⟦ (b , nzb) ⁻¹ ⟧ₘ ≈⟨ cright special-assoc (□ ^ 2 • □ ^ 2) (□ ^ 3 • □) auto ⟩
  (H ^ 3 • CZ • H ^ 3) • (⟦ (b , nzb) ⁻¹ ⟧ₘ ↑ • H ↑ • S^ -d/b ↑) • ⟦ (b , nzb) ⁻¹ ⟧ₘ ≈⟨ cright sym (aux-comm-MMC ((b , nzb) ⁻¹) ((b , nzb) ⁻¹) (HS^ -d/b)) ⟩
  (H ^ 3 • CZ • H ^ 3) • ⟦ (b , nzb) ⁻¹ ⟧ₘ • (⟦ (b , nzb) ⁻¹ ⟧ₘ ↑ • H ↑ • S^ -d/b ↑) ≈⟨ special-assoc (□ ^ 3 • □ ^ 2) (□ ^ 4 • □) auto ⟩
  (H ^ 3 • CZ • H ^ 3 • ⟦ (b , nzb) ⁻¹ ⟧ₘ) • (⟦ (b , nzb) ⁻¹ ⟧ₘ ↑ • H ↑ • S^ -d/b ↑) ≈⟨ refl ⟩
  (H ^ 3 • CZ • H ^ 3 • ZM (b* ⁻¹)) • (⟦ (b , nzb) ⁻¹ ⟧ₘ ↑ • H ↑ • S^ -d/b ↑)  ≈⟨ cright sym (lemma-cong↑ _ _ (aux-abox-nza b d nzb) ) ⟩
  (H ^ 3 • CZ • H ^ 3 • ZM (b* ⁻¹)) • [ (b , d) , nz' ]ᵃ ↑ ∎
  where
  b⁻¹ = (b* ⁻¹) .proj₁
  nz : (₀ , b) ≢ (₀ , ₀)
  nz = aux-b≠0⇒ab≠0 ₀ b nzb
  nz' : (b , d) ≢ (₀ , ₀)
  nz' = aux-a≠0⇒ab≠0 b d nzb
  -d/b = - d * b⁻¹


_^ᵖ_ : ∀ {X : Set} -> Word X -> ℤ ₚ -> Word X
_^ᵖ_ {X} w k = w ^ toℕ k

open import Data.Nat.DivMod
open import Data.Fin.Properties

lemma-S^k*l : ∀ k l -> S^ k ^ᵖ l ≈ S^ (k * l)
lemma-S^k*l k l = begin
  S^ k ^ᵖ l ≈⟨ refl ⟩
  (S ^ toℕ k) ^ toℕ l ≈⟨ lemma-^^ S (toℕ k) (toℕ l) ⟩
  S ^ (toℕ k Nat.* toℕ l) ≡⟨ Eq.cong (S ^_) (m≡m%n+[m/n]*n k*l p) ⟩
  S ^ (k*l Nat.% p Nat.+ (k*l Nat./ p) Nat.* p) ≈⟨ lemma-^-+ S (k*l Nat.% p) (((k*l Nat./ p) Nat.* p)) ⟩
  S ^ (k*l Nat.% p) • S ^ ((k*l Nat./ p) Nat.* p) ≈⟨ cong (refl' (Eq.cong (S ^_) (Eq.sym (toℕ-fromℕ< (m%n<n k*l p))))) (refl' (Eq.cong (S ^_) (NP.*-comm ((k*l Nat./ p)) p))) ⟩
  S ^ toℕ (fromℕ< (m%n<n k*l p)) • S ^ (p Nat.* (k*l Nat./ p) ) ≈⟨ cong (sym (refl)) (sym (lemma-^^ S p (k*l Nat./ p))) ⟩
  S^ (k * l) • (S ^ p) ^ (k*l Nat./ p) ≈⟨ cright (lemma-^-cong (S ^ p) ε (k*l Nat./ p) (axiom order-S)) ⟩
  S^ (k * l) • ε ^ (k*l Nat./ p) ≈⟨ cright lemma-ε^k=ε (k*l Nat./ p) ⟩
  S^ (k * l) • ε ≈⟨ right-unit ⟩
  S^ (k * l) ∎
  where
  k*l = toℕ k Nat.* toℕ l

lemma-CZ^k*l : ∀ k l -> CZ^ k ^ᵖ l ≈ CZ^ (k * l)
lemma-CZ^k*l k l = begin
  CZ^ k ^ᵖ l ≈⟨ refl ⟩
  (CZ ^ toℕ k) ^ toℕ l ≈⟨ lemma-^^ CZ (toℕ k) (toℕ l) ⟩
  CZ ^ (toℕ k Nat.* toℕ l) ≡⟨ Eq.cong (CZ ^_) (m≡m%n+[m/n]*n k*l p) ⟩
  CZ ^ (k*l Nat.% p Nat.+ (k*l Nat./ p) Nat.* p) ≈⟨ lemma-^-+ CZ (k*l Nat.% p) (((k*l Nat./ p) Nat.* p)) ⟩
  CZ ^ (k*l Nat.% p) • CZ ^ ((k*l Nat./ p) Nat.* p) ≈⟨ cong (refl' (Eq.cong (CZ ^_) (Eq.sym (toℕ-fromℕ< (m%n<n k*l p))))) (refl' (Eq.cong (CZ ^_) (NP.*-comm ((k*l Nat./ p)) p))) ⟩
  CZ ^ toℕ (fromℕ< (m%n<n k*l p)) • CZ ^ (p Nat.* (k*l Nat./ p) ) ≈⟨ cong (sym (refl)) (sym (lemma-^^ CZ p (k*l Nat./ p))) ⟩
  CZ^ (k * l) • (CZ ^ p) ^ (k*l Nat./ p) ≈⟨ cright (lemma-^-cong (CZ ^ p) ε (k*l Nat./ p) (axiom order-CZ)) ⟩
  CZ^ (k * l) • ε ^ (k*l Nat./ p) ≈⟨ cright lemma-ε^k=ε (k*l Nat./ p) ⟩
  CZ^ (k * l) • ε ≈⟨ right-unit ⟩
  CZ^ (k * l) ∎
  where
  k*l = toℕ k Nat.* toℕ l


{-

lemma-^^ᵖ : ∀ w a b -> w ^ p 
  (w ^ᵖ a) ^ᵖ b ≈ w ^ᵖ (a * b)
lemma-^^ᵖ w zero zero = refl
lemma-^^ᵖ w zero (suc zero) = PB.refl
lemma-^^ᵖ w zero (suc (suc b)) = trans left-unit (lemma-^^ᵖ w zero (suc b))
lemma-^^ᵖ w (suc zero) b = refl' (Eq.cong (w ^_) (Eq.sym (NP.+-identityʳ b)))
lemma-^^ᵖ w (suc (suc a)) b = begin
  (w • w ^ suc a) ^ b ≈⟨ lemma-^-• w (w ^ suc a) b (lemma-comm-wᵃwᵇ w 1 (suc a)) ⟩
  w ^ b • (w ^ suc a) ^ b ≈⟨ (cong refl (lemma-^^ᵖ w (suc a) b))  ⟩
  w ^ b • w ^ (suc a Nat.* b) ≈⟨ sym (lemma-^-+ w b (suc a Nat.* b)) ⟩
  w ^ (b Nat.+ (b Nat.+ a Nat.* b)) ∎

-}


open Rewriting-Swap 1
open Symplectic-GroupLike
open Basis-Change _ (2 QRel,_===_) grouplike

  
aux-CZ⁻¹^k-CZ^-k : ∀ (k : ℤ ₚ) -> CZ⁻¹ ^ toℕ k ≈ CZ ^ toℕ (- k)
aux-CZ⁻¹^k-CZ^-k k = begin
  CZ⁻¹ ^ toℕ k ≈⟨ sym (lemma-^-cong _ _ (toℕ k) (refl' (Eq.cong (CZ ^_) lemma-toℕ-1ₚ))) ⟩
  CZ^ (- ₁) ^ toℕ k ≈⟨ refl ⟩
  CZ^ (- ₁) ^ᵖ k ≈⟨ lemma-CZ^k*l (- ₁) k  ⟩
  CZ^ (- ₁ * k)  ≈⟨ refl' (Eq.cong CZ^ (-1*x≈-x k)) ⟩
  CZ^ (- k) ≈⟨ refl ⟩
  CZ ^ toℕ (- k) ∎

aux-Ex-CX^k-N : ∀ k -> Ex • CX ^ k ≈ XC ^ k • Ex
aux-Ex-CX^k-N k@0 = trans right-unit (sym left-unit)
aux-Ex-CX^k-N k@1 = rewrite-swap 100 auto
aux-Ex-CX^k-N k@(₁₊ k'@(₁₊ k'')) = begin
  Ex • CX ^ k ≈⟨ sym assoc ⟩
  (Ex • CX) • CX ^ k' ≈⟨ cleft rewrite-swap 100 auto ⟩
  (XC • Ex) • CX ^ k' ≈⟨ assoc ⟩
  XC • Ex • CX ^ k' ≈⟨ cright aux-Ex-CX^k-N k' ⟩
  XC • XC ^ k' • Ex ≈⟨ sym assoc ⟩
  XC ^ k • Ex ∎



aux-Ex-CX^k : ∀ k -> Ex • CX^ k ≈ XC^ k • Ex
aux-Ex-CX^k k = aux-Ex-CX^k-N (toℕ k)

aux-Ex-XC^k : ∀ k -> Ex • XC^ k ≈ CX^ k • Ex
aux-Ex-XC^k k = bbc Ex Ex claim
  where
  claim : Ex • (Ex • XC^ k) • Ex ≈ Ex • (CX^ k • Ex) • Ex
  claim = begin
    Ex • (Ex • XC^ k) • Ex ≈⟨ by-assoc auto ⟩
    (Ex • Ex) • XC^ k • Ex ≈⟨ cleft rewrite-swap 100 auto ⟩
    ε • XC^ k • Ex ≈⟨ left-unit ⟩
    XC^ k • Ex ≈⟨ sym (aux-Ex-CX^k k) ⟩
    Ex • CX^ k ≈⟨ cong refl (sym right-unit) ⟩
    Ex • CX^ k • ε ≈⟨ cright cright rewrite-swap 100 auto ⟩
    Ex • CX^ k • Ex • Ex ≈⟨ sym (cong refl assoc) ⟩
    Ex • (CX^ k • Ex) • Ex ∎


aux-XC^-XC'^-N : ∀ k -> XC ^ k ≈ H ↑ ^ 3 • CZ ^ k • H ↑
aux-XC^-XC'^-N k@0 = rewrite-swap 100 auto
aux-XC^-XC'^-N k@1 = refl
aux-XC^-XC'^-N k@(₁₊ k'@(₁₊ k'')) = begin
  XC ^ k ≈⟨ refl ⟩
  XC • XC ^ k' ≈⟨ cright aux-XC^-XC'^-N k' ⟩
  XC • H ↑ ^ 3 • CZ ^ k' • H ↑ ≈⟨ sym assoc ⟩
  (XC • H ↑ ^ 3) • CZ ^ k' • H ↑ ≈⟨ cleft rewrite-sym0 100 auto  ⟩
  (H ↑ ^ 3 • CZ) • CZ ^ k' • H ↑ ≈⟨ special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ⟩
  H ↑ ^ 3 • (CZ • CZ ^ k') • H ↑ ≈⟨ refl ⟩
  H ↑ ^ 3 • CZ ^ k • H ↑ ∎

aux-CX^-CX'^-N : ∀ k -> CX ^ k ≈ H ^ 3 • CZ ^ k • H
aux-CX^-CX'^-N k@0 = rewrite-sym0 100 auto
aux-CX^-CX'^-N k@1 = refl
aux-CX^-CX'^-N k@(₁₊ k'@(₁₊ k'')) = begin
  CX ^ k ≈⟨ refl ⟩
  CX • CX ^ k' ≈⟨ cright aux-CX^-CX'^-N k' ⟩
  CX • H ^ 3 • CZ ^ k' • H ≈⟨ sym assoc ⟩
  (CX • H ^ 3) • CZ ^ k' • H ≈⟨ cleft rewrite-sym0 100 auto  ⟩
  (H ^ 3 • CZ) • CZ ^ k' • H ≈⟨ special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ⟩
  H ^ 3 • (CZ • CZ ^ k') • H ≈⟨ refl ⟩
  H ^ 3 • CZ ^ k • H ∎





aux-XC^-XC'^ : ∀ k -> XC^ k ≈ XC'^ k
aux-XC^-XC'^ k = aux-XC^-XC'^-N (toℕ k)

aux-CX^-CX'^ : ∀ k -> CX^ k ≈ CX'^ k
aux-CX^-CX'^ k = aux-CX^-CX'^-N (toℕ k)

open import N.Duality p-2 p-prime
open Duality

lemma-semi-XCCZ^k : ∀ (k*@(k , nz) : ℤ* ₚ) ->
  let
    -2k : ℤ ₚ
    -2k = - k + - k
  in

  XC • CZ^ k ≈ S^ -2k • CZ^ k • XC
lemma-semi-XCCZ^k k*@(k , nz) = by-duality' (lemma-semi-CXCZ^k k*) c1 c2
  where
  -2k : ℤ ₚ
  -2k = - k + - k
  c1 : dual (CX • CZ^ k) ≈ XC • CZ^ k
  c1 = cright refl' (aux-dual-CZ^k (toℕ k))
  c2 : dual (S^ -2k ↑ • CZ^ k • CX) ≈ S^ -2k • CZ^ k • XC
  c2 = begin
    dual (S^ -2k ↑ • CZ^ k • CX) ≈⟨ cong (refl' (aux-dual-S^k↑ (toℕ -2k))) (cleft refl' (aux-dual-CZ^k (toℕ k))) ⟩
    S^ -2k • CZ^ k • XC ∎

aux-CZ-H↑-CZ^k : ∀ (k*@(k , nz) : ℤ* ₚ) ->
  let -2k = - k + - k in
  
  CZ • H ↑ • CZ^ k ≈ (S^ -2k • H ↑ • CZ^ k • H ↑ ^ 3) • CZ • H ↑

aux-CZ-H↑-CZ^k k*@(k , nz) = begin
  CZ • H ↑ • CZ^ k ≈⟨ sym assoc ⟩
  (CZ • H ↑) • CZ^ k ≈⟨ cleft rewrite-sym0 100 auto ⟩
  (H ↑ • XC) • CZ^ k ≈⟨ assoc ⟩
  H ↑ • XC • CZ^ k ≈⟨ cright lemma-semi-XCCZ^k k* ⟩
  H ↑ • S^ -2k • CZ^ k • XC ≈⟨ sym assoc ⟩
  (H ↑ • S^ -2k) • CZ^ k • XC ≈⟨ cleft sym (lemma-comm-Sᵏ-w↑ (toℕ -2k) H) ⟩
  (S^ -2k • H ↑) • CZ^ k • XC ≈⟨ special-assoc (□ ^ 2 • □ ^ 4) (□ ^ 4 • □ ^ 2) auto ⟩
  (S^ -2k • H ↑ • CZ^ k • H ↑ ^ 3) • CZ • H ↑ ∎
  where
  -2k : ℤ ₚ
  -2k = - k + - k
