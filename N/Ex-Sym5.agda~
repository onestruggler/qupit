{-# OPTIONS  --safe #-}
--{-# OPTIONS --termination-depth=2 #-}
open import Level using (0ℓ)

open import Relation.Binary using (Rel)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Binary.Morphism.Definitions using (Homomorphic₂)
open import Relation.Binary.PropositionalEquality using (_≡_ ; _≢_ ; inspect ; setoid ; module ≡-Reasoning ; _≗_) renaming ([_] to [_]')
import Relation.Binary.Reasoning.Setoid as SR
import Relation.Binary.PropositionalEquality as Eq
open import Relation.Nullary.Decidable using (yes ; no)


open import Function using (_∘_ ; id)
open import Function.Definitions using (Injective)

open import Data.Product using (_×_ ; _,_ ; proj₁ ; proj₂ ; map₁ ; ∃ ; Σ ; Σ-syntax)
open import Data.Product.Relation.Binary.Pointwise.NonDependent as PW using (≡×≡⇒≡ ; Pointwise ; ≡⇒≡×≡)
open import Data.Nat hiding (_^_ ; _+_ ; _*_)
open import Agda.Builtin.Nat using (_-_)
import Data.Nat as Nat
open import Data.Bool hiding (_<_ ; _≤_)
open import Data.List hiding ([_] ; _++_ ; last ; head ; tail ; _∷ʳ_)
open import Data.Vec hiding ([_])
import Data.Vec as Vec
open import Data.Fin hiding (_+_ ; _-_)

open import Data.Maybe
open import Data.Sum using (_⊎_ ; inj₁ ; inj₂ ; [_,_] ; [_,_]′)
open import Data.Unit using (⊤ ; tt)
open import Data.Empty using (⊥ ; ⊥-elim)

open import Word.Base as WB hiding (wfoldl ; _*)
open import Word.Properties
import Presentation.Base as PB
import Presentation.Properties as PP
open PP using (NFProperty ; NFProperty')
import Presentation.CosetNF as CA
import Presentation.Reidemeister-Schreier as RS
module RSF = RS.Star-Injective-Full.Reidemeister-Schreier-Full

open import Presentation.Construct.Base hiding (_*_ ; _⊕_)
import Presentation.Construct.Properties.SemiDirectProduct2 as SDP2
import Presentation.Construct.Properties.DirectProduct as DP
import Presentation.Groups.Cyclic as Cyclic


open import Data.Fin using (Fin ; toℕ ; suc ; zero ; fromℕ)
open import Data.Fin.Properties using (suc-injective ; toℕ-inject₁ ; toℕ-fromℕ)
import Data.Nat.Properties as NP
open import Presentation.GroupLike
open import Presentation.Tactics hiding ([_])
open import Data.Nat.Primality



module N.Ex-Sym5 (p-2 : ℕ) (p-prime : Prime (2+ p-2))  where

pattern auto = Eq.refl

pattern ₀ = zero
pattern ₁ = suc ₀
pattern ₂ = suc ₁
pattern ₃ = suc ₂
pattern ₄ = 4
pattern ₅ = 5
pattern ₆ = 6
pattern ₇ = 7
pattern ₈ = 8
pattern ₉ = 9
pattern ₁₀ = 10
pattern ₁₁ = 11
pattern ₁₂ = 12
pattern ₁₃ = 13
pattern ₁₄ = 14
pattern ₁₅ = 15

pattern ₁₊ ⱼ = suc ⱼ
pattern ₂₊ ⱼ = suc (suc ⱼ)
pattern ₃₊ ⱼ = suc (suc (suc ⱼ))


open import Zp.ModularArithmetic
open PrimeModulus p-2 p-prime
open import N.Symplectic p-2 p-prime
open import N.Lemmas-2Qupit-Sym p-2 p-prime
open import N.NF2-Sym p-2 p-prime
open Lemmas-2Q 0
open Symplectic
open import N.NF1-Sym p-2 p-prime
open Normal-Form1
open import N.Ex-Sym p-2 p-prime
open import N.Ex-Sym1 p-2 p-prime
open import N.Ex-Sym2 p-2 p-prime
open import N.Ex-Sym3 p-2 p-prime
open import N.Ex-Sym4 p-2 p-prime
open import N.Ex-Rewriting p-2 p-prime
open Rewriting-Ex

open import N.Lemma-Comm p-2 p-prime
open import N.Lemma-Postfix p-2 p-prime
open import N.Duality p-2 p-prime hiding (module L0)
open Lemmas0a
open Lemmas0a1
open Lemmas0b
open Lemmas0c

open LM2
open import N.Completeness1-Sym p-2 p-prime renaming (module Completeness to CP1) using ()

private
  variable
    n : ℕ

open Symplectic
open Lemmas-Sym
open Symplectic-GroupLike

open import Data.Nat.DivMod
open import Data.Fin.Properties
open Duality







open import Algebra.Properties.Ring (+-*-ring p-2)
open PB (₂ QRel,_===_)
open PP (₂ QRel,_===_)
open SR word-setoid
open Pattern-Assoc
open Lemmas0 1
open Commuting-Symplectic 0
open Sym0-Rewriting 1
open Basis-Change _ ((₂₊ 0) QRel,_===_) grouplike
import N.Duality p-2 p-prime as ND



open import N.Proofs.P1 p-2 p-prime
open import N.Proofs.P2 p-2 p-prime
open import N.Lemmas-2Qupit-Sym p-2 p-prime as TQ

open Duality
open Lemmas0 1
module L0 = Lemmas0 0


step-|-CZa : ∀ m s' m' ->
  let
    aa = ((m ⁻¹) .proj₁ + m' .proj₁)
  in aa ≡ ₀ -> 
  ⟦ case-| (m , ε) (s' , m' , ε) ⟧₂ • CZ ≈ (⟦ m ⟧ₘ ↑) • ⟦ case-nf1 (s' , m' , ε) ⟧₂
  
step-|-CZa m s' m' eq = claim
  where
  claim : ⟦ case-| (m , ε) (s' , m' , ε) ⟧₂ • CZ ≈ (⟦ m ⟧ₘ ↑) • ⟦ case-nf1 (s' , m' , ε) ⟧₂
  claim  = begin
    ⟦ case-| (m , ε) (s' , m' , ε) ⟧₂ • CZ ≈⟨ trans assoc (cong refl assoc) ⟩
    CZ • ⟦ (m , ε) ⟧ₘ₊ ↑ • ⟦ (s' , m' , ε) ⟧₁ • CZ ≈⟨ (cright cong right-unit (cong (cong refl right-unit) refl)) ⟩
    CZ • ⟦ m ⟧ₘ ↑ • (S^ s' • ⟦ m' ⟧ₘ) • CZ ≈⟨ (cright special-assoc (□ • □ ^ 2 • □) (□ ^ 2 • □ ^ 2) auto) ⟩
    CZ • (⟦ m ⟧ₘ ↑ • S^ s') • ⟦ m' ⟧ₘ • CZ ≈⟨ (cright cleft sym (lemma-comm-Sᵏ-w↑ (toℕ s') ⟦ m ⟧ₘ)) ⟩
    CZ • (S^ s' • ⟦ m ⟧ₘ ↑) • ⟦ m' ⟧ₘ • CZ ≈⟨ special-assoc (□ • □ ^ 2 • □ ^ 2) (□ ^ 2 • □ ^ 3) auto ⟩
    (CZ • S^ s') • ⟦ m ⟧ₘ ↑ • ⟦ m' ⟧ₘ • CZ ≈⟨ (cleft word-comm 1 (toℕ s') (axiom comm-CZ-S↓)) ⟩
    (S^ s' • CZ) • ⟦ m ⟧ₘ ↑ • ⟦ m' ⟧ₘ • CZ ≈⟨ assoc ⟩
    S^ s' • CZ • ⟦ m ⟧ₘ ↑ • ⟦ m' ⟧ₘ • CZ ≈⟨ ( cright  lemma-|MM| m m') ⟩
    S^ s' • ⟦ m ⟧ₘ ↑ • (CZ^ ((m ⁻¹) .proj₁ + m' .proj₁)) • ⟦ m' ⟧ₘ ≈⟨ (cright cright cleft refl' (Eq.cong CZ^ eq)) ⟩
    S^ s' • ⟦ m ⟧ₘ ↑ • (CZ^ ₀) • ⟦ m' ⟧ₘ ≈⟨ cong refl (cong refl left-unit) ⟩
    S^ s' • ⟦ m ⟧ₘ ↑ • ⟦ m' ⟧ₘ ≈⟨ sym assoc ⟩
    (S^ s' • ⟦ m ⟧ₘ ↑) • ⟦ m' ⟧ₘ ≈⟨ (cleft lemma-comm-Sᵏ-w↑ (toℕ s') ⟦ m ⟧ₘ) ⟩
    (⟦ m ⟧ₘ ↑ • S^ s') • ⟦ m' ⟧ₘ ≈⟨ assoc ⟩
    ⟦ m ⟧ₘ ↑ • S^ s' • ⟦ m' ⟧ₘ ≈⟨ (cright cright  sym right-unit) ⟩
    ⟦ m ⟧ₘ ↑ • S^ s' • ⟦ m' ⟧ₘ • ε ≈⟨ refl ⟩
    ⟦ m ⟧ₘ ↑ • ⟦ (s' , m' , ε) ⟧₁ ∎

step-|-CZb : ∀ m s' m' ->
  let
    aa = ((m ⁻¹) .proj₁ + m' .proj₁)
  in (neq : aa ≢ ₀) -> 
  ⟦ case-| (m , ε) (s' , m' , ε) ⟧₂ • CZ ≈ (⟦ m ⟧ₘ • M (aa , neq)) ↑ • ⟦ case-| ((aa , neq) ⁻¹ , ε) (s' , m' , ε) ⟧₂
  
step-|-CZb m s' m' neq = claim
  where
  aa = ((m ⁻¹) .proj₁ + m' .proj₁)
  
  claim : ⟦ case-| (m , ε) (s' , m' , ε) ⟧₂ • CZ ≈ (⟦ m ⟧ₘ • M (aa , neq)) ↑ • ⟦ case-| ((aa , neq) ⁻¹ , ε) (s' , m' , ε) ⟧₂
  claim = begin
    ⟦ case-| (m , ε) (s' , m' , ε) ⟧₂ • CZ ≈⟨ trans assoc (cong refl assoc) ⟩
    CZ • ⟦ (m , ε) ⟧ₘ₊ ↑ • ⟦ (s' , m' , ε) ⟧₁ • CZ ≈⟨ (cright cong right-unit (cong (cong refl right-unit) refl)) ⟩
    CZ • ⟦ m ⟧ₘ ↑ • (S^ s' • ⟦ m' ⟧ₘ) • CZ ≈⟨ (cright special-assoc (□ • □ ^ 2 • □) (□ ^ 2 • □ ^ 2) auto) ⟩
    CZ • (⟦ m ⟧ₘ ↑ • S^ s') • ⟦ m' ⟧ₘ • CZ ≈⟨ (cright cleft sym (lemma-comm-Sᵏ-w↑ (toℕ s') ⟦ m ⟧ₘ)) ⟩
    CZ • (S^ s' • ⟦ m ⟧ₘ ↑) • ⟦ m' ⟧ₘ • CZ ≈⟨ special-assoc (□ • □ ^ 2 • □ ^ 2) (□ ^ 2 • □ ^ 3) auto ⟩
    (CZ • S^ s') • ⟦ m ⟧ₘ ↑ • ⟦ m' ⟧ₘ • CZ ≈⟨ (cleft word-comm 1 (toℕ s') (axiom comm-CZ-S↓)) ⟩
    (S^ s' • CZ) • ⟦ m ⟧ₘ ↑ • ⟦ m' ⟧ₘ • CZ ≈⟨ assoc ⟩
    S^ s' • CZ • ⟦ m ⟧ₘ ↑ • ⟦ m' ⟧ₘ • CZ ≈⟨ ( cright  lemma-|MM| m m') ⟩
    S^ s' • ⟦ m ⟧ₘ ↑ • (CZ^ ((m ⁻¹) .proj₁ + m' .proj₁)) • ⟦ m' ⟧ₘ ≈⟨ sym assoc ⟩
    (S^ s' • ⟦ m ⟧ₘ ↑) • (CZ^ ((m ⁻¹) .proj₁ + m' .proj₁)) • ⟦ m' ⟧ₘ ≈⟨ cong (lemma-comm-Sᵏ-w↑ (toℕ s') ⟦ m ⟧ₘ) (sym left-unit) ⟩
    (⟦ m ⟧ₘ ↑ • S^ s') • ε • (CZ^ ((m ⁻¹) .proj₁ + m' .proj₁)) • ⟦ m' ⟧ₘ ≈⟨ sym (cright cleft lemma-cong↑ _ _ (L0.aux-M-mul (aa , neq))) ⟩
    (⟦ m ⟧ₘ ↑ • S^ s') • (M (aa , neq) ↑ • M ((aa , neq) ⁻¹) ↑ ) • (CZ^ ((m ⁻¹) .proj₁ + m' .proj₁)) • ⟦ m' ⟧ₘ ≈⟨ (cright assoc) ⟩
    (⟦ m ⟧ₘ ↑ • S^ s') • M (aa , neq) ↑ • M ((aa , neq) ⁻¹) ↑  • (CZ^ ((m ⁻¹) .proj₁ + m' .proj₁)) • ⟦ m' ⟧ₘ ≈⟨ (cright cright sym assoc) ⟩
    (⟦ m ⟧ₘ ↑ • S^ s') • M (aa , neq) ↑ • (M ((aa , neq) ⁻¹) ↑  • CZ^ ((m ⁻¹) .proj₁ + m' .proj₁)) • ⟦ m' ⟧ₘ ≈⟨ (cright cright cleft lemma-M↑CZ^k (((aa , neq) ⁻¹) .proj₁) (((m ⁻¹) .proj₁ + m' .proj₁)) (((aa , neq) ⁻¹) .proj₂)) ⟩
    (⟦ m ⟧ₘ ↑ • S^ s') • M (aa , neq) ↑ • (CZ^ (((m ⁻¹) .proj₁ + m' .proj₁) * ((aa , neq) ⁻¹) .proj₁) • M ((aa , neq) ⁻¹) ↑) • ⟦ m' ⟧ₘ ≈⟨ assoc ⟩
    ⟦ m ⟧ₘ ↑ • S^ s' • M (aa , neq) ↑ • (CZ^ (((m ⁻¹) .proj₁ + m' .proj₁) * ((aa , neq) ⁻¹) .proj₁) • M ((aa , neq) ⁻¹) ↑) • ⟦ m' ⟧ₘ ≈⟨ (cright sym assoc) ⟩
    ⟦ m ⟧ₘ ↑ • (S^ s' • M (aa , neq) ↑) • (CZ^ (((m ⁻¹) .proj₁ + m' .proj₁) * ((aa , neq) ⁻¹) .proj₁) • M ((aa , neq) ⁻¹) ↑) • ⟦ m' ⟧ₘ ≈⟨ (cright cong (lemma-comm-Sᵏ-w↑ (toℕ s') (M (aa , neq))) (cleft (cleft refl' (Eq.cong CZ^ aux)))) ⟩
    ⟦ m ⟧ₘ ↑ • (M (aa , neq) ↑ • S^ s') • (CZ • M ((aa , neq) ⁻¹) ↑) • ⟦ m' ⟧ₘ ≈⟨ (cright assoc) ⟩
    ⟦ m ⟧ₘ ↑ • M (aa , neq) ↑ • S^ s' • (CZ • M ((aa , neq) ⁻¹) ↑) • ⟦ m' ⟧ₘ ≈⟨ (cright cright special-assoc (□ • □ ^ 2 • □) (□ ^ 2 • □ ^ 2) auto) ⟩
    ⟦ m ⟧ₘ ↑ • M (aa , neq) ↑ • (S^ s' • CZ) • M ((aa , neq) ⁻¹) ↑ • ⟦ m' ⟧ₘ ≈⟨ (cright cright cleft word-comm (toℕ s') 1 (sym (axiom comm-CZ-S↓))) ⟩
    ⟦ m ⟧ₘ ↑ • M (aa , neq) ↑ • (CZ • S^ s') • M ((aa , neq) ⁻¹) ↑ • ⟦ m' ⟧ₘ ≈⟨ (cright cright assoc) ⟩
    ⟦ m ⟧ₘ ↑ • M (aa , neq) ↑ • CZ • S^ s' • M ((aa , neq) ⁻¹) ↑ • ⟦ m' ⟧ₘ ≈⟨ (cright cright cright sym assoc) ⟩
    ⟦ m ⟧ₘ ↑ • M (aa , neq) ↑ • CZ • (S^ s' • M ((aa , neq) ⁻¹) ↑) • ⟦ m' ⟧ₘ ≈⟨ (cright cright cright cleft lemma-comm-Sᵏ-w↑ (toℕ s') (M ((aa , neq) ⁻¹))) ⟩
    ⟦ m ⟧ₘ ↑ • M (aa , neq) ↑ • CZ • (M ((aa , neq) ⁻¹) ↑ • S^ s') • ⟦ m' ⟧ₘ ≈⟨ (cright cright cright assoc) ⟩
    ⟦ m ⟧ₘ ↑ • M (aa , neq) ↑ • CZ • M ((aa , neq) ⁻¹) ↑ • S^ s' • ⟦ m' ⟧ₘ ≈⟨ (cright cright cright cright sym (cong refl right-unit)) ⟩
    ⟦ m ⟧ₘ ↑ • M (aa , neq) ↑ • CZ • (M ((aa , neq) ⁻¹) ↑) • S^ s' • ⟦ m' ⟧ₘ • ε ≈⟨ (cright cright cright cleft sym right-unit) ⟩
    ⟦ m ⟧ₘ ↑ • M (aa , neq) ↑ • CZ • (M ((aa , neq) ⁻¹) ↑ • ε) • S^ s' • ⟦ m' ⟧ₘ • ε ≈⟨ sym assoc ⟩
    (⟦ m ⟧ₘ • M (aa , neq)) ↑ • ⟦ case-| ((aa , neq) ⁻¹ , ε) (s' , m' , ε) ⟧₂ ∎
    where
    aux : (((m ⁻¹) .proj₁ + m' .proj₁) * ((aa , neq) ⁻¹) .proj₁) ≡ ₁
    aux = (lemma-⁻¹ʳ (aa) {{nztoℕ {y = aa} {neq0 = neq}}})



step-|-CZc : ∀ m s' m' ->
  let
    aa = ((m ⁻¹) .proj₁ + m' .proj₁)
  in (neq : aa ≢ ₀) -> 
  ⟦ case-| (m , ε) (s' , m' , ε) ⟧₂ • CZ ≈ (⟦ m ⟧ₘ • M (aa , neq)) ↑ • ⟦ case-| ((aa , neq) ⁻¹ , ε) (s' , m' , ε) ⟧₂
  
step-|-CZc m s' m' neq = claim
  where
  aa = ((m ⁻¹) .proj₁ + m' .proj₁)
  
  claim : ⟦ case-| (m , ε) (s' , m' , ε) ⟧₂ • CZ ≈ (⟦ m ⟧ₘ • M (aa , neq)) ↑ • ⟦ case-| ((aa , neq) ⁻¹ , ε) (s' , m' , ε) ⟧₂
  claim = begin
    ⟦ case-| (m , ε) (s' , m' , ε) ⟧₂ • CZ ≈⟨ trans assoc (cong refl assoc) ⟩
    CZ • ⟦ (m , ε) ⟧ₘ₊ ↑ • ⟦ (s' , m' , ε) ⟧₁ • CZ ≈⟨ (cright cong right-unit (cong (cong refl right-unit) refl)) ⟩
    CZ • ⟦ m ⟧ₘ ↑ • (S^ s' • ⟦ m' ⟧ₘ) • CZ ≈⟨ (cright special-assoc (□ • □ ^ 2 • □) (□ ^ 2 • □ ^ 2) auto) ⟩
    CZ • (⟦ m ⟧ₘ ↑ • S^ s') • ⟦ m' ⟧ₘ • CZ ≈⟨ (cright cleft sym (lemma-comm-Sᵏ-w↑ (toℕ s') ⟦ m ⟧ₘ)) ⟩
    CZ • (S^ s' • ⟦ m ⟧ₘ ↑) • ⟦ m' ⟧ₘ • CZ ≈⟨ special-assoc (□ • □ ^ 2 • □ ^ 2) (□ ^ 2 • □ ^ 3) auto ⟩
    (CZ • S^ s') • ⟦ m ⟧ₘ ↑ • ⟦ m' ⟧ₘ • CZ ≈⟨ (cleft word-comm 1 (toℕ s') (axiom comm-CZ-S↓)) ⟩
    (S^ s' • CZ) • ⟦ m ⟧ₘ ↑ • ⟦ m' ⟧ₘ • CZ ≈⟨ assoc ⟩
    S^ s' • CZ • ⟦ m ⟧ₘ ↑ • ⟦ m' ⟧ₘ • CZ ≈⟨ ( cright  lemma-|MM| m m') ⟩
    S^ s' • ⟦ m ⟧ₘ ↑ • (CZ^ ((m ⁻¹) .proj₁ + m' .proj₁)) • ⟦ m' ⟧ₘ ≈⟨ sym assoc ⟩
    (S^ s' • ⟦ m ⟧ₘ ↑) • (CZ^ ((m ⁻¹) .proj₁ + m' .proj₁)) • ⟦ m' ⟧ₘ ≈⟨ cong (lemma-comm-Sᵏ-w↑ (toℕ s') ⟦ m ⟧ₘ) (sym left-unit) ⟩
    (⟦ m ⟧ₘ ↑ • S^ s') • ε • (CZ^ ((m ⁻¹) .proj₁ + m' .proj₁)) • ⟦ m' ⟧ₘ ≈⟨ sym (cright cleft lemma-cong↑ _ _ (L0.aux-M-mul (aa , neq))) ⟩
    (⟦ m ⟧ₘ ↑ • S^ s') • (M (aa , neq) ↑ • M ((aa , neq) ⁻¹) ↑ ) • (CZ^ ((m ⁻¹) .proj₁ + m' .proj₁)) • ⟦ m' ⟧ₘ ≈⟨ (cright assoc) ⟩
    (⟦ m ⟧ₘ ↑ • S^ s') • M (aa , neq) ↑ • M ((aa , neq) ⁻¹) ↑  • (CZ^ ((m ⁻¹) .proj₁ + m' .proj₁)) • ⟦ m' ⟧ₘ ≈⟨ (cright cright sym assoc) ⟩
    (⟦ m ⟧ₘ ↑ • S^ s') • M (aa , neq) ↑ • (M ((aa , neq) ⁻¹) ↑  • CZ^ ((m ⁻¹) .proj₁ + m' .proj₁)) • ⟦ m' ⟧ₘ ≈⟨ (cright cright cleft lemma-M↑CZ^k (((aa , neq) ⁻¹) .proj₁) (((m ⁻¹) .proj₁ + m' .proj₁)) (((aa , neq) ⁻¹) .proj₂)) ⟩
    (⟦ m ⟧ₘ ↑ • S^ s') • M (aa , neq) ↑ • (CZ^ (((m ⁻¹) .proj₁ + m' .proj₁) * ((aa , neq) ⁻¹) .proj₁) • M ((aa , neq) ⁻¹) ↑) • ⟦ m' ⟧ₘ ≈⟨ assoc ⟩
    ⟦ m ⟧ₘ ↑ • S^ s' • M (aa , neq) ↑ • (CZ^ (((m ⁻¹) .proj₁ + m' .proj₁) * ((aa , neq) ⁻¹) .proj₁) • M ((aa , neq) ⁻¹) ↑) • ⟦ m' ⟧ₘ ≈⟨ (cright sym assoc) ⟩
    ⟦ m ⟧ₘ ↑ • (S^ s' • M (aa , neq) ↑) • (CZ^ (((m ⁻¹) .proj₁ + m' .proj₁) * ((aa , neq) ⁻¹) .proj₁) • M ((aa , neq) ⁻¹) ↑) • ⟦ m' ⟧ₘ ≈⟨ (cright cong (lemma-comm-Sᵏ-w↑ (toℕ s') (M (aa , neq))) (cleft (cleft refl' (Eq.cong CZ^ aux)))) ⟩
    ⟦ m ⟧ₘ ↑ • (M (aa , neq) ↑ • S^ s') • (CZ • M ((aa , neq) ⁻¹) ↑) • ⟦ m' ⟧ₘ ≈⟨ (cright assoc) ⟩
    ⟦ m ⟧ₘ ↑ • M (aa , neq) ↑ • S^ s' • (CZ • M ((aa , neq) ⁻¹) ↑) • ⟦ m' ⟧ₘ ≈⟨ (cright cright special-assoc (□ • □ ^ 2 • □) (□ ^ 2 • □ ^ 2) auto) ⟩
    ⟦ m ⟧ₘ ↑ • M (aa , neq) ↑ • (S^ s' • CZ) • M ((aa , neq) ⁻¹) ↑ • ⟦ m' ⟧ₘ ≈⟨ (cright cright cleft word-comm (toℕ s') 1 (sym (axiom comm-CZ-S↓))) ⟩
    ⟦ m ⟧ₘ ↑ • M (aa , neq) ↑ • (CZ • S^ s') • M ((aa , neq) ⁻¹) ↑ • ⟦ m' ⟧ₘ ≈⟨ (cright cright assoc) ⟩
    ⟦ m ⟧ₘ ↑ • M (aa , neq) ↑ • CZ • S^ s' • M ((aa , neq) ⁻¹) ↑ • ⟦ m' ⟧ₘ ≈⟨ (cright cright cright sym assoc) ⟩
    ⟦ m ⟧ₘ ↑ • M (aa , neq) ↑ • CZ • (S^ s' • M ((aa , neq) ⁻¹) ↑) • ⟦ m' ⟧ₘ ≈⟨ (cright cright cright cleft lemma-comm-Sᵏ-w↑ (toℕ s') (M ((aa , neq) ⁻¹))) ⟩
    ⟦ m ⟧ₘ ↑ • M (aa , neq) ↑ • CZ • (M ((aa , neq) ⁻¹) ↑ • S^ s') • ⟦ m' ⟧ₘ ≈⟨ (cright cright cright assoc) ⟩
    ⟦ m ⟧ₘ ↑ • M (aa , neq) ↑ • CZ • M ((aa , neq) ⁻¹) ↑ • S^ s' • ⟦ m' ⟧ₘ ≈⟨ (cright cright cright cright sym (cong refl right-unit)) ⟩
    ⟦ m ⟧ₘ ↑ • M (aa , neq) ↑ • CZ • (M ((aa , neq) ⁻¹) ↑) • S^ s' • ⟦ m' ⟧ₘ • ε ≈⟨ (cright cright cright cleft sym right-unit) ⟩
    ⟦ m ⟧ₘ ↑ • M (aa , neq) ↑ • CZ • (M ((aa , neq) ⁻¹) ↑ • ε) • S^ s' • ⟦ m' ⟧ₘ • ε ≈⟨ sym assoc ⟩
    (⟦ m ⟧ₘ • M (aa , neq)) ↑ • ⟦ case-| ((aa , neq) ⁻¹ , ε) (s' , m' , ε) ⟧₂ ∎
    where
    aux : (((m ⁻¹) .proj₁ + m' .proj₁) * ((aa , neq) ⁻¹) .proj₁) ≡ ₁
    aux = (lemma-⁻¹ʳ (aa) {{nztoℕ {y = aa} {neq0 = neq}}})


