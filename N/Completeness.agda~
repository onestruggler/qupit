{-# OPTIONS  --safe #-}
{-# OPTIONS  --call-by-name #-}
{-# OPTIONS --termination-depth=4 #-}
open import Level using (0ℓ)

open import Relation.Binary using (Rel)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Binary.Morphism.Definitions using (Homomorphic₂)
open import Relation.Binary.PropositionalEquality using (_≡_ ; _≢_ ; inspect ; setoid ; module ≡-Reasoning ; _≗_) renaming ([_] to [_]')
import Relation.Binary.Reasoning.Setoid as SR
import Relation.Binary.PropositionalEquality as Eq
open import Relation.Nullary.Decidable using (yes ; no)


open import Function using (_∘_ ; id)
open import Function.Definitions using (Injective)

open import Data.Product using (_×_ ; _,_ ; proj₁ ; proj₂ ; map₁ ; ∃ ; Σ ; Σ-syntax)
open import Data.Product.Relation.Binary.Pointwise.NonDependent as PW using (≡×≡⇒≡ ; Pointwise ; ≡⇒≡×≡)
open import Data.Nat hiding (_^_ ; _+_ ; _*_)
open import Agda.Builtin.Nat using (_-_)
import Data.Nat as Nat
open import Data.Bool hiding (_<_ ; _≤_)
--open import Data.List using () hiding ([_] ; _++_ ; last ; head ; tail ; _∷ʳ_)
open import Data.Vec hiding ([_])
open import Data.Vec as V
open import Data.Fin hiding (_+_ ; _-_ ; _≤_ ; _<_)

open import Data.Maybe
open import Data.Sum using (_⊎_ ; inj₁ ; inj₂ ; [_,_] ; [_,_]′)
open import Data.Unit using (⊤ ; tt)
open import Data.Empty using (⊥ ; ⊥-elim)

open import Word.Base as WB hiding (wfoldl ; _* ; _^'_)
open import Word.Properties
import Presentation.Base as PB
import Presentation.Properties as PP
open PP using (NFProperty ; NFProperty')
import Presentation.CosetNF as CA
import Presentation.Reidemeister-Schreier as RS
module RSF = RS.Star-Injective-Full.Reidemeister-Schreier-Full

open import Presentation.Construct.Base hiding (_*_ ; _⊕_)
import Presentation.Construct.Properties.SemiDirectProduct2 as SDP2
import Presentation.Construct.Properties.DirectProduct as DP
import Presentation.Groups.Cyclic as Cyclic


open import Data.Fin using (Fin ; toℕ ; suc ; zero ; fromℕ)
open import Data.Fin.Properties using (suc-injective ; toℕ-inject₁ ; toℕ-fromℕ)
import Data.Nat.Properties as NP
open import Presentation.GroupLike
open import Presentation.Tactics using ()
open import Data.Nat.Primality



module N.LM-Lemmas2 (p-2 : ℕ) (p-prime : Prime (2+ p-2))  where

pattern auto = Eq.refl

pattern ₀ = zero
pattern ₁ = suc ₀
pattern ₂ = suc ₁
pattern ₃ = suc ₂
pattern ₅ = 5
pattern ₆ = 6
pattern ₇ = 7
pattern ₈ = 8
pattern ₉ = 9
pattern ₁₀ = 10
pattern ₁₁ = 11
pattern ₁₂ = 12
pattern ₁₃ = 13
pattern ₁₄ = 14
pattern ₁₅ = 15

pattern ₁₊ ⱼ = suc ⱼ
pattern ₂₊ ⱼ = suc (suc ⱼ)
pattern ₃₊ ⱼ = suc (suc (suc ⱼ))
pattern ₄₊ ⱼ = suc (suc (suc (suc ⱼ)))


open import Zp.ModularArithmetic
open PrimeModulus p-2 p-prime
open import N.Cosets p-2 p-prime
open import N.Symplectic-Derived p-2 p-prime
open Symplectic-Derived-Gen renaming (M to ZM)
open import N.NF1 p-2 p-prime
open import N.LM p-2 p-prime
open import N.LM-Lemmas p-2 p-prime
open Normal-Form1

private
  variable
    n : ℕ
    
open import N.Action p-2 p-prime
open import N.Action-Lemmas p-2 p-prime
open import Algebra.Properties.Ring (+-*-ring p-2)
open import N.NF2 p-2 p-prime
open LM2

lemma-init-last : ∀ {n} {A : Set} (vs : Vec A (₁₊ n)) → vs ≡ init vs ∷ʳ last vs
lemma-init-last (x ∷ []) = auto
lemma-init-last (x ∷ x₁ ∷ vs) = Eq.cong (x ∷_) (lemma-init-last (x₁ ∷ vs))

lemma-ebox-XZ : ∀ e -> act {₁₊ n} ([ e ]ᵉ) (pX₀Z₀ e) ≡ pX₀
lemma-ebox-XZ {n} e = begin
  act {₁₊ n} ([ e ]ᵉ) (pX₀Z₀ e) ≡⟨ auto ⟩
  (₁ , e + ₁ * (- e)) ∷ pIₙ ≡⟨ Eq.cong (\ xx -> (₁ , e + xx) ∷ pIₙ) (*-identityˡ (- e)) ⟩
  (₁ , e + (- e)) ∷ pIₙ ≡⟨ Eq.cong (\ xx -> (₁ , xx) ∷ pIₙ) (+-inverseʳ e) ⟩
  pX₀ ∎
  where
  open ≡-Reasoning

lemma-pZₙ-pIₙ∷ʳpZ : ∀ {n} -> pZₙ ≡ pIₙ {n} ∷ʳ pZ
lemma-pZₙ-pIₙ∷ʳpZ {0} = auto
lemma-pZₙ-pIₙ∷ʳpZ {₁₊ n} = begin
  pI ∷ pZₙ ≡⟨ Eq.cong (pI ∷_) lemma-pZₙ-pIₙ∷ʳpZ ⟩
  pI ∷ (pIₙ ∷ʳ pZ) ≡⟨ auto ⟩
  pIₙ ∷ʳ pZ ∎
  where
  open ≡-Reasoning
  

Theorem-LM :

  ∀ (p q : Pauli n) ->
  sform p q ≡ ₁ ->
  -------------------------------
  ∃ \ lm -> act [ lm ]ˡᵐ p ≡ pZ₀ ×
            act [ lm ]ˡᵐ q ≡ pX₀


Theorem-LM {0} [] [] sf=1 = ⊥-elim (0ₚ≢1ₚ sf=1)
Theorem-LM {1} (p ∷ []) (q ∷ []) sf=1 = Theorem-NF1 p q [] sf=1'
  where
  sf=1' : sform1 p q ≡ ₁
  sf=1' rewrite +-identityʳ (sform1 p q) = sf=1
Theorem-LM {2} ps@(p1 ∷ p2 ∷ []) qs@(q1 ∷ q2 ∷ []) sf=1 = Theorem-LM2 ps qs [] sf=1
Theorem-LM {₃₊ n} ps@(p1@(₀ , ₀) ∷ p2 ∷ p3 ∷ pt) qs@(q1 ∷ q2 ∷ q3 ∷ qt) sf=1 = lm , claim1 , claim2
  where
  open ≡-Reasoning
  sf=1' : sform (p2 ∷ p3 ∷ pt) (q2 ∷ q3 ∷ qt) ≡ ₁
  sf=1' = begin
    sform (p2 ∷ p3 ∷ pt) (q2 ∷ q3 ∷ qt) ≡⟨ Eq.sym (+-identityˡ (sform (p2 ∷ p3 ∷ pt) (q2 ∷ q3 ∷ qt))) ⟩
    ₀ + sform (p2 ∷ p3 ∷ pt) (q2 ∷ q3 ∷ qt) ≡⟨ Eq.cong (_+ sform (p2 ∷ p3 ∷ pt) (q2 ∷ q3 ∷ qt)) (Eq.sym (sfrom-pIq=0 q1)) ⟩
    sform1 p1 q1 + sform (p2 ∷ p3 ∷ pt) (q2 ∷ q3 ∷ qt) ≡⟨ auto ⟩
    sform (p1 ∷ p2 ∷ p3 ∷ pt) (q1 ∷ q2 ∷ q3 ∷ qt) ≡⟨ sf=1 ⟩
    ₁ ∎
    
  ih = Theorem-LM {₂₊ n} (p2 ∷ p3 ∷ pt) (q2 ∷ q3 ∷ qt) sf=1'
  lm2 = ih .proj₁
  lm : LM (₃₊ n)
  lm = inj₂ (q1 , ih .proj₁)
  
  claim1 : act [ lm ]ˡᵐ ps ≡ pZ₀
  claim1 = begin
    act [ lm ]ˡᵐ ps ≡⟨ auto ⟩
    act ([ q1 ]ᵈ • [ lm2 ]ˡᵐ ↑) ps ≡⟨ auto ⟩
    act [ q1 ]ᵈ (act ([ lm2 ]ˡᵐ ↑) ps) ≡⟨ Eq.cong (act [ q1 ]ᵈ) (lemma-act-↑ [ lm2 ]ˡᵐ pI (p2 ∷ p3 ∷ pt)) ⟩
    act [ q1 ]ᵈ (pI ∷ act {₂₊ n} [ lm2 ]ˡᵐ (p2 ∷ p3 ∷ pt)) ≡⟨ Eq.cong (\ xx -> act [ q1 ]ᵈ (pI ∷ xx)) (ih .proj₂ .proj₁) ⟩
    act [ q1 ]ᵈ (pI ∷ pZ₀) ≡⟨ lemma-dbox-IZ q1 pIₙ ⟩
    pZ₀ ∎

  claim2 : act [ lm ]ˡᵐ qs ≡ pX₀
  claim2 = begin
    act [ lm ]ˡᵐ qs ≡⟨ auto ⟩
    act ([ q1 ]ᵈ • [ lm2 ]ˡᵐ ↑) qs ≡⟨ auto ⟩
    act [ q1 ]ᵈ (act ([ lm2 ]ˡᵐ ↑) qs) ≡⟨ Eq.cong (act [ q1 ]ᵈ) (lemma-act-↑ [ lm2 ]ˡᵐ q1 (q2 ∷ q3 ∷ qt)) ⟩
    act [ q1 ]ᵈ (q1 ∷ act {₂₊ n} [ lm2 ]ˡᵐ (q2 ∷ q3 ∷ qt)) ≡⟨ Eq.cong (\ xx -> act [ q1 ]ᵈ (q1 ∷ xx)) (ih .proj₂ .proj₂) ⟩
    act [ q1 ]ᵈ (q1 ∷ pX₀) ≡⟨ lemma-dbox q1 pIₙ ⟩
    pX₀ ∎


Theorem-LM {₃₊ n} ps@(p1@(a1@(₁₊ a1') , b1) ∷ p2 ∷ p3 ∷ pt) qs@(q1 ∷ q2 ∷ q3 ∷ qt) sf=1 = lm , claim1 , claim2
  where
  open ≡-Reasoning
  e : E
  e = e-after-abox-q p1 q1 (λ ())
  spq = sform1 p1 q1
  se = (spq , e)

  ttt = (act-bboxes se (p2 ∷ p3 ∷ pt) (q2 ∷ q3 ∷ qt))
  vd : Vec D (₂₊ n)
  vd = init ttt
  m : M (₃₊ n)
  m = (e , vd)
  l : L' (₃₊ n)
  l = (p2 ∷ p3 ∷ pt , (p1 , λ ()))
  lm : LM (₃₊ n)
  lm = inj₁ (m , l)
  
  claim1 : act [ lm ]ˡᵐ ((₁₊ a1' , b1) ∷ p2 ∷ p3 ∷ pt) ≡ pZ₀
  claim1 = begin
    act ([ m ]ᵐ • [ l ]ˡ') ((₁₊ a1' , b1) ∷ p2 ∷ p3 ∷ pt) ≡⟨ auto ⟩
    act ([ m ]ᵐ • [ p2 ∷ p3 ∷ pt ]ᵛᵇ • [ (p1 , λ ()) ]ᵃ) ((₁₊ a1' , b1) ∷ p2 ∷ p3 ∷ pt) ≡⟨ Eq.cong (act ([ m ]ᵐ • [ p2 ∷ p3 ∷ pt ]ᵛᵇ)) (lemma-abox p1 (λ ()) (p2 ∷ p3 ∷ pt)) ⟩
    act ([ m ]ᵐ • [ p2 ∷ p3 ∷ pt ]ᵛᵇ) (pZ ∷ p2 ∷ p3 ∷ pt) ≡⟨ Eq.cong (act ([ m ]ᵐ)) (lemma-bboxes (p2 ∷ p3 ∷ pt)) ⟩
    act ([ m ]ᵐ) (pZₙ) ≡⟨ auto ⟩
    act ([ e ]ᵉ • [ vd ]ᵛᵈ) pZₙ ≡⟨ Eq.cong (act ([ e ]ᵉ • [ vd ]ᵛᵈ)) lemma-pZₙ-pIₙ∷ʳpZ ⟩
    act ([ e ]ᵉ • [ vd ]ᵛᵈ) (pIₙ ∷ʳ pZ) ≡⟨ Eq.cong (act ([ e ]ᵉ)) (lemma-dboxes-Z (vd)) ⟩
    pZ₀ ∎


  claim2 : act [ lm ]ˡᵐ (q1 ∷ q2 ∷ q3 ∷ qt) ≡ pX₀
  claim2 = begin
    act ([ m ]ᵐ • [ l ]ˡ') (q1 ∷ q2 ∷ q3 ∷ qt) ≡⟨ auto ⟩
    act ([ m ]ᵐ • [ p2 ∷ p3 ∷ pt ]ᵛᵇ • [ (p1 , λ ()) ]ᵃ) (q1 ∷ q2 ∷ q3 ∷ qt) ≡⟨ Eq.cong (act ([ m ]ᵐ • [ p2 ∷ p3 ∷ pt ]ᵛᵇ)) (lemma-abox-X p1 q1 (λ ()) (q2 ∷ q3 ∷ qt)) ⟩
    act ([ m ]ᵐ • [ p2 ∷ p3 ∷ pt ]ᵛᵇ) (se ∷ q2 ∷ q3 ∷ qt) ≡⟨ Eq.cong (act ([ m ]ᵐ)) (lemma-bboxes-X' se (p2 ∷ p3 ∷ pt) (q2 ∷ q3 ∷ qt)) ⟩
    act ([ m ]ᵐ) ttt ≡⟨ Eq.cong (act ([ m ]ᵐ)) (lemma-init-last ttt) ⟩
    act ([ m ]ᵐ) (init ttt ∷ʳ last ttt) ≡⟨ Eq.cong (\ xx -> act ([ m ]ᵐ) (init ttt ∷ʳ xx)) (lemma-act-bboxes-last' se ((p2 ∷ p3 ∷ pt) ) ((q2 ∷ q3 ∷ qt))) ⟩
    act ([ m ]ᵐ) (init ttt ∷ʳ (spq + sform (p2 ∷ p3 ∷ pt) (q2 ∷ q3 ∷ qt) , e)) ≡⟨ Eq.cong (\ xx -> act ([ m ]ᵐ) (init ttt ∷ʳ (xx , e))) sf=1 ⟩
    act ([ m ]ᵐ) (init ttt ∷ʳ (₁ , e)) ≡⟨ Eq.cong (act ([ e ]ᵉ)) (lemma-dboxes-XZ e (init ttt)) ⟩
    act ([ e ]ᵉ) (pX₀Z₀ e) ≡⟨ lemma-ebox-XZ e ⟩
    pX₀ ∎
    where
    t1 = act-bbox p2 se q2 (q3 ∷ qt)
    p1' = head t1
    q1' = head (tail t1)
    il = act-bboxes q1' (p3 ∷ pt) (q3 ∷ qt)
    b'' = q1' .proj₂
    a'' = q1' .proj₁
    spq'' = sform  (p3 ∷ pt) (q3 ∷ qt)


Theorem-LM {₃₊ n} ps@(p1@(a1 , b1@(₁₊ b1')) ∷ p2 ∷ p3 ∷ pt) qs@(q1 ∷ q2 ∷ q3 ∷ qt) sf=1 = lm , claim1 , claim2
  where
  open ≡-Reasoning
  e : E
  e = e-after-abox-q p1 q1 (λ ())
  spq = sform1 p1 q1
  se = (spq , e)

  ttt = (act-bboxes se (p2 ∷ p3 ∷ pt) (q2 ∷ q3 ∷ qt))
  vd : Vec D (₂₊ n)
  vd = init ttt
  m : M (₃₊ n)
  m = (e , vd)
  l : L' (₃₊ n)
  l = (p2 ∷ p3 ∷ pt , (p1 , λ ()))
  lm : LM (₃₊ n)
  lm = inj₁ (m , l)
  
  claim1 : act [ lm ]ˡᵐ ((a1 , b1) ∷ p2 ∷ p3 ∷ pt) ≡ pZ₀
  claim1 = begin
    act ([ m ]ᵐ • [ l ]ˡ') ((a1 , b1) ∷ p2 ∷ p3 ∷ pt) ≡⟨ auto ⟩
    act ([ m ]ᵐ • [ p2 ∷ p3 ∷ pt ]ᵛᵇ • [ (p1 , λ ()) ]ᵃ) ((a1 , b1) ∷ p2 ∷ p3 ∷ pt) ≡⟨ Eq.cong (act ([ m ]ᵐ • [ p2 ∷ p3 ∷ pt ]ᵛᵇ)) (lemma-abox p1 (λ ()) (p2 ∷ p3 ∷ pt)) ⟩
    act ([ m ]ᵐ • [ p2 ∷ p3 ∷ pt ]ᵛᵇ) (pZ ∷ p2 ∷ p3 ∷ pt) ≡⟨ Eq.cong (act ([ m ]ᵐ)) (lemma-bboxes (p2 ∷ p3 ∷ pt)) ⟩
    act ([ m ]ᵐ) (pZₙ) ≡⟨ auto ⟩
    act ([ e ]ᵉ • [ vd ]ᵛᵈ) pZₙ ≡⟨ Eq.cong (act ([ e ]ᵉ • [ vd ]ᵛᵈ)) lemma-pZₙ-pIₙ∷ʳpZ ⟩
    act ([ e ]ᵉ • [ vd ]ᵛᵈ) (pIₙ ∷ʳ pZ) ≡⟨ Eq.cong (act ([ e ]ᵉ)) (lemma-dboxes-Z (vd)) ⟩
    pZ₀ ∎


  claim2 : act [ lm ]ˡᵐ (q1 ∷ q2 ∷ q3 ∷ qt) ≡ pX₀
  claim2 = begin
    act ([ m ]ᵐ • [ l ]ˡ') (q1 ∷ q2 ∷ q3 ∷ qt) ≡⟨ auto ⟩
    act ([ m ]ᵐ • [ p2 ∷ p3 ∷ pt ]ᵛᵇ • [ (p1 , λ ()) ]ᵃ) (q1 ∷ q2 ∷ q3 ∷ qt) ≡⟨ Eq.cong (act ([ m ]ᵐ • [ p2 ∷ p3 ∷ pt ]ᵛᵇ)) (lemma-abox-X p1 q1 (λ ()) (q2 ∷ q3 ∷ qt)) ⟩
    act ([ m ]ᵐ • [ p2 ∷ p3 ∷ pt ]ᵛᵇ) (se ∷ q2 ∷ q3 ∷ qt) ≡⟨ Eq.cong (act ([ m ]ᵐ)) (lemma-bboxes-X' se (p2 ∷ p3 ∷ pt) (q2 ∷ q3 ∷ qt)) ⟩
    act ([ m ]ᵐ) ttt ≡⟨ Eq.cong (act ([ m ]ᵐ)) (lemma-init-last ttt) ⟩
    act ([ m ]ᵐ) (init ttt ∷ʳ last ttt) ≡⟨ Eq.cong (\ xx -> act ([ m ]ᵐ) (init ttt ∷ʳ xx)) (lemma-act-bboxes-last' se ((p2 ∷ p3 ∷ pt) ) ((q2 ∷ q3 ∷ qt))) ⟩
    act ([ m ]ᵐ) (init ttt ∷ʳ (spq + sform (p2 ∷ p3 ∷ pt) (q2 ∷ q3 ∷ qt) , e)) ≡⟨ Eq.cong (\ xx -> act ([ m ]ᵐ) (init ttt ∷ʳ (xx , e))) sf=1 ⟩
    act ([ m ]ᵐ) (init ttt ∷ʳ (₁ , e)) ≡⟨ Eq.cong (act ([ e ]ᵉ)) (lemma-dboxes-XZ e (init ttt)) ⟩
    act ([ e ]ᵉ) (pX₀Z₀ e) ≡⟨ lemma-ebox-XZ e ⟩
    pX₀ ∎
    where
    t1 = act-bbox p2 se q2 (q3 ∷ qt)
    p1' = head t1
    q1' = head (tail t1)
    il = act-bboxes q1' (p3 ∷ pt) (q3 ∷ qt)
    b'' = q1' .proj₂
    a'' = q1' .proj₁
    spq'' = sform  (p3 ∷ pt) (q3 ∷ qt)




