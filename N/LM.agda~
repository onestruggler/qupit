{-# OPTIONS  --safe #-}
{-# OPTIONS --termination-depth=2 #-}
open import Level using (0ℓ)

open import Relation.Binary using (Rel)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Binary.Morphism.Definitions using (Homomorphic₂)
open import Relation.Binary.PropositionalEquality using (_≡_ ; _≢_ ; inspect ; setoid ; module ≡-Reasoning ; _≗_) renaming ([_] to [_]')
import Relation.Binary.Reasoning.Setoid as SR
import Relation.Binary.PropositionalEquality as Eq
open import Relation.Nullary.Decidable using (yes ; no)


open import Function using (_∘_ ; id)
open import Function.Definitions using (Injective)

open import Data.Product using (_×_ ; _,_ ; proj₁ ; proj₂ ; map₁ ; ∃ ; Σ ; Σ-syntax)
open import Data.Product.Relation.Binary.Pointwise.NonDependent as PW using (≡×≡⇒≡ ; Pointwise ; ≡⇒≡×≡)
open import Data.Nat hiding (_^_ ; _+_ ; _*_)
open import Agda.Builtin.Nat using (_-_)
import Data.Nat as Nat
open import Data.Bool hiding (_<_ ; _≤_)
open import Data.List hiding ([_] ; _++_ ; last ; head ; tail ; _∷ʳ_)
open import Data.Vec hiding ([_])
import Data.Vec as Vec
open import Data.Fin hiding (_+_ ; _-_ ; _≤_ ; _<_)

open import Data.Maybe
open import Data.Sum using (_⊎_ ; inj₁ ; inj₂ ; [_,_] ; [_,_]′)
open import Data.Unit using (⊤ ; tt)
open import Data.Empty using (⊥ ; ⊥-elim)

open import Word.Base as WB hiding (wfoldl ; _* ; _^'_)
open import Word.Properties
import Presentation.Base as PB
import Presentation.Properties as PP
open PP using (NFProperty ; NFProperty')
import Presentation.CosetNF as CA
import Presentation.Reidemeister-Schreier as RS
module RSF = RS.Star-Injective-Full.Reidemeister-Schreier-Full

open import Presentation.Construct.Base hiding (_*_ ; _⊕_)
import Presentation.Construct.Properties.SemiDirectProduct2 as SDP2
import Presentation.Construct.Properties.DirectProduct as DP
import Presentation.Groups.Cyclic as Cyclic


open import Data.Fin using (Fin ; toℕ ; suc ; zero ; fromℕ)
open import Data.Fin.Properties using (suc-injective ; toℕ-inject₁ ; toℕ-fromℕ)
import Data.Nat.Properties as NP
open import Presentation.GroupLike
open import Presentation.Tactics hiding ([_])
open import Data.Nat.Primality



module N.LM (p-2 : ℕ) (p-prime : Prime (2+ p-2))  where

pattern auto = Eq.refl

pattern ₀ = zero
pattern ₁ = suc ₀
pattern ₂ = suc ₁
pattern ₃ = suc ₂
pattern ₅ = 5
pattern ₆ = 6
pattern ₇ = 7
pattern ₈ = 8
pattern ₉ = 9
pattern ₁₀ = 10
pattern ₁₁ = 11
pattern ₁₂ = 12
pattern ₁₃ = 13
pattern ₁₄ = 14
pattern ₁₅ = 15

pattern ₁₊ ⱼ = suc ⱼ
pattern ₂₊ ⱼ = suc (suc ⱼ)
pattern ₃₊ ⱼ = suc (suc (suc ⱼ))
pattern ₄₊ ⱼ = suc (suc (suc (suc ⱼ)))


open import Zp.ModularArithmetic
open PrimeModulus p-2 p-prime
open import N.Cosets p-2 p-prime
open import N.Symplectic-Derived p-2 p-prime
open Symplectic-Derived-Gen renaming (M to ZM)
open import N.NF1 p-2 p-prime
open Normal-Form1

private
  variable
    n : ℕ


A : Set
A = Σ[ ab ∈ (ℤ ₚ × ℤ ₚ) ] (ab ≢ (₀ , ₀))

B : Set
B = ℤ ₚ × ℤ ₚ

D : Set
D = ℤ ₚ × ℤ ₚ

E : Set
E = ℤ ₚ

Lj : (j : ℕ) → Set
Lj j = Vec B j × A

-- Natural numbers that are less than (₁₊ n).
LE : (n : ℕ) → Set
LE n = Σ[ j ∈ ℕ ] j ≤ n

-- n-indexed boxes (L, M, LM, NF) is of n.
L : (n : ℕ) → Set
L 0 = ⊤
L 1 = A
L (₂₊ n) = Σ[ (j , le) ∈ LE (₁₊ n) ] Lj ((₁₊ n) ∸ j)

L' : ℕ → Set
L' 0 = ⊤
L' 1 = E
L' 2 = ⊤
L' (₂₊ n) = Vec B (₁₊ n) × A

M : ℕ → Set
M 0 = ⊤
M 1 = E
M (₂₊ n) = E × Vec D (₁₊ n)

open import N.NF2 p-2 p-prime
open LM2

LM : (n : ℕ) → Set
LM 0 = ⊤
LM 1 = NF1
LM 2 = Cosets2
LM n@(₃₊ x) = M n × L' n ⊎ D × LM (₂₊ x)


NF : (n : ℕ) → Set
NF 0 = ⊤
NF (₁₊ n) = LM (₁₊ n) × NF n

-- A box is MC.
[_]ᵃ : ∀ {n} → A → Word (Gen (₁₊ n))
[_]ᵃ {n} ((₀ , ₀), pr) = ⊥-elim (pr auto)
[_]ᵃ {n} ((₀ , b@(₁₊ b-1)), pr) = ⟦ (b , λ ()) ⁻¹ , ε ⟧ₘ₊
[_]ᵃ {n} ((a@(₁₊ a-1) , b), pr) = ⟦ (a , λ ()) ⁻¹ , HS^ -b/a ⟧ₘ₊
  where
  a⁻¹ = ((a , λ ()) ⁻¹) .proj₁
  -b/a = - b * a⁻¹

[_]ᵇ : ∀ {n} → B → Word (Gen (₂₊ n))
[_]ᵇ {n} (₀ , ₀) = Ex
[_]ᵇ {n} (a@₀ , b@(₁₊ b-1)) = XC • Ex • [ (a , b) , (λ ()) ]ᵃ ↑
[_]ᵇ {n} (a@(₁₊ a-1) , b) = XC • Ex • [ (a , b) , (λ ()) ]ᵃ ↑

[_]ᵈ : ∀ {n} → D → Word (Gen (₂₊ n))
[_]ᵈ {n} (₀ , d) = CZ^ (- d) • Ex
[_]ᵈ {n} (a@(₁₊ _) , b) = [ ₀ , ₁ ]ᵇ • [ (a , b) , (λ ()) ]ᵃ

[_]ᵉ : ∀ {n} → E → Word (Gen (₁₊ n))
[_]ᵉ {n} b = S^ b

[_]ᵛᵇ : ∀ {n} → Vec B n → Word (Gen (₁₊ n))
[_]ᵛᵇ {₀} [] = ε
[_]ᵛᵇ {suc n} (x ∷ v) = [ v ]ᵛᵇ ↑ • [ x ]ᵇ

[_]ᵛᵈ : ∀ {n} → Vec D n → Word (Gen (₁₊ n))
[_]ᵛᵈ {₀} [] = ε
[_]ᵛᵈ {suc n} (x ∷ v) = [ x ]ᵈ • [ v ]ᵛᵈ ↑

[_]ᵐ : ∀ {n} → M n → Word (Gen n)
[_]ᵐ {0} _ = ε
[_]ᵐ {1} e = [ e ]ᵉ
[_]ᵐ {₂₊ n} (e , vd) = [ vd ]ᵛᵈ

jth-abox : ∀ {j n} → j ≤ n → A → Word (Gen (₁₊ n))
jth-abox {₀} {n} _ a = [ a ]ᵃ
jth-abox {₁₊ j} {₁₊ n} (s≤s j≤n) a = jth-abox {j} {n} (j≤n) a ↑


jth-bbox : ∀ {j n} → j ≤ n → B → Word (Gen (₂₊ n))
jth-bbox {₀} {n} _ a = [ a ]ᵇ
jth-bbox {₁₊ j} {₁₊ n} (s≤s j≤n) a = jth-bbox {j} {n} (j≤n) a ↑

jth-dbox : ∀ {j n} → j ≤ n → B → Word (Gen (₂₊ n))
jth-dbox {₀} {n} _ a = [ a ]ᵈ
jth-dbox {₁₊ j} {₁₊ n} (s≤s j≤n) a = jth-dbox {j} {n} (j≤n) a ↑

jth-ebox : ∀ {j n} → j ≤ n → E → Word (Gen (₁₊ n))
jth-ebox {₀} {n} _ a = [ a ]ᵉ
jth-ebox {₁₊ j} {₁₊ n} (s≤s j≤n) a = jth-ebox {j} {n} (j≤n) a ↑

jth-bboxes : ∀ {j n} → j ≤ n → Vec B (n ∸ j) → Word (Gen (₁₊ n))
jth-bboxes {₀} {n} j≤n v = [ v ]ᵛᵇ
jth-bboxes {₁₊ j} {₁₊ n} (s≤s j≤n) (v) = jth-bboxes j≤n v ↑

lemma-jth-bboxes : ∀ {n} (vb : Vec B n) → jth-bboxes (z≤n {n}) vb ≡ [ vb ]ᵛᵇ
lemma-jth-bboxes {₀} vb = auto
lemma-jth-bboxes {₁₊ j} vb = auto

jth-babox : ∀ {j n} → j ≤ n → Vec B (n ∸ j) -> A → Word (Gen (₁₊ n))
jth-babox {₀} {n} j≤n v a = [ v ]ᵛᵇ • jth-abox j≤n a
jth-babox {₁₊ j} {₁₊ n} (s≤s j≤n) v a = jth-babox j≤n v a ↑

[_]ˡ : ∀ {n} → L n → Word (Gen n)
[_]ˡ {0} _ = ε
[_]ˡ {1} a = [ a ]ᵃ
[_]ˡ {₂₊ n} ((j , j≤n) , bs , a) = jth-babox j≤n bs a

[_]ˡ' : ∀ {n} → L' n → Word (Gen n)
[_]ˡ' {0} l = ε
[_]ˡ' {1} l = [ l ]ᵉ
[_]ˡ' {2} l = ε
[_]ˡ' {₃₊ n} (vb , a) = [ vb ]ᵛᵇ • [ a ]ᵃ

[_]ˡᵐ : ∀ {n} → LM n → Word (Gen n)
[_]ˡᵐ {0} _ = ε
[_]ˡᵐ {1} lm1 = ⟦ lm1 ⟧₁
[_]ˡᵐ {2} lm2 = ⟦ lm2 ⟧₂
[_]ˡᵐ {₃₊ n} (inj₁ (m , l)) = [ m ]ᵐ • [ l ]ˡ'
[_]ˡᵐ {₃₊ n} (inj₂ (d , lm)) = [ d ]ᵈ • [ lm ]ˡᵐ ↑

[_] : ∀ {n} → NF n → Word (Gen n)
[_] {0} tt = ε
[_] {₁₊ n} (lm , nf) = [ lm ]ˡᵐ • [ nf ] ↑


data BoxType : Set where
  ᵃ : BoxType
  ᵇ : BoxType
  ᵈ : BoxType
  ᵉ : BoxType
  ˡ : BoxType
  ˡ' : BoxType
  ᵐ : BoxType
  ˡᵐ : BoxType
  ᵛᵇ : BoxType
  ᵛᵈ : BoxType
  ⁿᶠ : BoxType

Box : ∀ {n : ℕ} -> BoxType -> Set
Box ᵃ = A
Box ᵇ = B
Box ᵈ = D
Box ᵉ = E
Box {n} ˡ = L n
Box {n} ˡ' = L' n
Box {n} ᵐ = M n
Box {n} ˡᵐ = LM n
Box {n} ᵛᵇ = Vec B n
Box {n} ᵛᵈ = Vec D n
Box {n} ⁿᶠ = NF n

BIndex : BoxType -> Rel ℕ 0ℓ
BIndex ᵃ = _≤_
BIndex ᵉ = _≤_
BIndex ᵇ = _<_
BIndex ᵈ = _<_
BIndex _ = \ _ _ -> ⊤

BWidth : BoxType -> ℕ
BWidth ⁿᶠ = 0
BWidth ˡ = 0
BWidth ˡ' = 0
BWidth ᵐ = 0
BWidth ˡᵐ = 0
BWidth ᵇ = 2
BWidth ᵈ = 2
BWidth _ = 1

-- A unified way to call all box interpretation.
⟦_⟧ : ∀ {j n} (bt : BoxType) -> Box {n} bt -> BIndex bt j n -> Word (Gen (BWidth bt Nat.+ n))
⟦_⟧ {j} {n} ᵃ x j≤n = jth-abox j≤n x
⟦_⟧ {j} {₁₊ n} ᵇ x j<n = jth-bbox j<n x
⟦_⟧ {j} {n} ᵈ x j<n = jth-dbox j<n x
⟦_⟧ {j} {n} ᵉ x j≤n = jth-ebox j≤n x
⟦_⟧ {j} {n} ˡ x j≤n = [ x ]ˡ
⟦_⟧ {j} {n} ˡ' x j≤n = [ x ]ˡ'
⟦_⟧ {j} {n} ᵐ x j≤n = [ x ]ᵐ
⟦_⟧ {j} {n} ˡᵐ x j≤n = [ x ]ˡᵐ
⟦_⟧ {j} {n} ᵛᵇ x j≤n = [ x ]ᵛᵇ
⟦_⟧ {j} {n} ᵛᵈ x j≤n = [ x ]ᵛᵈ
⟦_⟧ {j} {n} ⁿᶠ x j≤n = [ x ]

--open import N.Pauli p-2 p-prime
open import N.Action p-2 p-prime
open import Algebra.Properties.Ring (+-*-ring p-2)

sfrom-pIq=0 : ∀ x -> sform1 pI x ≡ ₀
sfrom-pIq=0 x@(c , d) = begin
  sform1 pI x ≡⟨ auto ⟩
  - ₀ * d + c * ₀ ≡⟨ Eq.cong₂ (\ xx yy -> xx * d + yy) -0#≈0# (*-zeroʳ c) ⟩
  ₀ * d + ₀ ≡⟨ +-identityʳ (₀ * d) ⟩
  ₀ * d ≡⟨ *-zeroˡ d ⟩
  ₀ ∎
  where
  open ≡-Reasoning

lemma-act-Ex : ∀ p q t ->
  act {₂₊ n} Ex (p ∷ q ∷ t) ≡ (q ∷ p ∷ t)
lemma-act-Ex p q t = act-Ex (p .proj₁) (p .proj₂) (q .proj₁) (q .proj₂) t

-- lemma-abox' : ∀ (ab@((a , b), neqI) : A) t ->
--   act [ (a , b) , neqI ]ᵃ ((a , b) ∷ t) ≡ {!!}

lemma-abox-01 : ∀ (ps : Pauli (₁₊ n)) →
  act [ (₀ , ₁) , (λ ()) ]ᵃ ps ≡ ps
lemma-abox-01 ps@((a , b) ∷ t) = begin
  act [ (₀ , ₁) , (λ ()) ]ᵃ ps ≡⟨ auto ⟩
  act ⟦ (₁ , λ ()) ⁻¹ , ε ⟧ₘ₊ ps ≡⟨ auto ⟩
  act ⟦ (₁ , λ ()) ⁻¹ ⟧ₘ ps ≡⟨ lemma-M a b t ((₁ , λ ()) ⁻¹) ⟩
  (a * x⁻¹ , b * x) ∷ t ≡⟨ Eq.cong₂ (λ xx yy → (a * xx , b * yy) ∷ t) aux-inv1 inv-₁ ⟩
  (a * ₁ , b * ₁) ∷ t ≡⟨ Eq.cong₂ (\ xx yy -> (xx , yy) ∷ t) (*-identityʳ a) (*-identityʳ b) ⟩
  ps ∎
  where
  open ≡-Reasoning
  x' = (₁ , λ ()) ⁻¹
  x = (x' .proj₁)
  x⁻¹ = ((x' ⁻¹) .proj₁)
  aux-inv1 : x⁻¹ ≡ ₁
  aux-inv1 = Eq.trans (inv-cong (x' ) ((₁ , λ ())) inv-₁) inv-₁
  


lemma-abox : ∀ p (neqI : p ≢ pI)(ps : Pauli n) →
  act [ p , neqI ]ᵃ (p ∷ ps) ≡ (pZ ∷ ps)
lemma-abox (₀ , ₀) neqI ps = ⊥-elim (neqI auto)
lemma-abox (₀ , b@(₁₊ b')) neqI ps = begin
  act ⟦ (b , λ ()) ⁻¹ , ε ⟧ₘ₊ ((₀ , ₁₊ b') ∷ ps) ≡⟨ auto ⟩
  act ⟦ (b , λ ()) ⁻¹ ⟧ₘ ((₀ , ₁₊ b') ∷ ps) ≡⟨ lemma-M ₀ b ps ((b , λ ()) ⁻¹) ⟩
  (₀ * x⁻¹ , (₁₊ b') * x) ∷ ps ≡⟨ Eq.cong₂ (\ xx yy -> (xx , yy) ∷ ps) (*-zeroˡ x⁻¹) (lemma-⁻¹ʳ b {{nztoℕ {y = b} {neq0 = λ ()}}}) ⟩
  pZ ∷ ps ∎
  where
  open ≡-Reasoning
  x = ((b , λ ()) ⁻¹) .proj₁
  x⁻¹ = ((b , λ ()) ⁻¹ ⁻¹) .proj₁
  
lemma-abox (a@(₁₊ a') , b) neqI ps = begin
  act ⟦ (a , λ ()) ⁻¹ , HS^ -b/a ⟧ₘ₊ ((a , b) ∷ ps) ≡⟨ auto ⟩
  act ⟦ (a , λ ()) ⁻¹ ⟧ₘ (act ⟦ HS^ -b/a ⟧ₕₛ ((a , b) ∷ ps)) ≡⟨ Eq.cong (act ⟦ (a , λ ()) ⁻¹ ⟧ₘ) (lemma-HS-x -b/a a b ps) ⟩
  act ⟦ (a , λ ()) ⁻¹ ⟧ₘ ((- (b + a * -b/a) , a) ∷ ps) ≡⟨ Eq.cong (\ xx -> act ⟦ (a , λ ()) ⁻¹ ⟧ₘ ((xx , a) ∷ ps)) (Eq.trans (Eq.cong -_ aux) -0#≈0#) ⟩
  act ⟦ (a , λ ()) ⁻¹ ⟧ₘ ((₀ , a) ∷ ps) ≡⟨ lemma-M ₀ a ps ((a , λ ()) ⁻¹) ⟩
  (₀ * a⁻¹⁻¹  , a * a⁻¹) ∷ ps ≡⟨ Eq.cong (\ xx -> (₀ * a⁻¹⁻¹  , xx) ∷ ps) (lemma-⁻¹ʳ a {{nztoℕ {y = a} {neq0 = λ ()}}}) ⟩
  pZ ∷ ps ∎
  where
  open ≡-Reasoning
  a⁻¹ = ((a , λ ()) ⁻¹) .proj₁
  a⁻¹⁻¹ = ((a , λ ()) ⁻¹ ⁻¹) .proj₁
  -b/a = - b * a⁻¹
  aux : b + a * -b/a ≡ ₀
  aux = begin
    b + a * -b/a ≡⟨ Eq.cong (\ xx -> b + a * xx) (*-comm (- b) a⁻¹) ⟩
    b + a * (a⁻¹ * - b) ≡⟨ Eq.cong (b +_) (Eq.sym (*-assoc a a⁻¹ (- b))) ⟩
    b + a * a⁻¹ * - b ≡⟨ Eq.cong (\ xx -> b + xx * - b) (lemma-⁻¹ʳ a {{nztoℕ {y = a} {neq0 = λ ()}}}) ⟩
    b + ₁ * - b ≡⟨ Eq.cong (b +_) (*-identityˡ (- b)) ⟩
    b + - b ≡⟨ +-inverseʳ b ⟩
    ₀ ∎


lemma-dbox-IZ : ∀ d (t : Pauli n) -> act [ d ]ᵈ (pI ∷ pZ ∷ t) ≡ (pZ ∷ pI ∷ t)
lemma-dbox-IZ {n} (₀ , d) t = begin
  act [ ₀ , d ]ᵈ (pI ∷ pZ ∷ t) ≡⟨ auto ⟩
  act (CZ^ (- d) • Ex) (pI ∷ pZ ∷ t) ≡⟨ auto ⟩
  act (CZ^ (- d)) (act Ex (pI ∷ pZ ∷ t)) ≡⟨ Eq.cong (act (CZ^ (- d)) ) (lemma-act-Ex pI pZ t) ⟩
  act (CZ^ (- d)) (pZ ∷ pI ∷ t) ≡⟨ auto ⟩
  ((₀ , ₁ + ₀ * (- d)) ∷ (₀ , ₀ + ₀ * (- d)) ∷ t) ≡⟨ Eq.cong (\ xx -> ((₀ , ₁ + xx) ∷ (₀ , ₀ + xx) ∷ t)) (*-zeroˡ (- d)) ⟩
  ((₀ , ₁ + ₀) ∷ (₀ , ₀ + ₀) ∷ t) ≡⟨ auto ⟩
  (pZ ∷ pI ∷ t) ∎
  where
  open ≡-Reasoning
lemma-dbox-IZ {n} (c@(₁₊ c') , d) t = begin
  act [ c , d ]ᵈ (pI ∷ pZ ∷ t) ≡⟨ {!!} ⟩
  act ([ ₀ , ₁ ]ᵇ • [ (c , d) , (λ ()) ]ᵃ) (pI ∷ pZ ∷ t) ≡⟨ {!!} ⟩
  act ([ ₀ , ₁ ]ᵇ • ⟦ (c , λ ()) ⁻¹ , HS^ -d/c ⟧ₘ₊) (pI ∷ pZ ∷ t) ≡⟨ Eq.cong (act ([ ₀ , ₁ ]ᵇ • ⟦ (c , λ ()) ⁻¹ ⟧ₘ)) (lemma-HS-x -d/c ₀ ₀ (pZ ∷ t)) ⟩
  act ([ ₀ , ₁ ]ᵇ • ⟦ (c , λ ()) ⁻¹ ⟧ₘ) ((- (₀ + ₀ * -d/c) , ₀) ∷ pZ ∷ t) ≡⟨ {!!} ⟩
  act ([ ₀ , ₁ ]ᵇ • ⟦ (c , λ ()) ⁻¹ ⟧ₘ) ((₀ , ₀) ∷ pZ ∷ t) ≡⟨ {!!} ⟩
  act ([ ₀ , ₁ ]ᵇ) ((₀ * c⁻¹⁻¹ , ₀ * c⁻¹) ∷ pZ ∷ t) ≡⟨ {!!} ⟩
  act ([ ₀ , ₁ ]ᵇ) ((₀ , ₀) ∷ pZ ∷ t) ≡⟨ {!!} ⟩
  act (XC • Ex • [ (₀ , ₁) , (λ ()) ]ᵃ ↑) ((₀ , ₀) ∷ pZ ∷ t) ≡⟨ {!!} ⟩
  act (XC • Ex) (pI ∷ act [ (₀ , ₁) , (λ ()) ]ᵃ (pZ ∷ t) ≡⟨ {!!} ⟩
  act [ ₀ , ₁ ]ᵇ (pI ∷ pZ ∷ t) ≡⟨ {!!} ⟩
  (pZ ∷ pI ∷ t) ∎
  where
  open ≡-Reasoning
  c⁻¹ = ((c , λ ()) ⁻¹) .proj₁
  c⁻¹⁻¹ = ((c , λ ()) ⁻¹ ⁻¹) .proj₁
  -d/c = - d * c⁻¹
  aux : - (₀ + ₀ * -d/c) ≡ ₀
  aux = begin
    - (₀ + ₀ * -d/c) ≡⟨ {!!} ⟩
    - (₀ + ₀) ≡⟨ {!!} ⟩
    ₀ ∎

{-
Theorem-LM :

  ∀ (p q : Pauli n) ->
  sform p q ≡ ₁ ->
  -------------------------------
  ∃ \ lm -> act [ lm ]ˡᵐ p ≡ pZ₀ ×
            act [ lm ]ˡᵐ q ≡ pX₀

Theorem-LM {0} [] [] sf=1 = ⊥-elim (0ₚ≢1ₚ sf=1)
Theorem-LM {1} (p ∷ []) (q ∷ []) sf=1 = Theorem-NF1 p q [] sf=1'
  where
  sf=1' : sform1 p q ≡ ₁
  sf=1' rewrite +-identityʳ (sform1 p q) = sf=1
Theorem-LM {2} ps@(p1 ∷ p2 ∷ []) qs@(q1 ∷ q2 ∷ []) sf=1 = Theorem-LM2 ps qs [] sf=1
Theorem-LM {3} ps@(p1@(₀ , ₀) ∷ p2 ∷ p3 ∷ []) qs@(q1 ∷ q2 ∷ q3 ∷ []) sf=1 = lm , {!!}
  where
  open ≡-Reasoning
  sf=1' : sform (p2 ∷ p3 ∷ []) (q2 ∷ q3 ∷ []) ≡ ₁
  sf=1' = begin
    sform (p2 ∷ p3 ∷ []) (q2 ∷ q3 ∷ []) ≡⟨ Eq.sym (+-identityˡ (sform (p2 ∷ p3 ∷ []) (q2 ∷ q3 ∷ []))) ⟩
    ₀ + sform (p2 ∷ p3 ∷ []) (q2 ∷ q3 ∷ []) ≡⟨ Eq.cong (_+ sform (p2 ∷ p3 ∷ []) (q2 ∷ q3 ∷ [])) (Eq.sym (sfrom-pIq=0 q1)) ⟩
    sform1 p1 q1 + sform (p2 ∷ p3 ∷ []) (q2 ∷ q3 ∷ []) ≡⟨ auto ⟩
    sform (p1 ∷ p2 ∷ p3 ∷ []) (q1 ∷ q2 ∷ q3 ∷ []) ≡⟨ sf=1 ⟩
    ₁ ∎
    
  ih = Theorem-LM {2} (p2 ∷ p3 ∷ []) (q2 ∷ q3 ∷ []) sf=1'
  lm2 = ih .proj₁
  lm : LM 3
  lm = inj₂ (q1 , ih .proj₁)
  
  claim1 : act [ lm ]ˡᵐ ps ≡ pZ₀
  claim1 = begin
    act [ lm ]ˡᵐ ps ≡⟨ auto ⟩
    act ([ q1 ]ᵈ • ⟦ lm2 ⟧₂ ↑) ps ≡⟨ auto ⟩
    act [ q1 ]ᵈ (act (⟦ lm2 ⟧₂ ↑) ps) ≡⟨ Eq.cong (act [ q1 ]ᵈ) (lemma-act-↑ ⟦ lm2 ⟧₂ pI (p2 ∷ p3 ∷ [])) ⟩
    act [ q1 ]ᵈ (pI ∷ act {2} ⟦ lm2 ⟧₂ (p2 ∷ p3 ∷ [])) ≡⟨ Eq.cong (\ xx -> act [ q1 ]ᵈ (pI ∷ xx)) (ih .proj₂ .proj₁) ⟩
    act [ q1 ]ᵈ (pI ∷ pZ ∷ pI ∷ []) ≡⟨ {!!} ⟩
    act [ q1 ]ᵈ (pI ∷ pZ ∷ pI ∷ []) ≡⟨ {!!} ⟩
    pZ₀ ∎
  
  
Theorem-LM {₃₊ n} ps@(p1 ∷ p2 ∷ p3 ∷ pt) qs@(q1 ∷ q2 ∷ q3 ∷ qt) sf=1 = {!!}

-}

{-

E' = E

F : Set
F = ℤ ₚ × ℤ ₚ

G : Set
G = ℤ* ₚ × ℤ ₚ

-- F sends XᵃZᵇ to Zᵃ if a ≠ 0, otherwise F is identity.
[_]ᶠ : ∀ {n} → F → Word (Gen (₁₊ n))
[_]ᶠ {n} (₀ , _) = ε
--  [_]ᶠ {n} (x@(₁₊ _) , ₀) = H
[_]ᶠ {n} (x@(₁₊ _) , y) = H • S ^ k
  where
  k = toℕ (- y * x ⁻¹)

-- G sends X¹⁺ᵃZᵇ to X.
[_]ᵍ : ∀ {n} → G → Word (Gen (₁₊ n))
[_]ᵍ {n} (a , b) = (H ^ 2) ^ h • S ^ k
  where
  h = toℕ a
  k = toℕ (- b * (₁₊ a) ⁻¹)

-- NOTE: [ G ]ᵍ × [ F ]ᶠ ≈ Sp(1,3)

[_]ᵉ' : ∀ {n} → E' → Word (Gen (₂₊ n))
[_]ᵉ' {n} b = CZ ^ toℕ b

-}




{-
sform1-antisym' : ∀ (p q : Pauli1) -> sform1 p q ≡ - sform1 q p
sform1-antisym' p@(a , b) q@(c , d) = begin
  sform1 (a , b) (c , d) ≡⟨ solve p-2 {!4!} {!!} {!!} ⟩
  (- a) * d + c * b ≡⟨ {!\ a b c d -> (solve p-2 4 ? ?)!} ⟩
  - ((- c) * b + a * d) ≡⟨ solve p-2 {!4!} {!!} {!!} ⟩
  - sform1 (c , d) (a , b) ∎
  where
  open ≡-Reasoning
  aux2 : ∀ a b c d e -> - e * ((a) * d + c * b) ≡ - e * (c * b + (a) * d)
  aux2 = solve p-2 5 (\ a b c d e -> (⊝ e) ⊗ ((a) ⊗ d ⊕ c ⊗ b) , (⊝ e) ⊗ (c ⊗ b ⊕ (a) ⊗ d)) λ {x} {x = x₁} {x = x₂} {x = x₃} {x = x₄} → Eq.refl

  aux3 : ∀ a b -> a * b ≡ b * a
  aux3 = solve p-2 2 (\ a b -> a ⊗ b , b ⊗ a) λ {x} {x = x₁} → Eq.refl

-}

--module Two-Qupit-Completeness where

{-
  aux1 : ∀ (p : Pauli 1) -> sform pIₙ p ≡ 0
  aux1 p = {!!}

  Theorem-NF :

    ∀ (p q : Pauli 1) ->
    sform p q ≡ 1 ->
    -------------------------------
    ∃ \ nf -> act ⟦ nf ⟧ p ≡ pZ₀ ×
              act ⟦ nf ⟧ q ≡ pX₀

  Theorem-NF p@((₀ , ₀) ∷ []) q@(q1 ∷ []) eq with 0ₚ≢1ₚ (Eq.trans (Eq.sym (aux1 q)) eq)
  ... | ()
  Theorem-NF p@((₀ , ₁₊ b) ∷ []) q@((₀ , ₀) ∷ []) eq = {!!}
  Theorem-NF p@((₀ , ₁₊ b) ∷ []) q@((₀ , ₁₊ d) ∷ []) eq = {!!}
  Theorem-NF p@((₀ , ₁₊ b) ∷ []) q@((₁₊ c , ₀) ∷ []) eq = {!!}
  Theorem-NF p@((₀ , ₁₊ b) ∷ []) q@((₁₊ c , ₁₊ d) ∷ []) eq = {!!}
  Theorem-NF p@((₁₊ a , ₀) ∷ []) q@((₀ , ₀) ∷ []) eq = {!!}
  Theorem-NF p@((₁₊ a , ₀) ∷ []) q@((₀ , ₁₊ d) ∷ []) eq = {!!}
  Theorem-NF p@((₁₊ a , ₀) ∷ []) q@((₁₊ c , ₀) ∷ []) eq = {!!}
  Theorem-NF p@((₁₊ a , ₀) ∷ []) q@((₁₊ c , ₁₊ d) ∷ []) eq = {!!}
  Theorem-NF p@((₁₊ a , ₁₊ b) ∷ []) q@((₀ , ₀) ∷ []) eq = {!!}
  Theorem-NF p@((₁₊ a , ₁₊ b) ∷ []) q@((₀ , ₁₊ d) ∷ []) eq = {!!}
  Theorem-NF p@((₁₊ a , ₁₊ b) ∷ []) q@((₁₊ c , ₀) ∷ []) eq = {!!}
  Theorem-NF p@((₁₊ a , ₁₊ b) ∷ []) q@((₁₊ c , ₁₊ d) ∷ []) eq = {!!}
-}

{-
prop-abox : ∀ {n} (p : Pauli1) (p≢I : p ≢ pI) (ps : Pauli n) → 
  act [ p , p≢I ]ᵃ (p ∷ ps) ≡ (₀ , ₁) ∷ ps
prop-abox (₀ , ₀) p≢I ps with p≢I auto
... | ()
prop-abox (₀ , ₁) p≢I ps = auto
prop-abox (₀ , ₂) p≢I ps = auto
prop-abox (₁ , ₀) p≢I ps = auto
prop-abox (₁ , ₁) p≢I ps = auto
prop-abox (₁ , ₂) p≢I ps = auto
prop-abox (₂ , ₀) p≢I ps = auto
prop-abox (₂ , ₁) p≢I ps = auto
prop-abox (₂ , ₂) p≢I ps = auto

neqeq : ∀ x → x ≢ pI ⊎ x ≡ pI
neqeq (₀ , ₀) = inj₂ auto
neqeq (₀ , ₁) = inj₁ (λ ())
neqeq (₀ , ₂) = inj₁ (λ ())
neqeq (₁ , ₀) = inj₁ (λ ())
neqeq (₁ , ₁) = inj₁ (λ ())
neqeq (₁ , ₂) = inj₁ (λ ())
neqeq (₂ , ₀) = inj₁ (λ ())
neqeq (₂ , ₁) = inj₁ (λ ())
neqeq (₂ , ₂) = inj₁ (λ ())



prop-abox-↓ : ∀ {n} (p : Pauli1) (p≢I : p ≢ pI) (ps : Pauli (₁₊ n)) → 
  act ([ p , p≢I ]ᵃ ↓) (p ∷ ps) ≡ (₀ , ₁) ∷ ps
prop-abox-↓ (₀ , ₀) p≢I ps with p≢I auto
... | ()
prop-abox-↓ (₀ , ₁) p≢I ps = auto
prop-abox-↓ (₀ , ₂) p≢I ps = auto
prop-abox-↓ (₁ , ₀) p≢I ps = auto
prop-abox-↓ (₁ , ₁) p≢I ps = auto
prop-abox-↓ (₁ , ₂) p≢I ps = auto
prop-abox-↓ (₂ , ₀) p≢I ps = auto
prop-abox-↓ (₂ , ₁) p≢I ps = auto
prop-abox-↓ (₂ , ₂) p≢I ps = auto

lemma-[]ᵃ : ∀ {n} a → ([_]ᵃ {n} a ↓) ≡ [ a ]ᵃ
lemma-[]ᵃ ((₀ , ₀) , p≢I) with p≢I auto
... | ()
lemma-[]ᵃ ((₀ , ₁) , p≢I) = auto
lemma-[]ᵃ ((₀ , ₂) , p≢I) = auto
lemma-[]ᵃ ((₁ , ₀) , p≢I) = auto
lemma-[]ᵃ ((₁ , ₁) , p≢I) = auto
lemma-[]ᵃ ((₁ , ₂) , p≢I) = auto
lemma-[]ᵃ ((₂ , ₀) , p≢I) = auto
lemma-[]ᵃ ((₂ , ₁) , p≢I) = auto
lemma-[]ᵃ ((₂ , ₂) , p≢I) = auto


lemma-abox-a : ∀ {n} a → (abox (NP.≤-reflexive {n} auto) a) ≡ [ a ]ᵃ
lemma-abox-a {₀} ((₀ , ₀) , p≢I) with p≢I auto
... | ()
lemma-abox-a {₀} ((₀ , ₁) , p≢I) = auto
lemma-abox-a {₀} ((₀ , ₂) , p≢I) = auto
lemma-abox-a {₀} ((₁ , ₀) , p≢I) = auto
lemma-abox-a {₀} ((₁ , ₁) , p≢I) = auto
lemma-abox-a {₀} ((₁ , ₂) , p≢I) = auto
lemma-abox-a {₀} ((₂ , ₀) , p≢I) = auto
lemma-abox-a {₀} ((₂ , ₁) , p≢I) = auto
lemma-abox-a {₀} ((₂ , ₂) , p≢I) = auto
lemma-abox-a {₁₊ n} a = begin
  (abox (NP.≤-reflexive auto) a ↓) ≡⟨ Eq.cong _↓ (lemma-abox-a a) ⟩
  ( [ a ]ᵃ ↓) ≡⟨ lemma-[]ᵃ a ⟩
  [ a ]ᵃ ∎
  where open ≡-Reasoning

{-
prop-abox-↓↓ : ∀ {j n} (p : Pauli1) (p≢I : p ≢ pI) (le : j ≤ n) (ps : Pauli n) → 
  act (abox le (p , p≢I)) (p ∷ ps) ≡ (₀ , ₁) ∷ ps
prop-abox-↓↓ (₀ , ₀) p≢I le ps with p≢I auto
... | ()
prop-abox-↓↓ (₀ , ₁) p≢I le ps = {!!}
prop-abox-↓↓ (₀ , ₂) p≢I le ps = {!!}
prop-abox-↓↓ (₁ , ₀) p≢I le ps = {!!}
prop-abox-↓↓ (₁ , ₁) p≢I le ps = {!!}
prop-abox-↓↓ (₁ , ₂) p≢I le ps = {!!}
prop-abox-↓↓ (₂ , ₀) p≢I le ps = {!!}
prop-abox-↓↓ (₂ , ₁) p≢I le ps = {!!}
prop-abox-↓↓ (₂ , ₂) p≢I le ps = {!!}
-}

prop-bbox : ∀ {n} (p : Pauli1) (ps : Pauli n) → act [ p ]ᵇ (pZ ∷ p ∷ ps) ≡ pI ∷ pZ ∷ ps
prop-bbox (₀ , ₀) ps = auto
prop-bbox (₀ , ₁) ps = auto
prop-bbox (₀ , ₂) ps = auto
prop-bbox (₁ , ₀) ps = auto
prop-bbox (₁ , ₁) ps = auto
prop-bbox (₁ , ₂) ps = auto
prop-bbox (₂ , ₀) ps = auto
prop-bbox (₂ , ₁) ps = auto
prop-bbox (₂ , ₂) ps = auto

prop-dbox : ∀ {n} (p : Pauli1) (ps : Pauli n) → act [ p ]ᵈ (p ∷ pX ∷ ps) ≡ pX ∷ pI ∷ ps
prop-dbox (₀ , ₀) ps = auto
prop-dbox (₀ , ₁) ps = auto
prop-dbox (₀ , ₂) ps = auto
prop-dbox (₁ , ₀) ps = auto
prop-dbox (₁ , ₁) ps = auto
prop-dbox (₁ , ₂) ps = auto
prop-dbox (₂ , ₀) ps = auto
prop-dbox (₂ , ₁) ps = auto
prop-dbox (₂ , ₂) ps = auto


prop-dbox-XZᵇ : ∀ {n} (p : Pauli1) (ᵇ : ℤ ₚ) (ps : Pauli n) → act [ p ]ᵈ (p ∷ pXZ ᵇ ∷ ps) ≡ pXZ ᵇ ∷ pI ∷ ps
prop-dbox-XZᵇ (₀ , ₀) ₀ ps = auto
prop-dbox-XZᵇ (₀ , ₀) ₁ ps = auto
prop-dbox-XZᵇ (₀ , ₀) ₂ ps = auto
prop-dbox-XZᵇ (₀ , ₁) ₀ ps = auto
prop-dbox-XZᵇ (₀ , ₁) ₁ ps = auto
prop-dbox-XZᵇ (₀ , ₁) ₂ ps = auto
prop-dbox-XZᵇ (₀ , ₂) ₀ ps = auto
prop-dbox-XZᵇ (₀ , ₂) ₁ ps = auto
prop-dbox-XZᵇ (₀ , ₂) ₂ ps = auto
prop-dbox-XZᵇ (₁ , ₀) ₀ ps = auto
prop-dbox-XZᵇ (₁ , ₀) ₁ ps = auto
prop-dbox-XZᵇ (₁ , ₀) ₂ ps = auto
prop-dbox-XZᵇ (₁ , ₁) ₀ ps = auto
prop-dbox-XZᵇ (₁ , ₁) ₁ ps = auto
prop-dbox-XZᵇ (₁ , ₁) ₂ ps = auto
prop-dbox-XZᵇ (₁ , ₂) ₀ ps = auto
prop-dbox-XZᵇ (₁ , ₂) ₁ ps = auto
prop-dbox-XZᵇ (₁ , ₂) ₂ ps = auto
prop-dbox-XZᵇ (₂ , ₀) ₀ ps = auto
prop-dbox-XZᵇ (₂ , ₀) ₁ ps = auto
prop-dbox-XZᵇ (₂ , ₀) ₂ ps = auto
prop-dbox-XZᵇ (₂ , ₁) ₀ ps = auto
prop-dbox-XZᵇ (₂ , ₁) ₁ ps = auto
prop-dbox-XZᵇ (₂ , ₁) ₂ ps = auto
prop-dbox-XZᵇ (₂ , ₂) ₀ ps = auto
prop-dbox-XZᵇ (₂ , ₂) ₁ ps = auto
prop-dbox-XZᵇ (₂ , ₂) ₂ ps = auto


prop-ebox : ∀ {n} (b : ℤ ₚ) (p : Pauli n) → 
  act [ - b ]ᵉ ((₁ , b) ∷ p) ≡ (₁ , ₀) ∷ p
prop-ebox {n} ₀ p = auto
prop-ebox {n} ₁ p = auto
prop-ebox {n} ₂ p = auto

prop-ebox-dual : ∀ {n} (b : ℤ ₚ) → 
  act ([_]ᵉ {n} b) pZ₀ ≡ pZ₀
prop-ebox-dual {₀} ₀ = auto
prop-ebox-dual {₀} ₁ = auto
prop-ebox-dual {₀} ₂ = auto
prop-ebox-dual {₁₊ n} ₀ = auto
prop-ebox-dual {₁₊ n} ₁ = auto
prop-ebox-dual {₁₊ n} ₂ = auto

prop-dbox-Z : ∀ {n} (p : Pauli1) (ps : Pauli n) → act [ p ]ᵈ (pI ∷ pZ ∷ ps) ≡ pZ ∷ pI ∷ ps
prop-dbox-Z (₀ , ₀) ps = auto
prop-dbox-Z (₀ , ₁) ps = auto
prop-dbox-Z (₀ , ₂) ps = auto
prop-dbox-Z (₁ , ₀) ps = auto
prop-dbox-Z (₁ , ₁) ps = auto
prop-dbox-Z (₁ , ₂) ps = auto
prop-dbox-Z (₂ , ₀) ps = auto
prop-dbox-Z (₂ , ₁) ps = auto
prop-dbox-Z (₂ , ₂) ps = auto

prop-dbox-I : ∀ {n} (p : Pauli1) (ps : Pauli n) → act [ p ]ᵈ (pI ∷ pI ∷ ps) ≡ pI ∷ pI ∷ ps
prop-dbox-I (₀ , ₀) ps = auto
prop-dbox-I (₀ , ₁) ps = auto
prop-dbox-I (₀ , ₂) ps = auto
prop-dbox-I (₁ , ₀) ps = auto
prop-dbox-I (₁ , ₁) ps = auto
prop-dbox-I (₁ , ₂) ps = auto
prop-dbox-I (₂ , ₀) ps = auto
prop-dbox-I (₂ , ₁) ps = auto
prop-dbox-I (₂ , ₂) ps = auto


prop-dboxes : ∀ {n} (vd : Vec D n) → act [ vd ]ᵛᵈ (pZₙ) ≡ pZ₀
prop-dboxes {₀} [] = auto
prop-dboxes {₁} (x ∷ []) = prop-dbox-Z x pIₙ
prop-dboxes {₂₊ n} vd@(x ∷ ds) = begin
  act [ vd ]ᵛᵈ (pI ∷ pI ∷ pZₙ) ≡⟨ auto ⟩
  act [ x ]ᵈ  (act ([ ds ]ᵛᵈ ↑) (pI ∷ pI ∷ pZₙ)) ≡⟨ Eq.cong (act [ x ]ᵈ) (lemma-act-↑ [ ds ]ᵛᵈ pI (pI ∷ pZₙ)) ⟩
  act [ x ]ᵈ  (pI ∷ act [ ds ]ᵛᵈ (pI ∷ pZₙ)) ≡⟨ Eq.cong (\ □ → act [ x ]ᵈ  (pI ∷ □)) (prop-dboxes ds) ⟩
  act [ x ]ᵈ  (pI ∷ (pZ ∷ pIₙ)) ≡⟨ prop-dbox-Z x pIₙ ⟩
  pZ ∷ (₀ , ₀) ∷ (₀ , ₀) ∷ pIₙ ∎
  where open ≡-Reasoning

last-∷ : ∀ {n}{A : Set}{a : A} {as : Vec A (₁₊ n)} → last (a ∷ as) ≡ last as
last-∷ {₀} {A} {a} {x ∷ []} = auto
last-∷ {₁₊ n} {A} {a} {x ∷ x₁ ∷ as} rewrite last-∷ {n} {A} {a} {x₁ ∷ as} = ih
  where
  ih = last-∷ {n} {A} {a} {x₁ ∷ as}

prop-∃-dboxes : ∀ {n} (ps : Pauli (₁₊ n)) (eqX : last ps ≡ pX) → ∃ \ vd → act [ vd ]ᵛᵈ ps ≡ pX₀
prop-∃-dboxes {₀} (x ∷ []) eqX rewrite eqX = [] , auto
prop-∃-dboxes {₁} (x ∷ y ∷ []) eqX rewrite eqX = x ∷ [] , prop-dbox x []
prop-∃-dboxes {₂₊ n} (x ∷ y ∷ ps) eqX = x ∷ proj₁ ih , (begin
  act [ x ]ᵈ (act ([ proj₁ ih ]ᵛᵈ ↑) (x ∷ y ∷ ps)) ≡⟨ Eq.cong (act [ x ]ᵈ) (lemma-act-↑ [ proj₁ ih ]ᵛᵈ x (y ∷ ps)) ⟩
  act [ x ]ᵈ (x ∷ act ([ proj₁ ih ]ᵛᵈ) (y ∷ ps)) ≡⟨ Eq.cong (\ □ → act [ x ]ᵈ (x ∷ □)) (proj₂ ih) ⟩
  act [ x ]ᵈ (x ∷ pX₀) ≡⟨ prop-dbox x pIₙ ⟩
  pX ∷ (₀ , ₀) ∷ (₀ , ₀) ∷ pIₙ ∎)
  where
  open ≡-Reasoning
  ih : ∃ \ vd → act [ vd ]ᵛᵈ (y ∷ ps) ≡ pX₀
  ih = prop-∃-dboxes {₁₊ n} (y ∷ ps) (Eq.trans (Eq.sym (last-∷ {a = x} {as = y ∷ ps})) eqX)


prop-∃-dboxes-XZ : ∀ {n} {ᵉ} (ps : Pauli (₁₊ n)) (eqX : last ps ≡ (₁ , ᵉ)) → ∃ \ vd → act [ vd ]ᵛᵈ ps ≡ pX₀Z₀ ᵉ
prop-∃-dboxes-XZ {₀} {ᵉ} (x ∷ []) eqX rewrite eqX = [] , auto
prop-∃-dboxes-XZ {₁} {ᵉ} (x ∷ y ∷ []) eqX rewrite eqX = x ∷ [] , prop-dbox-XZᵇ x ᵉ []
prop-∃-dboxes-XZ {₂₊ n} {ᵉ} (x ∷ y ∷ ps) eqX = x ∷ proj₁ ih , (begin
  act [ x ]ᵈ (act ([ proj₁ ih ]ᵛᵈ ↑) (x ∷ y ∷ ps)) ≡⟨ Eq.cong (act [ x ]ᵈ) (lemma-act-↑ [ proj₁ ih ]ᵛᵈ x (y ∷ ps)) ⟩
  act [ x ]ᵈ (x ∷ act ([ proj₁ ih ]ᵛᵈ) (y ∷ ps)) ≡⟨ Eq.cong (\ □ → act [ x ]ᵈ (x ∷ □)) (proj₂ ih) ⟩
  act [ x ]ᵈ (x ∷ pX₀Z₀ ᵉ) ≡⟨ prop-dbox-XZᵇ x ᵉ pIₙ ⟩
  pX₀Z₀ ᵉ ∎)
  where
  open ≡-Reasoning
  ih : ∃ \ vd → act [ vd ]ᵛᵈ (y ∷ ps) ≡ pX₀Z₀ ᵉ
  ih = prop-∃-dboxes-XZ {₁₊ n} {ᵉ} (y ∷ ps) (Eq.trans (Eq.sym (last-∷ {a = x} {as = y ∷ ps})) eqX)


prop-∃-bboxes : ∀ {n} (ps : Pauli (₁₊ n)) (eqZ : head ps ≡ pZ) → ∃ \ vb → act [ vb ]ᵛᵇ ps ≡ pZₙ
prop-∃-bboxes {₀} (x ∷ []) eqZ rewrite eqZ = [] , auto
prop-∃-bboxes {₁} (x ∷ y ∷ []) eqZ rewrite eqZ = (y ∷ []) , (prop-bbox y [])
prop-∃-bboxes {₂₊ n} (x ∷ y ∷ z ∷ ps) eqZ rewrite eqZ = y ∷ proj₁ ih , (begin
  act ([ proj₁ ih ]ᵛᵇ ↑) (act [ y ]ᵇ (pZ ∷ y ∷ z ∷ ps)) ≡⟨ Eq.cong (act ([ proj₁ ih ]ᵛᵇ ↑)) (prop-bbox y (z ∷ ps)) ⟩
  act ([ proj₁ ih ]ᵛᵇ ↑) (pI ∷ pZ ∷ z ∷ ps) ≡⟨ lemma-act-↑ [ proj₁ ih ]ᵛᵇ pI (pZ ∷ z ∷ ps) ⟩
  pI ∷ act ([ proj₁ ih ]ᵛᵇ) (pZ ∷ z ∷ ps) ≡⟨ Eq.cong (pI ∷_) (proj₂ ih) ⟩
  pI ∷ pI ∷ pZₙ ∎)
  where
  open ≡-Reasoning
  ih : ∃ \ vd → act [ vd ]ᵛᵇ (pZ ∷ z ∷ ps) ≡ pZₙ
  ih = prop-∃-bboxes (pZ ∷ z ∷ ps) auto

prop-∃-M : ∀ {n} {e} (ps : Pauli (₁₊ n)) (eqX : last ps ≡ (₁ , e)) → ∃ \ m → act [ m ]ᵐ ps ≡ pX₀
prop-∃-M {0} {e} (x ∷ []) eqX rewrite eqX = (- e , []) , prop-ebox e []
prop-∃-M {n@(suc m)} {e} ps eqX = (- e , proj₁ vdp) , (begin
  act [ - e ]ᵉ (act [ proj₁ vdp ]ᵛᵈ ps) ≡⟨ Eq.cong (act [ - e ]ᵉ) (proj₂ vdp) ⟩
  act [ - e ]ᵉ (pX₀Z₀ e) ≡⟨ prop-ebox e pIₙ ⟩
  pX₀ ∎)
  where
  open ≡-Reasoning
  vdp = prop-∃-dboxes-XZ {n} {e} ps eqX

lemma-init-last : ∀ {n} {A : Set} (vs : Vec A (₁₊ n)) → vs ≡ init vs ∷ʳ last vs
lemma-init-last (x ∷ []) = auto
lemma-init-last (x ∷ x₁ ∷ vs) = Eq.cong (x ∷_) (lemma-init-last (x₁ ∷ vs))

lemma-<⇒≤ : ∀ {j n} (le : j < (₁₊ n)) → NP.<⇒≤ (s≤s le) ≡ s≤s (NP.<⇒≤ le)
lemma-<⇒≤ (s≤s z≤n) = auto
lemma-<⇒≤ (s≤s (s≤s le)) = auto

lemma-sspred : ∀ {j n} (le : j < (₁₊ n)) → s≤s (NP.≤-pred le) ≡ le
lemma-sspred (s≤s z≤n) = auto
lemma-sspred (s≤s (s≤s le)) = auto

lemma-abox : ∀ {n j} p (ps : Pauli (₁₊ n)) (le : j < (₁₊ n)) a (neq : a ≢ pI) →
  act (abox (NP.<⇒≤ le) (a , neq)) (p ∷ ps) ≡ p ∷ act (abox (NP.≤-pred le) (a , neq)) ps
lemma-abox {₀} {₀} p (x ∷ []) (s≤s z≤n) a neq = lemma-act-↑ ([ a , neq ]ᵃ) p (x ∷ [])
lemma-abox {₁₊ n} {₀} p (x ∷ x₁ ∷ ps) (s≤s z≤n) a neq = lemma-act-↑ (abox z≤n (a , neq) ↑) p (x ∷ x₁ ∷ ps)
lemma-abox {₁₊ n} {₁₊ j} p (x ∷ ps) (s≤s le) a neq = begin
  act (abox (NP.<⇒≤ (s≤s le)) (a , neq)) (p ∷ x ∷ ps) ≡⟨ Eq.cong (\ □ → act (abox □ (a , neq)) (p ∷ x ∷ ps)) ( lemma-<⇒≤ le) ⟩
  act (abox (s≤s (NP.<⇒≤ le)) (a , neq)) (p ∷ x ∷ ps) ≡⟨ auto ⟩
  act (abox (NP.<⇒≤ le) (a , neq) ↓) (p ∷ x ∷ ps) ≡⟨ Eq.cong (\ □ → act (abox (NP.<⇒≤ le) (a , neq) ↓) (p ∷ x ∷ □)) (lemma-init-last ps) ⟩
  act (abox (NP.<⇒≤ le) (a , neq) ↓) (p ∷ x ∷ (init ps ∷ʳ last ps)) ≡⟨ auto ⟩
  act (abox (NP.<⇒≤ le) (a , neq) ↓) ((p ∷ x ∷ init ps) ∷ʳ last ps) ≡⟨ lemma-act-↓ (abox (NP.<⇒≤ le) (a , neq)) (last ps) (p ∷ x ∷ init ps) ⟩
  act (abox (NP.<⇒≤ le) (a , neq)) (p ∷ x ∷ init ps) ∷ʳ last ps ≡⟨ Eq.cong (_∷ʳ last ps) (lemma-abox p (x ∷ init ps) le a neq) ⟩
  (p ∷ act (abox (NP.≤-pred le) (a , neq)) (x ∷ init ps)) ∷ʳ last ps ≡⟨ auto ⟩
  p ∷ (act (abox (NP.≤-pred le) (a , neq)) (x ∷ init ps) ∷ʳ last ps) ≡⟨ Eq.cong (p ∷_) (Eq.sym (lemma-act-↓ (abox (NP.≤-pred le) (a , neq)) (last ps) (x ∷ init ps))) ⟩
  p ∷ (act (abox (NP.≤-pred le) (a , neq) ↓) ((x ∷ init ps) ∷ʳ last ps)) ≡⟨ auto ⟩
  p ∷ (act (abox (NP.≤-pred le) (a , neq) ↓) (x ∷ (init ps ∷ʳ last ps))) ≡⟨ Eq.cong (\ □ → p ∷ (act (abox (NP.≤-pred le) (a , neq) ↓) (x ∷ □))) (Eq.sym (lemma-init-last ps)) ⟩
  p ∷ (act (abox (NP.≤-pred le) (a , neq) ↓) (x ∷ ps)) ≡⟨ Eq.sym auto ⟩
  p ∷ act (abox (s≤s (NP.≤-pred le)) (a , neq)) (x ∷ ps) ≡⟨ Eq.cong (\ □ → p ∷ act (abox □ (a , neq)) (x ∷ ps)) (lemma-sspred le) ⟩
  p ∷ act (abox le (a , neq)) (x ∷ ps) ∎
  where
  open ≡-Reasoning

lemma-bbox2 : ∀ {n j} p (ps : Pauli (₂₊ n)) (le : j < (₁₊ n)) b →
  act (bbox (NP.<⇒≤ le) (b)) (p ∷ ps) ≡ p ∷ act (bbox (NP.≤-pred le) (b)) ps
lemma-bbox2 {₀} {₀} p (x ∷ x₁ ∷ []) (s≤s z≤n) b = lemma-act-↑ [ b ]ᵇ p (x ∷ x₁ ∷ [])
lemma-bbox2 {₁₊ n} {₀} p (x ∷ ps) (s≤s z≤n) b = lemma-act-↑ (bbox z≤n b ↑) p (x ∷ ps)
lemma-bbox2 {₁₊ n} {₁₊ j} p (x ∷ ps) (s≤s le) b = begin
  act (bbox (NP.<⇒≤ (s≤s le)) (b)) (p ∷ x ∷ ps) ≡⟨ Eq.cong (\ □ → act (bbox □ (b)) (p ∷ x ∷ ps)) ( lemma-<⇒≤ le) ⟩
  act (bbox (s≤s (NP.<⇒≤ le)) (b)) (p ∷ x ∷ ps) ≡⟨ auto ⟩
  act (bbox (NP.<⇒≤ le) (b) ↓) (p ∷ x ∷ ps) ≡⟨ Eq.cong (\ □ → act (bbox (NP.<⇒≤ le) (b) ↓) (p ∷ x ∷ □)) (lemma-init-last ps) ⟩
  act (bbox (NP.<⇒≤ le) (b) ↓) (p ∷ x ∷ (init ps ∷ʳ last ps)) ≡⟨ auto ⟩
  act (bbox (NP.<⇒≤ le) (b) ↓) ((p ∷ x ∷ init ps) ∷ʳ last ps) ≡⟨ lemma-act-↓ (bbox (NP.<⇒≤ le) (b)) (last ps) (p ∷ x ∷ init ps) ⟩
  act (bbox (NP.<⇒≤ le) (b)) (p ∷ x ∷ init ps) ∷ʳ last ps ≡⟨ Eq.cong (_∷ʳ last ps) (lemma-bbox2 p (x ∷ init ps) le b) ⟩
  (p ∷ act (bbox (NP.≤-pred le) (b)) (x ∷ init ps)) ∷ʳ last ps ≡⟨ auto ⟩
  p ∷ (act (bbox (NP.≤-pred le) (b)) (x ∷ init ps) ∷ʳ last ps) ≡⟨ Eq.cong (p ∷_) (Eq.sym (lemma-act-↓ (bbox (NP.≤-pred le) (b)) (last ps) (x ∷ init ps))) ⟩
  p ∷ (act (bbox (NP.≤-pred le) (b) ↓) ((x ∷ init ps) ∷ʳ last ps)) ≡⟨ auto ⟩
  p ∷ (act (bbox (NP.≤-pred le) (b) ↓) (x ∷ (init ps ∷ʳ last ps))) ≡⟨ Eq.cong (\ □ → p ∷ (act (bbox (NP.≤-pred le) (b) ↓) (x ∷ □))) (Eq.sym (lemma-init-last ps)) ⟩
  p ∷ (act (bbox (NP.≤-pred le) (b) ↓) (x ∷ ps)) ≡⟨ Eq.sym auto ⟩
  p ∷ act (bbox (s≤s (NP.≤-pred le)) (b)) (x ∷ ps) ≡⟨ Eq.cong (\ □ → p ∷ act (bbox □ (b)) (x ∷ ps)) (lemma-sspred le) ⟩
  p ∷ act (bbox le (b)) (x ∷ ps) ∎
  where
  open ≡-Reasoning

lemma-↑↓ : ∀ {n} (w : Word (Gen n)) → w ↑ ↓ ≡ w ↓ ↑
lemma-↑↓ [ x ]ʷ = auto
lemma-↑↓ ε = auto
lemma-↑↓ (w • w₁) = Eq.cong₂ _•_ (lemma-↑↓ w) (lemma-↑↓ w₁)

lemma-bbox2a : ∀ {n j} (le : j < (₁₊ n)) b →
  bbox (NP.<⇒≤ le) b ≡ bbox (≤-pred le) b ↑
lemma-bbox2a {₀} {₀} (s≤s z≤n) b = auto
lemma-bbox2a {₁₊ n} {₀} (s≤s z≤n) b = auto
lemma-bbox2a {₁₊ n} {₁₊ j} (s≤s (s≤s le)) b = begin
  (bbox (NP.<⇒≤ (s≤s le)) b ↓) ≡⟨ Eq.cong _↓ ih ⟩
  ((bbox le b ↑) ↓) ≡⟨ lemma-↑↓ (bbox le b) ⟩
  ((bbox le b ↓) ↑) ∎
  where
  open ≡-Reasoning
  ih = lemma-bbox2a (s≤s le) b

lemma-bboxes2a : ∀ {n j} (le : j < (₁₊ n)) vb →
  bboxes (NP.<⇒≤ le) vb ≡ (bboxes (≤-pred le) vb ↑)
lemma-bboxes2a {₀} {₀} (s≤s z≤n) [] = auto
lemma-bboxes2a {₁₊ n} {₀} (s≤s le) [] = auto
lemma-bboxes2a {₁₊ n} {₁₊ j} (s≤s le@(s≤s le')) (x ∷ vb) = begin
  bboxes (NP.<⇒≤ (s≤s le)) (x ∷ vb) ≡⟨ auto ⟩
  bboxes (s≤s (NP.<⇒≤ le)) (x ∷ vb) ≡⟨ auto ⟩
  bboxes (NP.<⇒≤ (le)) (vb) ↑ • bbox (NP.<⇒≤ (le)) x ≡⟨ Eq.cong (bboxes (NP.<⇒≤ (le)) (vb) ↑ •_) (lemma-bbox2a (s≤s le') x) ⟩
  bboxes (NP.<⇒≤ (le)) (vb) ↑ • bbox (≤-pred le) x ↑ ≡⟨ auto ⟩
  (bboxes (NP.<⇒≤ le) (vb) • bbox (≤-pred le) x) ↑ ≡⟨ Eq.cong ( \ □ → (□ • bbox (≤-pred le) x) ↑) ih ⟩
  (bboxes (≤-pred le) vb ↑ • bbox (≤-pred le) x) ↑ ≡⟨ auto ⟩
  (bboxes (s≤s (≤-pred le)) (x ∷ vb) ↑) ≡⟨ auto ⟩
  (bboxes (≤-pred (s≤s le)) (x ∷ vb) ↑) ∎
  where
  open ≡-Reasoning
  ih = lemma-bboxes2a le vb

lemma-bboxes2 : ∀ {n j} p (ps : Pauli (₁₊ n)) (le : j < (₁₊ n)) vb →
  act (bboxes (NP.<⇒≤ le) vb) (p ∷ ps) ≡ p ∷ act (bboxes (NP.≤-pred le) vb) ps
lemma-bboxes2 {₀} {₀} p (x ∷ []) (s≤s z≤n) [] = auto
lemma-bboxes2 {₁₊ n} {₀} p (x ∷ ps) (s≤s z≤n) [] = auto
lemma-bboxes2 {₁₊ n} {₁₊ j} p (x ∷ ps) (s≤s le@(s≤s le')) (b ∷ vb) = begin
  act (bboxes (NP.<⇒≤ (s≤s le)) (b ∷ vb)) (p ∷ x ∷ ps) ≡⟨ auto ⟩
  act (bboxes (s≤s (NP.<⇒≤ le)) (b ∷ vb)) (p ∷ x ∷ ps) ≡⟨ auto ⟩
  act (bboxes (NP.<⇒≤ (le)) vb ↑ • bbox (NP.<⇒≤ le) b) (p ∷ x ∷ ps) ≡⟨ auto ⟩
  act (bboxes (NP.<⇒≤ (le)) vb ↑) (act (bbox (NP.<⇒≤ le) b) (p ∷ x ∷ ps)) ≡⟨ Eq.cong (act (bboxes (NP.<⇒≤ (le)) vb ↑)) (lemma-bbox2 p (x ∷ ps) le b) ⟩
  act (bboxes (NP.<⇒≤ (le)) vb ↑) (p ∷ act (bbox (NP.≤-pred le) b) (x ∷ ps)) ≡⟨ lemma-act-↑ (bboxes (NP.<⇒≤ (le)) vb) p (act (bbox (≤-pred le) b) (x ∷ ps)) ⟩
  p ∷ act (bboxes (NP.<⇒≤ (le)) vb) (act (bbox (NP.≤-pred le) b) (x ∷ ps)) ≡⟨ auto ⟩
  p ∷ act (bboxes (NP.<⇒≤ (le)) vb) (act (bbox (NP.≤-pred le) b) (x ∷ ps)) ≡⟨ Eq.cong (\ □ → p ∷ act (□) (act (bbox (NP.≤-pred le) b) (x ∷ ps))) (lemma-bboxes2a (s≤s le') vb) ⟩
  p ∷ act (bboxes ((≤-pred le)) (vb) ↑) (act (bbox ((≤-pred le)) b) (x ∷ ps))  ≡⟨ auto ⟩
  p ∷ act (bboxes ((≤-pred le)) (vb) ↑ • bbox ((≤-pred le)) b) (x ∷ ps)  ≡⟨ auto ⟩
  p ∷ act (bboxes (s≤s (≤-pred le)) (b ∷ vb)) (x ∷ ps)  ≡⟨ auto ⟩
  p ∷ act (bboxes (≤-pred (s≤s le)) (b ∷ vb)) (x ∷ ps) ∎
  where
  open ≡-Reasoning
  ih = lemma-bboxes2 p ps le vb

prop-∃-L' : ∀ {n} (ps : Pauli n) (p : Pauli1) (p≢I : p ≢ pI) → ∃ \ l → act [ l ]ˡ (p ∷ ps) ≡ pZₙ
prop-∃-L' {0} [] p neq = ((0 , [] , p , neq) , z≤n) , prop-abox p neq []
prop-∃-L' {n@(suc n')} ps@(q ∷ qs) p neq =
  let le = NP.≤-reflexive auto in
  let (vb , prf) = prop-∃-bboxes (pZ ∷ q ∷ qs) auto in
  ((n , vb , p , neq), le) , (begin
    act (bboxes le vb) (act (abox le (p , neq)) (p ∷ ps)) ≡⟨ auto ⟩
    act (bboxes le vb) (act (abox le (p , neq)) (p ∷ q ∷ qs)) ≡⟨ Eq.cong (\ □ → act (bboxes le vb) (act (□) (p ∷ q ∷ qs))) (lemma-abox-a (p , neq)) ⟩ --(prop-abox-↓↓ p neq le (q ∷ qs))
    act (bboxes le vb) (act ([(p , neq)]ᵃ) (p ∷ q ∷ qs)) ≡⟨ Eq.cong (act (bboxes le vb)) (prop-abox p neq (q ∷ qs)) ⟩
    act (bboxes le vb) (pZ ∷ q ∷ qs) ≡⟨ Eq.cong (\ □ → act □ (pZ ∷ q ∷ qs)) (lemma-bboxes vb) ⟩
    act ([ vb ]ᵛᵇ) (pZ ∷ q ∷ qs) ≡⟨ prf ⟩
    pZₙ ∎)
  where
  open ≡-Reasoning

{-
lemma-act-bbox : ∀ {j n} (j<n : j < n) p ps → act (bbox j<n pI) (p ∷ ps) ≡ p ∷ ps
lemma-act-bbox {₀} {₁₊ n} (s≤s j≤n) p ps = {!!}
lemma-act-bbox {₁₊ j} {₀} () p ps
lemma-act-bbox {₁₊ j} {₁₊ n} (s≤s j<n) p ps = {!!}
lemma-act-bbox {j} {n} (j<n) p ps = begin
  act (bbox j<n pI) (p ∷ ps) ≡⟨ {!!} ⟩
  p ∷ ps ∎
  where
  open ≡-Reasoning

lemma-bboxes-< : ∀ {j n} (j<n : j < ₁₊ n) (vb : Vec B j) p ps →
  act (bboxes (NP.≤-pred j<n) vb) (p ∷ ps) ≡ {!!} -- p ∷ act (bboxes (j<n) vb) ps
lemma-bboxes-< {j} {n} (s≤s j<n) vb p ps = begin
  act (bboxes (j<n) (vb)) (p ∷ ps) ≡⟨ Eq.refl ⟩
  {!!} ∎
  where
  open ≡-Reasoning
-}

prop-∃-L : ∀ {n} (ps : Pauli (₁₊ n)) (≢I : ps ≢ pIₙ {₁₊ n}) → ∃ \ l → act [ l ]ˡ ps ≡ pZₙ
prop-∃-L {₀} (x ∷ []) ≢I = ((₀ , [] , x , neq) , z≤n) , prop-abox x neq []
  where
  neq : x ≢ pI
  neq eq = ≢I (Eq.cong (_∷ []) eq)
prop-∃-L {₁} ps@(x ∷ y ∷ []) ≢I = [ c1 , c2 ]′ (neqeq x)
  where
  open ≡-Reasoning
  c1 : x ≢ pI → ∃ \ l → act [ l ]ˡ ps ≡ pZₙ
  c1 neq = ((₁ , (y ∷ []), x , neq) , s≤s z≤n) , (begin
    act [ y ]ᵇ (act ([ x , neq ]ᵃ ↓) (x ∷ y ∷ [])) ≡⟨ Eq.cong (act [ y ]ᵇ) (prop-abox-↓ x neq (y ∷ [])) ⟩
    act [ y ]ᵇ (pZ ∷ y ∷ []) ≡⟨ prop-bbox y [] ⟩
    pI ∷ pZ ∷ [] ∎)

  c2 : x ≡ pI → ∃ \ l → act [ l ]ˡ ps ≡ pZₙ
  c2 eq rewrite eq = ((₀ , ([]), y , neq) , z≤n) , (begin
    act ([ y , neq ]ᵃ ↑) (pI ∷ y ∷ []) ≡⟨ lemma-act-↑ [ y , neq ]ᵃ pI (y ∷ []) ⟩
    pI ∷ act ([ y , neq ]ᵃ) (y ∷ []) ≡⟨ Eq.cong (pI ∷_) (prop-abox y neq []) ⟩
    pI ∷ pZ ∷ [] ∎)
    where
    neq : y ≢ pI
    neq eq2 rewrite eq | eq2 = ≢I auto

prop-∃-L {₂₊ n} ps@(x ∷ y ∷ ps') ≢I = [ c1 , c2 ]′ (neqeq x)
  where
  open ≡-Reasoning
  c1 : x ≢ pI → ∃ \ l → act [ l ]ˡ ps ≡ pZₙ
  c1 neq = prop-∃-L' (y ∷ ps') x neq

  c2 : x ≡ pI → ∃ \ l → act [ l ]ˡ ps ≡ pZₙ
  c2 eq rewrite eq =
    let ((j , qs , a , neq) , le) , prf = ih in
    let le' = s≤s le in
    let le'' = NP.<⇒≤ le' in
      ((j , qs , a , neq) , le'') , (begin
         act (bboxes le'' qs) (act (abox le'' (a , neq)) ((₀ , ₀) ∷ y ∷ ps')) ≡⟨ Eq.cong (act (bboxes le'' qs)) (lemma-abox pI (y ∷ ps') le' a neq) ⟩
         act (bboxes le'' qs) ((₀ , ₀) ∷ act (abox (≤-pred le') (a , neq)) (y ∷ ps')) ≡⟨ lemma-bboxes2 pI (act (abox (≤-pred le') (a , neq)) (y ∷ ps')) (le') qs ⟩
         (₀ , ₀) ∷ act (bboxes (≤-pred le') qs) (act (abox (≤-pred le') (a , neq)) (y ∷ ps')) ≡⟨ auto ⟩
         (₀ , ₀) ∷ act (bboxes le qs) (act (abox le (a , neq)) (y ∷ ps')) ≡⟨ Eq.cong (pI ∷_) prf ⟩
         (₀ , ₀) ∷ (₀ , ₀) ∷ pZₙ ∎)
    where
    neq : y ∷ ps' ≢ pIₙ
    neq eq2 rewrite eq | eq2 = ≢I auto

    ih = prop-∃-L {₁₊ n} (y ∷ ps') neq







-- open import Data.Product.Relation.Binary.Pointwise.NonDependent as PW
-- open import Tactic.RingSolver

lemma-sform-aux-s : ∀ a b c d → sform1 (a , b) (c , d) ≡ sform1 (a , a + b) (c , c + d)
lemma-sform-aux-s a b c d = begin
  (- a) * d + c * b ≡⟨ lemma-sform-aux-s' a b c d  ⟩
  (- a) * (c + d) + c * (a + b) ∎
  where
  open ≡-Reasoning

lemma-sform-aux : ∀ a b c d → sform1  (a , b) (c , d) ≡ sform1 (2F * b , a) (2F * d , c)
lemma-sform-aux a b c d = lemma-sform-aux-h a b c d

lemma-sform-aux-cz :  ∀ x y z w → sform1 (x .proj₁ , x .proj₂ + y .proj₁)
    (z .proj₁ , z .proj₂ + w .proj₁)
    +
    sform1 (y .proj₁ , x .proj₁ + y .proj₂)
     (w .proj₁ , z .proj₁ + w .proj₂)
    ≡ sform1 x z + sform1 y w
lemma-sform-aux-cz x y z w = Eq.sym (lemma-sform-aux-cz' (x .proj₁) (x .proj₂) (z .proj₁) (z .proj₂) (y .proj₁) (y .proj₂) (w .proj₁) (w .proj₂))

lemma-sform-fix-gen : ∀ {n} g ps qs → sform {n} (act1 g ps) (act1 g qs) ≡ sform ps qs
lemma-sform-fix-gen {n} H-gen (x ∷ ps) (x₁ ∷ qs) = Eq.cong₂ _+_ (Eq.sym (lemma-sform-aux (proj₁ x) (proj₂ x) (proj₁ x₁) (proj₂ x₁))) Eq.refl
lemma-sform-fix-gen {n} S-gen (x ∷ ps) (x₁ ∷ qs) = Eq.cong₂ _+_ (Eq.sym (lemma-sform-aux-s (proj₁ x) (proj₂ x) (proj₁ x₁) (proj₂ x₁))) Eq.refl
lemma-sform-fix-gen {n} CZ-gen (x ∷ x₂ ∷ ps) (x₁ ∷ x₃ ∷ qs) = begin
  sform1 (x .proj₁ , x .proj₂ + x₂ .proj₁) (x₁ .proj₁ , x₁ .proj₂ + x₃ .proj₁) + (sform1 (x₂ .proj₁ , x .proj₁ + x₂ .proj₂) (x₃ .proj₁ , x₁ .proj₁ + x₃ .proj₂) + sform ps qs) ≡⟨ Eq.sym (+-assoc (sform1 (x .proj₁ , x .proj₂ + x₂ .proj₁) (x₁ .proj₁ , x₁ .proj₂ + x₃ .proj₁) )  (sform1 (x₂ .proj₁ , x .proj₁ + x₂ .proj₂) (x₃ .proj₁ , x₁ .proj₁ + x₃ .proj₂))  (sform ps qs)) ⟩
  (sform1 (x .proj₁ , x .proj₂ + x₂ .proj₁) (x₁ .proj₁ , x₁ .proj₂ + x₃ .proj₁) + sform1 (x₂ .proj₁ , x .proj₁ + x₂ .proj₂) (x₃ .proj₁ , x₁ .proj₁ + x₃ .proj₂)) + sform ps qs ≡⟨ Eq.cong₂ _+_ (lemma-sform-aux-cz x x₂ x₁ x₃) auto ⟩
  (sform1 x x₁ + sform1 x₂ x₃) + sform ps qs ≡⟨ +-assoc (sform1 x x₁) (sform1 x₂ x₃)  (sform ps qs) ⟩
  sform1 x x₁ + (sform1 x₂ x₃ + sform ps qs) ∎
  where open ≡-Reasoning

lemma-sform-fix-gen {n} (g ↥) (x ∷ ps) (x₁ ∷ qs) = Eq.cong₂ _+_ (Eq.refl {x = sform1 x x₁})  (lemma-sform-fix-gen g ps qs)

lemma-sform-fix : ∀ {n} w ps qs → sform {n} (act w ps) (act w qs) ≡ sform ps qs
lemma-sform-fix {n} [ x ]ʷ ps qs = lemma-sform-fix-gen x ps qs
lemma-sform-fix {n} ε ps qs = auto
lemma-sform-fix {n} (w • w₁) ps qs = begin
  sform (act w (act w₁ ps)) (act w (act w₁ qs)) ≡⟨ lemma-sform-fix w (act w₁ ps) (act w₁ qs) ⟩
  sform ((act w₁ ps)) ((act w₁ qs)) ≡⟨ lemma-sform-fix w₁ ps qs ⟩
  sform ps qs ∎
  where open ≡-Reasoning


lemma-sform1-pI' : ∀ x → sform1 pI x ≡ 0F
lemma-sform1-pI' x = begin
  sform1 pI x ≡⟨ lemma-sform1-pI (x .proj₁) (x .proj₂) ⟩
  0F ∎
  where
  open ≡-Reasoning

lemma-sform1-pIʳ : ∀ x → sform1 x pI ≡ 0F
lemma-sform1-pIʳ x = begin
  sform1 x pI ≡⟨ lemma-sform1-pIʳ' (x .proj₁) (x .proj₂) ⟩
  0F ∎
  where
  open ≡-Reasoning

lemma-eq0 : ∀ {n} (ps : Pauli ( n)) → sform pIₙ ps ≡ 0F
lemma-eq0 {₀} ([]) = auto
lemma-eq0 {₁₊ n} (x ∷ ps) = Eq.cong₂ _+_ eq0 (lemma-eq0 ps)
  where
  open ≡-Reasoning
  eq0 : sform1 pI x ≡ 0F
  eq0 = begin
    sform1 pI x ≡⟨ lemma-sform1-pI (x .proj₁) (x .proj₂) ⟩
    0F ∎


lemma-neqI : ∀ {n} (ps qs : Pauli (₁₊ n)) (eq1 : sform ps qs ≡ ₁) → ps ≢ pIₙ
lemma-neqI ps qs eq1 eq rewrite eq = 1neq0 (Eq.trans (Eq.sym eq1) (lemma-eq0 qs))
  where
  1neq0 : ₁ ≢ 0F
  1neq0 ()

lemma-na1 : ∀ p → sform1 pZ p ≡ ₁ → proj₁ p ≡ ₁
lemma-na1 p eq = [ (\ h → ⊥-elim (c0 h)) , (\ h → [ (λ z → z) , (\ h → ⊥-elim (c2 h)) ]′ h )]′ (lemma-enum (proj₁ p))
  where
  c0 : proj₁ p ≡ 0F → ⊥
  c0 eq2 = 0F≠₁ (Eq.trans (Eq.sym aux1) eq)
    where
    0F≠₁ : 0F ≡ ₁ → ⊥
    0F≠₁ ()
    aux1 : sform1 pZ p ≡ 0F
    aux1 rewrite eq2 = auto
  c2 : proj₁ p ≡ 2F → ⊥
  c2 eq2 = 2F≠₁ (Eq.trans (Eq.sym aux1) eq)
    where
    2F≠₁ : 2F ≡ ₁ → ⊥
    2F≠₁ ()
    aux1 : sform1 pZ p ≡ 2F
    aux1 rewrite eq2 = auto

lemma-₁-trivial : ∀ (p : Pauli1) → proj₁ p ≡ ₁ → ∃ \ e → p ≡ (₁ , e)
lemma-₁-trivial (a , ₀) eq rewrite eq = ₀ , auto
lemma-₁-trivial (a , ₁) eq rewrite eq = ₁ , auto
lemma-₁-trivial (a , ₂) eq rewrite eq = ₂ , auto


lemma-sform-pzn : ∀ {n} (qs : Pauli (₁₊ n)) (eq1 : sform pZₙ qs ≡ ₁) →
  ∃ \ e → last qs ≡ (₁ , e)
lemma-sform-pzn (x ∷ []) eq1 = lemma-₁-trivial x aux
  where
  aux0 : sform1 pZ x ≡ ₁
  aux0 = Eq.trans (Eq.sym (+-identityʳ (sform1 pZ x))) eq1

  aux : proj₁ (last (x ∷ [])) ≡ ₁
  aux = lemma-na1 x aux0
lemma-sform-pzn (x ∷ y ∷ qs) eq1 = (proj₁ ih) , (proj₂ ih)
  where
  open ≡-Reasoning
  ihh : sform pZₙ (y ∷ qs) ≡ ₁
  ihh = begin
    sform pZₙ (y ∷ qs) ≡⟨ Eq.sym (+-identityˡ (sform pZₙ (y ∷ qs))) ⟩
    0F + sform pZₙ (y ∷ qs) ≡⟨ Eq.cong (\ □ → □ + sform pZₙ (y ∷ qs)) (Eq.sym (lemma-sform1-pI' x)) ⟩
    sform1 pI x + sform pZₙ (y ∷ qs) ≡⟨ auto ⟩
    sform pZₙ (x ∷ y ∷ qs) ≡⟨ eq1 ⟩
    ₁ ∎

  ih = lemma-sform-pzn (y ∷ qs) ihh

lemma-lbox : ∀ {n} (ps qs : Pauli (₁₊ n)) (eq1 : sform ps qs ≡ ₁) →
  let (l , pzn) = prop-∃-L ps (lemma-neqI ps qs eq1) in
  ∃ \ e → last (act [ l ]ˡ qs) ≡ (₁ , e)
lemma-lbox {n} ps qs eq1 = (proj₁ la) , proj₂ la
  where
  open ≡-Reasoning
  lp = prop-∃-L ps (lemma-neqI ps qs eq1)
  pn = lemma-sform-fix [ proj₁ lp ]ˡ ps qs
  ps' = act [ proj₁ lp ]ˡ ps
  qs' = act [ proj₁ lp ]ˡ qs
  eq1' : sform pZₙ qs' ≡ ₁
  eq1' = begin
    sform pZₙ qs' ≡⟨ Eq.cong (\ □ → sform □ qs') (Eq.sym (proj₂ lp)) ⟩
    sform ps' qs' ≡⟨ pn ⟩
    sform ps qs ≡⟨ eq1 ⟩
    ₁ ∎

  la = lemma-sform-pzn qs' eq1'
  em = prop-∃-M qs' (proj₂ la)


lemma-lbox' : ∀ {n} (ps qs : Pauli (₁₊ n)) (eq1 : sform ps qs ≡ ₁) →
  ∃ \ l → 
  ∃ \ e → last (act [ l ]ˡ qs) ≡ (₁ , e) × (act [ l ]ˡ ps) ≡ pZₙ
lemma-lbox' {n} ps qs eq1 = proj₁ lp , (proj₁ la) , proj₂ la , proj₂ lp
  where
  open ≡-Reasoning
  lp = prop-∃-L ps (lemma-neqI ps qs eq1)
  pn = lemma-sform-fix [ proj₁ lp ]ˡ ps qs
  ps' = act [ proj₁ lp ]ˡ ps
  qs' = act [ proj₁ lp ]ˡ qs
  eq1' : sform pZₙ qs' ≡ ₁
  eq1' = begin
    sform pZₙ qs' ≡⟨ Eq.cong (\ □ → sform □ qs') (Eq.sym (proj₂ lp)) ⟩
    sform ps' qs' ≡⟨ pn ⟩
    sform ps qs ≡⟨ eq1 ⟩
    ₁ ∎

  la = lemma-sform-pzn qs' eq1'

prop-∃-LM : ∀ {n} (ps qs : Pauli (₁₊ n)) (eq1 : sform ps qs ≡ ₁) →
  ∃ \ lm → act [ lm ] ps ≡ pZ₀ × act [ lm ] qs ≡ pX₀
prop-∃-LM {n} ps qs eq1 = (l , m) , claim , claim2
  where
  open ≡-Reasoning

  lp = lemma-lbox' ps qs eq1
  l = proj₁ lp
  qs' = act [ l ]ˡ qs
  mp = prop-∃-M qs' (lp .proj₂ .proj₂ .proj₁)
  m = proj₁ mp
  claim : act [ (l , m) ] ps ≡ pZ₀
  claim = begin
    act [ (l , m) ] ps ≡⟨ auto ⟩
    act [ m ]ᵐ (act [ l ]ˡ ps) ≡⟨ Eq.cong (\ □ →  act [ m ]ᵐ □ ) ((lp .proj₂ .proj₂ .proj₂)) ⟩
    act [ m ]ᵐ pZₙ ≡⟨ auto ⟩
    act [ m .proj₁ ]ᵉ (act [ m .proj₂ ]ᵛᵈ pZₙ) ≡⟨ Eq.cong (\ □ → act [ m .proj₁ ]ᵉ □) (prop-dboxes (m .proj₂)) ⟩
    act [ m .proj₁ ]ᵉ (pZ₀) ≡⟨ prop-ebox-dual (m .proj₁) ⟩
    pZ₀ ∎

  claim2 : act [ (l , m) ] qs ≡ pX₀
  claim2 = begin
    act [ (l , m) ] qs ≡⟨ auto ⟩
    act [ m ]ᵐ (act [ l ]ˡ qs) ≡⟨ auto ⟩
    act [ m ]ᵐ qs' ≡⟨ proj₂ mp ⟩
    pX₀ ∎


-}

