{-# OPTIONS  --safe #-}
{-# OPTIONS --termination-depth=2 #-}
open import Level using (0ℓ)

open import Relation.Binary using (Rel)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Binary.Morphism.Definitions using (Homomorphic₂)
open import Relation.Binary.PropositionalEquality using (_≡_ ; _≢_ ; inspect ; setoid ; module ≡-Reasoning ; _≗_) renaming ([_] to [_]')
import Relation.Binary.Reasoning.Setoid as SR
import Relation.Binary.PropositionalEquality as Eq
open import Relation.Nullary.Decidable using (yes ; no)


open import Function using (_∘_ ; id)
open import Function.Definitions using (Injective)

open import Data.Product using (_×_ ; _,_ ; proj₁ ; proj₂ ; map₁ ; ∃ ; Σ ; Σ-syntax)
open import Data.Product.Relation.Binary.Pointwise.NonDependent as PW using (≡×≡⇒≡ ; Pointwise ; ≡⇒≡×≡)
open import Data.Nat hiding (_^_ ; _+_ ; _*_)
open import Agda.Builtin.Nat using (_-_)
import Data.Nat as Nat
open import Data.Bool hiding (_<_ ; _≤_)
open import Data.List hiding ([_] ; _++_ ; last ; head ; tail ; _∷ʳ_)
open import Data.Vec hiding ([_])
import Data.Vec as Vec
open import Data.Fin hiding (_+_ ; _-_)

open import Data.Maybe
open import Data.Sum using (_⊎_ ; inj₁ ; inj₂ ; [_,_] ; [_,_]′)
open import Data.Unit using (⊤ ; tt)
open import Data.Empty using (⊥ ; ⊥-elim)

open import Word.Base as WB hiding (wfoldl ; _*)
open import Word.Properties
import Presentation.Base as PB
import Presentation.Properties as PP
open PP using (NFProperty ; NFProperty')
import Presentation.CosetNF as CA
import Presentation.Reidemeister-Schreier as RS
module RSF = RS.Star-Injective-Full.Reidemeister-Schreier-Full

open import Presentation.Construct.Base hiding (_*_ ; _⊕_)
import Presentation.Construct.Properties.SemiDirectProduct2 as SDP2
import Presentation.Construct.Properties.DirectProduct as DP
import Presentation.Groups.Cyclic as Cyclic


open import Data.Fin using (Fin ; toℕ ; suc ; zero ; fromℕ)
open import Data.Fin.Properties as FP using (suc-injective ; toℕ-inject₁ ; toℕ-fromℕ)
import Data.Nat.Properties as NP
open import Presentation.GroupLike
open import Presentation.Tactics hiding ([_])
open import Data.Nat.Primality



module N.Action (p-2 : ℕ) (p-prime : Prime (2+ p-2))  where

pattern auto = Eq.refl

pattern ₀ = zero
pattern ₁ = suc ₀
pattern ₂ = suc ₁
pattern ₃ = suc ₂
pattern ₅ = 5
pattern ₆ = 6
pattern ₇ = 7
pattern ₈ = 8
pattern ₉ = 9
pattern ₁₀ = 10
pattern ₁₁ = 11
pattern ₁₂ = 12
pattern ₁₃ = 13
pattern ₁₄ = 14
pattern ₁₅ = 15

pattern ₁₊ ⱼ = suc ⱼ
pattern ₂₊ ⱼ = suc (suc ⱼ)
pattern ₃₊ ⱼ = suc (suc (suc ⱼ))


open import Zp.ModularArithmetic
open PrimeModulus p-2 p-prime
open import N.Symplectic-Derived p-2 p-prime


open Symplectic-Derived-Gen
open import N.Pauli p-2 p-prime public

act1 : ∀ {n} → Gen n → Pauli n → Pauli n
act1 {₁₊ n} (H-gen ₀) ((a , b) ∷ ps) = ((a , b) ∷ ps)
act1 {₁₊ n} (H-gen ₁) ((a , b) ∷ ps) = ((- b , a) ∷ ps)
act1 {₁₊ n} (H-gen ₂) ((a , b) ∷ ps) = ((- a , - b) ∷ ps)
act1 {₁₊ n} (H-gen ₃) ((a , b) ∷ ps) = ((b , - a) ∷ ps)
act1 {₁₊ n} (S-gen k) ((a , b) ∷ ps) = ((a , b + a * k) ∷ ps)
act1 {₂₊ n} (CZ-gen k) ((a , b) ∷ (a' , b') ∷ ps) = (a , b + a' * k) ∷ (a' , b' + a * k) ∷ ps
act1 {₁₊ n} (g ↥) (p ∷ ps) = p ∷ act1 {n} g ps

act : ∀ {n} → Word (Gen n) → Pauli n → Pauli n
act {n} = word-act act1
-- act {n} ε p = p
-- act {n} (w • w₁) p = act w (act w₁ p)

lemma-act-↑ : ∀ {n} (w : Word (Gen n)) → (p : Pauli1 ) (q : Pauli n) → act (w ↑) (p ∷ q) ≡ p ∷ act w q
lemma-act-↑ {n} [ x ]ʷ p q = auto
lemma-act-↑ {n} ε p q = auto
lemma-act-↑ {n} (w • v) p q = begin
  act ((w • v) ↑) (p ∷ q) ≡⟨ auto ⟩
  act (w ↑) (act (v ↑) (p ∷ q)) ≡⟨ Eq.cong (act (w ↑)) (lemma-act-↑ v p q) ⟩
  act (w ↑) (p ∷ act v q) ≡⟨ lemma-act-↑ w p (act v q) ⟩
  p ∷ act w (act v q) ≡⟨ auto ⟩
  p ∷ act (w • v) q ∎
  where open ≡-Reasoning


lemma-act-↓-gen : ∀ {n} (gen : Gen n) → (p : Pauli1 ) (ps : Pauli n) → act1 (gen ↓-gen) (ps ∷ʳ p) ≡ (act1 gen ps) ∷ʳ p
lemma-act-↓-gen {₁} (H-gen ₀) p (x ∷ []) = auto
lemma-act-↓-gen {₁} (H-gen ₁) p (x ∷ []) = auto
lemma-act-↓-gen {₁} (H-gen ₂) p (x ∷ []) = auto
lemma-act-↓-gen {₁} (H-gen ₃) p (x ∷ []) = auto
lemma-act-↓-gen {₁} (S-gen k) p (x ∷ []) = auE × Vec D nto
lemma-act-↓-gen {₂₊ n} (H-gen ₀) p (x ∷ x₁ ∷ ps) = auto
lemma-act-↓-gen {₂₊ n} (H-gen ₁) p (x ∷ x₁ ∷ ps) = auto
lemma-act-↓-gen {₂₊ n} (H-gen ₂) p (x ∷ x₁ ∷ ps) = auto
lemma-act-↓-gen {₂₊ n} (H-gen ₃) p (x ∷ x₁ ∷ ps) = auto
lemma-act-↓-gen {₂₊ n} (S-gen k) p (x ∷ x₁ ∷ ps) = auto
lemma-act-↓-gen {₂₊ n} (CZ-gen k) p (x ∷ x₁ ∷ ps) = auto
lemma-act-↓-gen {₂₊ n} (gen ↥) p (x ∷ x₁ ∷ ps) rewrite lemma-act-↓-gen {₁₊ n} gen p (x₁ ∷ ps) = Eq.cong (x ∷_) auto

-- lemma-act-↓ : ∀ {n} (w : Word (Gen n)) → (p : Pauli1 ) (ps : Pauli n) → act (w ↓) (ps ∷ʳ p) ≡ (act w ps) ∷ʳ p
-- lemma-act-↓ {₁₊ n} [ x ]ʷ p (x₁ ∷ ps) = lemma-act-↓-gen x p (x₁ ∷ ps)
-- lemma-act-↓ {n} ε p ps = auto
-- lemma-act-↓ {n} (w • w₁) p ps rewrite lemma-act-↓ w₁ p ps | lemma-act-↓ w p (act w₁ ps) = auto

open import Data.Nat.DivMod
open import Algebra.Properties.Ring (+-*-ring p-2)


lemma-act-Sᵏ : ∀ {n} k ps -> let k' = fromℕ< (m%n<n k p) in
  act {₁₊ n} (S ^ k) ps ≡ act (S^ k') ps
lemma-act-Sᵏ {n} k@₀ ps@((a , b) ∷ t) = begin  
  act (S ^ k) ps ≡⟨ Eq.cong (\ xx -> (a , xx) ∷ t) (Eq.sym (Eq.trans (Eq.cong (b +_) (*-zeroʳ a)) (+-identityʳ b))) ⟩
  (a , b + a * k') ∷ t ≡⟨ auto ⟩
  act (S^ k') ps ∎
  where
  open ≡-Reasoning
  k' = fromℕ< (m%n<n k p)    
lemma-act-Sᵏ {n} k@₁ ps@((a , b) ∷ t) = auto
lemma-act-Sᵏ {n} k@(₂₊ k-2) ps@((a , b) ∷ t) = begin
  act (S • S ^ ₁₊ k-2) ((a , b) ∷ t) ≡⟨ auto ⟩
  act S (act (S ^ ₁₊ k-2) ((a , b) ∷ t)) ≡⟨ Eq.cong (act S) (lemma-act-Sᵏ (₁₊ k-2) ((a , b) ∷ t)) ⟩
  act S (act (S^ k'-1) ((a , b) ∷ t)) ≡⟨ auto ⟩
  act S ((a , b + a * k'-1) ∷ t) ≡⟨ auto ⟩
  (a , b + a * k'-1 + a * ₁) ∷ t ≡⟨ Eq.cong (\ xx -> (a , xx) ∷ t) (+-assoc b (a * k'-1) (a * ₁)) ⟩
  (a , b + (a * k'-1 + a * ₁)) ∷ t ≡⟨ Eq.cong (λ xx → (a , xx) ∷ t) (Eq.cong (b +_) (Eq.sym (*-distribˡ-+ a k'-1 ₁))) ⟩
  (a , b + a * (k'-1 + ₁)) ∷ t ≡⟨ Eq.cong (λ xx → (a , xx) ∷ t) (Eq.cong (b +_) (Eq.cong (a *_) aux-k'-1+1)) ⟩
  (a , b + a * k') ∷ t ≡⟨ auto ⟩
  act (S^ k') ((a , b) ∷ t) ∎
  where
  open ≡-Reasoning
  open Lemmas0 n
  k-1 = ₁₊ k-2
  k' = fromℕ< (m%n<n k p)  
  k'-1 = fromℕ< (m%n<n k-1 p)
  aux-k'k : (toℕ k'-1 Nat.+ 1) Nat.% p ≡ k Nat.% p
  aux-k'k = begin
    (toℕ k'-1 Nat.+ 1) Nat.% p ≡⟨ Eq.cong (Nat._% p) (NP.+-comm (toℕ k'-1) 1) ⟩
    (1 Nat.+ (toℕ k'-1)) Nat.% p ≡⟨ Eq.cong (Nat._% p) (Eq.cong (1 Nat.+_) (FP.toℕ-fromℕ< (m%n<n k-1 p))) ⟩
    (1 Nat.% p Nat.+ (k-1) Nat.% p) Nat.% p ≡⟨ Eq.sym (%-distribˡ-+ 1 k-1 p) ⟩
    k Nat.% p ∎
  aux-k'-1+1 : k'-1 + ₁ ≡ k'
  aux-k'-1+1 = begin
    k'-1 + ₁ ≡⟨ FP.fromℕ<-cong ( (toℕ k'-1 Nat.+ 1) Nat.% p) (k Nat.% p) aux-k'k (m%n<n (toℕ k'-1 Nat.+ 1) p) (m%n<n k p) ⟩
    k' ∎


lemma-act-CZᵏ : ∀ {n} k ps -> let k' = fromℕ< (m%n<n k p) in
  act {₂₊ n} (CZ ^ k) ps ≡ act (CZ^ k') ps
lemma-act-CZᵏ {n} k@₀ ps@((a , b) ∷ (a' , b') ∷ t) = begin  
  act (CZ ^ k) ps ≡⟨ Eq.cong₂ (\ xx yy -> (a , xx) ∷ (a' , yy) ∷ t) (Eq.sym (Eq.trans (Eq.cong (b +_) (*-zeroʳ a')) (+-identityʳ b))) (Eq.sym (Eq.trans (Eq.cong (b' +_) (*-zeroʳ a)) (+-identityʳ b'))) ⟩
  (a , b + a' * k') ∷ (a' , b' + a * k' ) ∷ t ≡⟨ auto ⟩
  act (CZ^ k') ps ∎
  where
  open ≡-Reasoning
  k' = fromℕ< (m%n<n k p)    
lemma-act-CZᵏ {n} k@₁ ps@((a , b) ∷ (a' , b') ∷ t) = auto
lemma-act-CZᵏ {n} k@(₂₊ k-2) ps@((a , b) ∷ (a' , b') ∷ t) = begin
  act (CZ • CZ ^ ₁₊ k-2) ((a , b) ∷ (a' , b') ∷ t) ≡⟨ auto ⟩
  act CZ (act (CZ ^ ₁₊ k-2) ((a , b) ∷ (a' , b') ∷ t)) ≡⟨ Eq.cong (act CZ) (lemma-act-CZᵏ (₁₊ k-2) ((a , b) ∷ (a' , b') ∷ t)) ⟩
  act CZ (act (CZ^ k'-1) ((a , b) ∷ (a' , b') ∷ t)) ≡⟨ auto ⟩
  act CZ ((a , b + a' * k'-1) ∷ (a' , b' + a * k'-1) ∷ t) ≡⟨ auto ⟩
  (a , b + a' * k'-1 + a' * ₁) ∷ (a' , b' + a * k'-1 + a * ₁) ∷ t ≡⟨ Eq.cong₂ (\ xx  yy -> (a , xx) ∷ (a' , yy) ∷ t) (+-assoc b (a' * k'-1) (a' * ₁)) (+-assoc b' (a * k'-1) (a * ₁)) ⟩
  (a , b + (a' * k'-1 + a' * ₁)) ∷ (a' , b' + (a * k'-1 + a * ₁)) ∷ t ≡⟨ Eq.cong₂ (λ xx yy → (a , xx) ∷ (a' , yy) ∷ t) (Eq.cong (b +_) (Eq.sym (*-distribˡ-+ a' k'-1 ₁))) (Eq.cong (b' +_) (Eq.sym (*-distribˡ-+ a k'-1 ₁))) ⟩
  (a , b + a' * (k'-1 + ₁)) ∷ (a' , b' + a * (k'-1 + ₁)) ∷ t ≡⟨ Eq.cong₂ (λ xx yy → (a , xx) ∷ (a' , yy) ∷ t) (Eq.cong (b +_) (Eq.cong (a' *_) aux-k'-1+1)) (Eq.cong (b' +_) (Eq.cong (a *_) aux-k'-1+1)) ⟩
  (a , b + a' * k') ∷ (a' , b' + a * k') ∷ t ≡⟨ auto ⟩
  act (CZ^ k') ((a , b) ∷ (a' , b') ∷ t) ∎
  where
  open ≡-Reasoning
  open Lemmas0 n
  k-1 = ₁₊ k-2
  k' = fromℕ< (m%n<n k p)  
  k'-1 = fromℕ< (m%n<n k-1 p)
  aux-k'k : (toℕ k'-1 Nat.+ 1) Nat.% p ≡ k Nat.% p
  aux-k'k = begin
    (toℕ k'-1 Nat.+ 1) Nat.% p ≡⟨ Eq.cong (Nat._% p) (NP.+-comm (toℕ k'-1) 1) ⟩
    (1 Nat.+ (toℕ k'-1)) Nat.% p ≡⟨ Eq.cong (Nat._% p) (Eq.cong (1 Nat.+_) (FP.toℕ-fromℕ< (m%n<n k-1 p))) ⟩
    (1 Nat.% p Nat.+ (k-1) Nat.% p) Nat.% p ≡⟨ Eq.sym (%-distribˡ-+ 1 k-1 p) ⟩
    k Nat.% p ∎
  aux-k'-1+1 : k'-1 + ₁ ≡ k'
  aux-k'-1+1 = begin
    k'-1 + ₁ ≡⟨ FP.fromℕ<-cong ( (toℕ k'-1 Nat.+ 1) Nat.% p) (k Nat.% p) aux-k'k (m%n<n (toℕ k'-1 Nat.+ 1) p) (m%n<n k p) ⟩
    k' ∎


lemma-act-ₕ|ₕ : ∀ {n} a b a' b' t -> 
  act {₂₊ n} ₕ|ₕ ((a , b) ∷ (a' , b') ∷ t) ≡ ((- a + - a' , - b) ∷ (a' , b' + - b) ∷ t)
lemma-act-ₕ|ₕ {n} a b a' b' t = begin
  act {₂₊ n} ₕ|ₕ ((a , b) ∷ (a' , b') ∷ t) ≡⟨ auto ⟩
  act {₂₊ n} (H • CZ) ((- b , a) ∷ (a' , b') ∷ t) ≡⟨ auto ⟩
  act {₂₊ n} (H) ((- b , a + a' * ₁) ∷ (a' , b' + - b * ₁) ∷ t) ≡⟨ auto ⟩
  ((- (a + a' * ₁) , - b) ∷ (a' , b' + - b * ₁) ∷ t) ≡⟨ Eq.cong₂ (\ xx yy -> ((- (a + xx) , - b) ∷ (a' , b' + yy) ∷ t)) (*-identityʳ a') (*-identityʳ (- b)) ⟩
  ((- (a + a') , - b) ∷ (a' , b' + - b) ∷ t) ≡⟨ Eq.cong (\ xx -> ((xx , - b) ∷ (a' , b' + - b) ∷ t)) (Eq.sym (-‿+-comm a a')) ⟩
  ((- a + - a' , - b) ∷ (a' , b' + - b) ∷ t) ∎
  where
  open ≡-Reasoning


lemma-act-ʰ|ʰ : ∀ {n} a b a' b' t -> 
  act {₂₊ n} ʰ|ʰ ((a , b) ∷ (a' , b') ∷ t) ≡ ((a , b + - b') ∷ (- a' + - a , - b') ∷ t)
lemma-act-ʰ|ʰ {n} a b a' b' t = begin
  act {₂₊ n} ʰ|ʰ ((a , b) ∷ (a' , b') ∷ t) ≡⟨ auto ⟩
  act {₂₊ n} (H ↑ • CZ) ((a , b) ∷ (- b' , a') ∷ t) ≡⟨ auto ⟩
  act {₂₊ n} (H ↑) ((a , b + - b' * ₁) ∷ (- b' , a' + a * ₁) ∷ t) ≡⟨ auto ⟩
  ((a , b + - b' * ₁) ∷ (- (a' + a * ₁) , - b') ∷ t) ≡⟨ Eq.cong₂ (\ yy xx -> ((a , b + yy) ∷ (- (a' + xx) , - b') ∷ t)) (*-identityʳ (- b')) (*-identityʳ a)  ⟩
  ((a , b + - b') ∷ (- (a' + a) , - b') ∷ t) ≡⟨ Eq.cong (\ xx -> ((a , b + - b') ∷ (xx , - b') ∷ t)) (Eq.sym (-‿+-comm a' a)) ⟩
  ((a , b + - b') ∷ (- a' + - a , - b') ∷ t) ∎
  where
  open ≡-Reasoning


aux1-aaa : ∀ a a' -> - a + - (- a' + - a) ≡ a'
aux1-aaa a a' = begin
  - a + - (- a' + - a) ≡⟨ Eq.cong (- a +_) (Eq.sym (-‿+-comm (- a') (- a))) ⟩
  - a + (- - a' + - - a) ≡⟨ Eq.cong (- a +_) (+-comm (- - a') (- - a)) ⟩
  - a + (- - a + - - a') ≡⟨ Eq.sym (+-assoc (- a) (- - a) (- - a')) ⟩
  - a + - - a + - - a' ≡⟨ Eq.cong (_+ - - a') (+-inverseʳ (- a)) ⟩
  ₀ + - - a' ≡⟨ +-identityˡ (- - a') ⟩
  - - a' ≡⟨ -‿involutive a' ⟩
  a' ∎
  where
  open ≡-Reasoning

aux1-aaa' : ∀ a a' -> - a + - (a' + - a) ≡ - a'
aux1-aaa' a a' = begin
  - a + - (a' + - a) ≡⟨ Eq.cong (- a +_) (Eq.sym (-‿+-comm (a') (- a))) ⟩
  - a + (- a' + - - a) ≡⟨ Eq.cong (- a +_) (+-comm (- a') (- - a)) ⟩
  - a + (- - a + - a') ≡⟨ Eq.sym (+-assoc (- a) (- - a) (- a')) ⟩
  - a + - - a + - a' ≡⟨ Eq.cong (_+ - a') (+-inverseʳ (- a)) ⟩
  ₀ + - a' ≡⟨ +-identityˡ (- a') ⟩
  - a' ∎
  where
  open ≡-Reasoning


aux1-bbb : ∀ b b' -> - (b + - b') ≡ - b + b'
aux1-bbb b b' = Eq.trans (Eq.sym (-‿+-comm b (- b'))) (Eq.cong (- b +_) (-‿involutive b'))

lemma-act-⊥⊤ : ∀ {n} a b a' b' t -> 
  act {₂₊ n} ⊥⊤ ((a , b) ∷ (a' , b') ∷ t) ≡ (a' , - b + b') ∷ (- a' + - a , - b) ∷ t
lemma-act-⊥⊤ {n} a b a' b' t = begin
  act {₂₊ n} ⊥⊤ ((a , b) ∷ (a' , b') ∷ t) ≡⟨ Eq.cong (act {₂₊ n} ₕ|ₕ) (lemma-act-ʰ|ʰ a b a' b' t) ⟩
  act {₂₊ n} ₕ|ₕ ((a , b + - b') ∷ (- a' + - a , - b') ∷ t) ≡⟨ lemma-act-ₕ|ₕ a (b + - b') (- a' + - a) (- b') t ⟩
  ((- a + - (- a' + - a) , - (b + - b')) ∷ (- a' + - a , - b' + - (b + - b')) ∷ t) ≡⟨ cong₃ (\ xx yy zz -> (xx , yy) ∷ (- a' + - a , zz) ∷ t) (aux1-aaa a a') (aux1-bbb b b') (aux1-aaa' b' b ) ⟩
  (a' , - b + b') ∷ (- a' + - a , - b) ∷ t ∎
  where
  open ≡-Reasoning


lemma-act-⊤⊥ : ∀ {n} a b a' b' t -> 
  act {₂₊ n} ⊤⊥ ((a , b) ∷ (a' , b') ∷ t) ≡ ((- a + - a' , - b') ∷ (a , - b' + b) ∷ t)
lemma-act-⊤⊥ {n} a b a' b' t = begin
  act {₂₊ n} ⊤⊥ ((a , b) ∷ (a' , b') ∷ t) ≡⟨ Eq.cong (act {₂₊ n} ʰ|ʰ) (lemma-act-ₕ|ₕ a b a' b' t) ⟩
  act {₂₊ n} ʰ|ʰ ((- a + - a' , - b) ∷ (a' , b' + - b) ∷ t) ≡⟨ lemma-act-ʰ|ʰ (- a + - a') (- b) a' (b' + - b) t ⟩
  ((- a + - a' , - b + - (b' + - b)) ∷ (- a' + - (- a + - a') , - (b' + - b)) ∷ t) ≡⟨ cong₃ (\ xx yy zz -> (- a + - a' , xx) ∷ (yy , zz) ∷ t) (aux1-aaa' b b') (aux1-aaa a' a) (aux1-bbb b' b) ⟩
  ((- a + - a' , - b') ∷ (a , - b' + b) ∷ t) ∎
  where
  open ≡-Reasoning

lemma-act-⊤⊥↑CZ↓ : ∀ {n} a b a' b' a'' b'' t ->
  act {₃₊ n} (⊤⊥ ↑ • CZ ↓) ((a , b) ∷ (a' , b') ∷ (a'' , b'') ∷ t) ≡ (a , b + a') ∷ (- a' + - a'' , - b'') ∷ (a' , - b'' + (b' + a)) ∷ t
lemma-act-⊤⊥↑CZ↓ {n} a b a' b' a'' b'' t = begin
  act {₃₊ n} (⊤⊥ ↑ • CZ ↓) ((a , b) ∷ (a' , b') ∷ (a'' , b'') ∷ t) ≡⟨ auto ⟩
  act {₃₊ n} (⊤⊥ ↑) ((a , b + a' * ₁) ∷ (a' , b' + a * ₁) ∷ (a'' , b'') ∷ t) ≡⟨ Eq.trans (lemma-act-↑ ⊤⊥ ((a , b + a' * ₁)) ((a' , b' + a * ₁) ∷ (a'' , b'') ∷ t)) (Eq.cong ((a , b + a' * ₁) ∷_) (lemma-act-⊤⊥ a' (b' + a * ₁) a'' b'' t)) ⟩
  (a , b + a' * ₁) ∷ (- a' + - a'' , - b'') ∷ (a' , - b'' + (b' + a * ₁)) ∷ t ≡⟨ Eq.cong₂ (\ xx yy -> (a , b + xx) ∷ (- a' + - a'' , - b'') ∷ (a' , - b'' + (b' + yy)) ∷ t) (*-identityʳ a') (*-identityʳ a) ⟩
  (a , b + a') ∷ (- a' + - a'' , - b'') ∷ (a' , - b'' + (b' + a)) ∷ t ∎
  where
  open ≡-Reasoning


lemma-act-⊥⊤↓CZ↑ : ∀ {n} a b a' b' a'' b'' t ->
  act {₃₊ n} (⊥⊤ ↓ • CZ ↑) ((a , b) ∷ (a' , b') ∷ (a'' , b'') ∷ t) ≡ ((a' , - b + (b' + a'')) ∷ (- a' + - a , - b) ∷ (a'' , b'' + a') ∷ t)
lemma-act-⊥⊤↓CZ↑ {n} a b a' b' a'' b'' t = begin
  act {₃₊ n} (⊥⊤ ↓ • CZ ↑) ((a , b) ∷ (a' , b') ∷ (a'' , b'') ∷ t) ≡⟨ Eq.cong  (act {₃₊ n} (⊥⊤ ↓)) (lemma-act-↑ CZ ((a , b)) ((a' , b') ∷ (a'' , b'') ∷ t)) ⟩
  act {₃₊ n} (⊥⊤ ↓) ((a , b) ∷ (a' , b' + a'' * ₁) ∷ (a'' , b'' + a' * ₁) ∷ t) ≡⟨ lemma-act-⊥⊤ a b a' (b' + a'' * ₁) ((a'' , b'' + a' * ₁) ∷ t) ⟩
  ((a' , - b + (b' + a'' * ₁)) ∷ (- a' + - a , - b) ∷ (a'' , b'' + a' * ₁) ∷ t) ≡⟨ Eq.cong₂ ( \ xx yy -> ((a' , - b + (b' + xx)) ∷ (- a' + - a , - b) ∷ (a'' , b'' + yy) ∷ t)) (*-identityʳ a'') (*-identityʳ a') ⟩
  ((a' , - b + (b' + a'')) ∷ (- a' + - a , - b) ∷ (a'' , b'' + a') ∷ t) ∎
  where
  open ≡-Reasoning

