{-# OPTIONS  --safe #-}
{-# OPTIONS --termination-depth=2 #-}
{-# OPTIONS  --call-by-name #-}

open import Level using (0ℓ)

open import Relation.Binary using (Rel)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Binary.Morphism.Definitions using (Homomorphic₂)
open import Relation.Binary.PropositionalEquality using (_≡_ ; _≢_ ; inspect ; setoid ; module ≡-Reasoning ; _≗_) renaming ([_] to [_]')
import Relation.Binary.Reasoning.Setoid as SR
import Relation.Binary.PropositionalEquality as Eq
open import Relation.Nullary.Decidable using (yes ; no)


open import Function using (_∘_ ; id)
open import Function.Definitions using (Injective)

open import Data.Product using (_×_ ; _,_ ; proj₁ ; proj₂ ; map₁ ; ∃ ; Σ ; Σ-syntax)
open import Data.Product.Relation.Binary.Pointwise.NonDependent as PW using (≡×≡⇒≡ ; Pointwise ; ≡⇒≡×≡)
open import Data.Nat hiding (_^_ ; _+_ ; _*_)
open import Agda.Builtin.Nat using (_-_)
import Data.Nat as Nat
open import Data.Bool hiding (_<_ ; _≤_)
open import Data.List hiding ([_] ; _++_ ; last ; head ; tail ; _∷ʳ_)
open import Data.Vec hiding ([_])
import Data.Vec as Vec
open import Data.Fin hiding (_+_ ; _-_)

open import Data.Maybe
open import Data.Sum using (_⊎_ ; inj₁ ; inj₂ ; [_,_] ; [_,_]′)
open import Data.Unit using (⊤ ; tt)
open import Data.Empty using (⊥ ; ⊥-elim)

open import Word.Base as WB hiding (wfoldl ; _*)
open import Word.Properties
import Presentation.Base as PB
import Presentation.Properties as PP
open PP using (NFProperty ; NFProperty')
import Presentation.CosetNF as CA
import Presentation.Reidemeister-Schreier as RS
module RSF = RS.Star-Injective-Full.Reidemeister-Schreier-Full

open import Presentation.Construct.Base hiding (_*_ ; _⊕_)
import Presentation.Construct.Properties.SemiDirectProduct2 as SDP2
import Presentation.Construct.Properties.DirectProduct as DP
import Presentation.Groups.Cyclic as Cyclic


open import Data.Fin using (Fin ; toℕ ; suc ; zero ; fromℕ)
open import Data.Fin.Properties using (suc-injective ; toℕ-inject₁ ; toℕ-fromℕ)
import Data.Nat.Properties as NP
open import Presentation.GroupLike
open import Presentation.Tactics hiding ([_] ; inspect)
open import Data.Nat.Primality



module N.Proofs.P3 (p-2 : ℕ) (p-prime : Prime (2+ p-2))  where

pattern auto = Eq.refl

pattern ₀ = zero
pattern ₁ = suc ₀
pattern ₂ = suc ₁
pattern ₃ = suc ₂
pattern ₄ = 4
pattern ₅ = 5
pattern ₆ = 6
pattern ₇ = 7
pattern ₈ = 8
pattern ₉ = 9
pattern ₁₀ = 10
pattern ₁₁ = 11
pattern ₁₂ = 12
pattern ₁₃ = 13
pattern ₁₄ = 14
pattern ₁₅ = 15

pattern ₁₊ ⱼ = suc ⱼ
pattern ₂₊ ⱼ = suc (suc ⱼ)
pattern ₃₊ ⱼ = suc (suc (suc ⱼ))


open import Zp.ModularArithmetic
open PrimeModulus p-2 p-prime
open import N.Symplectic p-2 p-prime
open import N.Lemmas-2Qupit-Sym p-2 p-prime
open import N.NF2-Sym p-2 p-prime
open Lemmas-2Q 0
open Symplectic
open Lemmas-Sym
open import N.NF1-Sym p-2 p-prime
open Normal-Form1
open import N.Ex-Sym p-2 p-prime
open import N.Ex-Sym1 p-2 p-prime
open import N.Ex-Sym2 p-2 p-prime
open import N.Ex-Sym3 p-2 p-prime
open import N.Ex-Sym4 p-2 p-prime
open import N.Lemma-Comm p-2 p-prime
open import N.Duality p-2 p-prime hiding (module L0)
open import N.Lemma-Postfix p-2 p-prime
open import N.Completeness1-Sym p-2 p-prime renaming (module Completeness to Cp1)

open Lemmas0a
open Lemmas0a1
open Lemmas0b
open Lemmas0c

open LM2
open import N.Completeness1-Sym p-2 p-prime renaming (module Completeness to CP1) using ()

open PB (2 QRel,_===_)
open PP (2 QRel,_===_)
open SR word-setoid
open Pattern-Assoc

open import Algebra.Properties.Ring (+-*-ring p-2)


open Duality
open Lemmas0 1


lemma-M↓CZ : ∀ x* -> let x = x* .proj₁ in
  M x* ↓ • CZ ≈ CZ^ x • M x* ↓
lemma-M↓CZ x*@(x , nz) = begin 
  M x* ↓ • CZ ≈⟨ lemma-M↓CZ^k x ₁ nz  ⟩
  CZ^ (₁ * x) • M x* ↓ ≈⟨ cleft refl' (Eq.cong CZ^ (*-identityˡ x)) ⟩
  CZ^ x • M x* ↓ ∎


lemma-M↑CZ : ∀ x* -> let x = x* .proj₁ in
  M x* ↑ • CZ ≈ CZ^ x • M x* ↑
lemma-M↑CZ x*@(x , nz) = begin 
  M x* ↑ • CZ ≈⟨ lemma-M↑CZ^k x ₁ nz  ⟩
  CZ^ (₁ * x) • M x* ↑ ≈⟨ cleft refl' (Eq.cong CZ^ (*-identityˡ x)) ⟩
  CZ^ x • M x* ↑ ∎

lemma-CX-CX' : ∀ k -> H • CZ^ k • H ^ 3 ≈ H ^ 3 • CZ^ (- k) • H
lemma-CX-CX' k = begin
  H • CZ^ k • H ^ 3 ≈⟨ special-assoc (□ ^ 5) (□ • □ ^ 3 • □) auto ⟩
  H • (CZ^ k • HH) • H ≈⟨ cright cleft sym (lemma-semi-HH↓-CZ^k'' k) ⟩
  H • (HH • CZ^ (- k)) • H ≈⟨ special-assoc (□ • (□ ^ 2 • □) • □) (□ ^ 3 • □ ^ 2) auto ⟩
  H ^ 3 • CZ^ (- k) • H ∎




lemma-MHS| : ∀ m* k ->
  let
  m⁻¹ = (m* ⁻¹) .proj₁
  -m⁻¹ = - m⁻¹
  in ⟦ m* , HS^ k ⟧ₘ₊ • CZ ≈ (H ^ 3 • CZ^ -m⁻¹  • H) • ⟦ m* , HS^ k ⟧ₘ₊
lemma-MHS| m* k = begin
  ⟦ m* , HS^ k ⟧ₘ₊ • CZ ≈⟨ special-assoc ((□ • □ ^ 2) • □) (□ ^ 2 • □ ^ 2) auto ⟩
  (⟦ m* ⟧ₘ • H) • (S^ k • CZ) ≈⟨ cong (sym (semi-HM' m*)) (word-comm (toℕ k) 1 (sym (axiom comm-CZ-S↓))) ⟩
  (H • ⟦ m* ⁻¹ ⟧ₘ) • (CZ • S^ k) ≈⟨ special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ⟩
  H • (⟦ m* ⁻¹ ⟧ₘ • CZ) • S^ k ≈⟨ cright cleft lemma-M↓CZ (m* ⁻¹) ⟩
  H • (CZ^ m⁻¹ • ⟦ m* ⁻¹ ⟧ₘ) • S^ k ≈⟨ cright cright trans (sym left-unit) (sym (cong (axiom order-H) refl)) ⟩
  H • (CZ^ m⁻¹ • ⟦ m* ⁻¹ ⟧ₘ) • H ^ 4 • S^ k ≈⟨ special-assoc (□ • □ ^ 2 • □ ^ 4 • □) (□ ^ 2 • □ ^ 4 • □ ^ 2) auto ⟩
  (H • CZ^ m⁻¹) • (⟦ m* ⁻¹ ⟧ₘ • H ^ 3) • H • S^ k ≈⟨ cright cleft sym (aux-H³M m*)⟩
  (H • CZ^ m⁻¹) • (H ^ 3 • ⟦ m* ⟧ₘ) • H • S^ k ≈⟨ special-assoc (□ ^ 2 • □ ^ 2 • □) (□ ^ 3 • □ ^ 2) auto ⟩
  (H • CZ^ m⁻¹ • H ^ 3) • ⟦ m* ⟧ₘ • H • S^ k ≈⟨ cleft lemma-CX-CX' m⁻¹ ⟩
  (H ^ 3 • CZ^ -m⁻¹ • H) • ⟦ m* ⟧ₘ • H • S^ k  ∎
  where
  m⁻¹ = (m* ⁻¹) .proj₁
  -m⁻¹ = - m⁻¹




step-|-CZʰₕ : ∀ m* y k' s' m'* ->
  let
    m' = m'* .proj₁
    m'⁻¹ = (m'* ⁻¹) .proj₁
    m⁻¹ = (m* ⁻¹) .proj₁
    a* = m'* ⁻¹
    a = a* .proj₁
    l = m* .proj₁
    -l : ℤ ₚ
    -l = - l
    l⁻¹ : ℤ ₚ
    l⁻¹ = ((m* ⁻¹) .proj₁)
    -l⁻¹ : ℤ ₚ
    -l⁻¹ = - l⁻¹

    k′ : ℤ ₚ
    k′ = m'⁻¹
    a′ = m⁻¹
    m'0 = m'* .proj₁
    k′⁻¹ = (((m'*) ⁻¹ ⁻¹) .proj₁)
    -k′⁻¹ = - k′⁻¹
    -k′ = - k′
    -m'* = - m'0

  in
    ⟦ case-| (m* , HS^ y) (s' , m'* , HS^ k') ⟧₂ • CZ ≈ ⟦ m* *' m'* ⟧ₘ ↑ • ⟦ case-|| ((m* *' m'*) ⁻¹) (y * (m' * m')) (s' , ((-' m'*) , ε) , (m'* , HS^ k') ) ⟧₂

step-|-CZʰₕ m*@(m , nzm) y k' s' m'*@(m' , nzm') = claim
  where

  module L0 = Lemmas0 0

  m'⁻¹ = (m'* ⁻¹) .proj₁
  m⁻¹ = (m* ⁻¹) .proj₁
  -m'⁻¹ = - m'⁻¹
  m'⁻¹⁻¹ = (m'* ⁻¹ ⁻¹) .proj₁
  -m' = - m'

  a* = m'* ⁻¹
  a = a* .proj₁
  l = m* .proj₁
  -l : ℤ ₚ
  -l = - l
  l⁻¹ : ℤ ₚ
  l⁻¹ = ((m* ⁻¹) .proj₁)
  -l⁻¹ : ℤ ₚ
  -l⁻¹ = - l⁻¹

  k′ : ℤ ₚ
  k′ = m'⁻¹
  a′ = m⁻¹
  m'0 = m'* .proj₁
  k′⁻¹ = (((m'*) ⁻¹ ⁻¹) .proj₁)
  -k′⁻¹ = - k′⁻¹
  -k′ = - k′
  -m'* = - m'0
  
  claim : ⟦ case-| (m* , HS^ y) (s' , m'* , HS^ k') ⟧₂ • CZ ≈ ⟦ m* *' m'* ⟧ₘ ↑ • ⟦ case-|| ((m* *' m'*) ⁻¹) (y * (m' * m')) (s' , ((-' m'*) , ε) , (m'* , HS^ k') ) ⟧₂ 
  claim = begin
    ⟦ case-| (m* , HS^ y) (s' , m'* , HS^ k') ⟧₂ • CZ ≈⟨ trans assoc (cong refl assoc) ⟩
    CZ • ⟦ (m* , HS^ y) ⟧ₘ₊ ↑ • ⟦ (s' , m'* , HS^ k') ⟧₁ • CZ ≈⟨ refl ⟩
    CZ • (⟦ m* ⟧ₘ ↑ • H ↑ • S^ y ↑) • ⟦ (s' , m'* , HS^ k') ⟧₁ • CZ ≈⟨ special-assoc (□ • □ ^ 3 • □) (□ ^ 2 • □ ^ 2 • □) auto ⟩
    (CZ • ⟦ m* ⟧ₘ ↑) • ( H ↑ • S^ y ↑) • ⟦ (s' , m'* , HS^ k') ⟧₁ • CZ ≈⟨ cright cright assoc ⟩
    (CZ • ⟦ m* ⟧ₘ ↑) • ( H ↑ • S^ y ↑) • S^ s' • ⟦ m'* , HS^ k' ⟧ₘ₊ • CZ ≈⟨ cright cright (cright lemma-MHS| m'* k') ⟩
    (CZ • ⟦ m* ⟧ₘ ↑) • ( H ↑ • S^ y ↑) • S^ s' • (H ^ 3 • CZ^ -m'⁻¹ • H) • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ cright cright sym left-unit ⟩
    (CZ • ⟦ m* ⟧ₘ ↑) • ( H ↑ • S^ y ↑) • ε • S^ s' • (H ^ 3 • CZ^ -m'⁻¹ • H) • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ cright cright cleft sym (lemma-cong↑ _ _ (L0.aux-M-mulˡ (-' m'*))) ⟩
    (CZ • ⟦ m* ⟧ₘ ↑) • ( H ↑ • S^ y ↑) • (M ((-' m'*) ⁻¹) ↑ • M (-' m'*) ↑) • S^ s' • (H ^ 3 • CZ^ -m'⁻¹ • H) • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ cright cright special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ⟩
    (CZ • ⟦ m* ⟧ₘ ↑) • ( H ↑ • S^ y ↑) • M ((-' m'*) ⁻¹) ↑ • (M (-' m'*) ↑ • S^ s') • (H ^ 3 • CZ^ -m'⁻¹ • H) • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ cright cright cright cleft sym (lemma-comm-Sᵏ-w↑ (toℕ s') (M (-' m'*))) ⟩
    (CZ • ⟦ m* ⟧ₘ ↑) • ( H ↑ • S^ y ↑) • M ((-' m'*) ⁻¹) ↑ • (S^ s' • M (-' m'*) ↑ ) • (H ^ 3 • CZ^ -m'⁻¹ • H) • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ cright cright cright special-assoc (□ ^ 2 • □ ^ 3 • □) (□ • □ ^ 2 • □ ^ 3) auto ⟩
    (CZ • ⟦ m* ⟧ₘ ↑) • ( H ↑ • S^ y ↑) • M ((-' m'*) ⁻¹) ↑ • S^ s' • (M (-' m'*) ↑ • H ^ 3) • CZ^ -m'⁻¹ • H • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ cright cright cright cright (cleft sym (lemma-comm-Hᵏ-w↑ 3 (M (-' m'*)))) ⟩
    (CZ • ⟦ m* ⟧ₘ ↑) • ( H ↑ • S^ y ↑) • M ((-' m'*) ⁻¹) ↑ • S^ s' • (H ^ 3 • M (-' m'*) ↑ ) • CZ^ -m'⁻¹ • H • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ cright cright cright cright  special-assoc (□ ^ 2 • □ ^ 2) (□ • □ ^ 2 • □) auto ⟩
    (CZ • ⟦ m* ⟧ₘ ↑) • ( H ↑ • S^ y ↑) • M ((-' m'*) ⁻¹) ↑ • S^ s' • H ^ 3 • (M (-' m'*) ↑ • CZ^ -m'⁻¹) • H • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ cright cright cright cright cright cleft lemma-M↑CZ^k -m' -m'⁻¹ ((-' m'*) .proj₂) ⟩
    (CZ • ⟦ m* ⟧ₘ ↑) • ( H ↑ • S^ y ↑) • M ((-' m'*) ⁻¹) ↑ • S^ s' • H ^ 3 • (CZ^ (-m'⁻¹ * -m') • M (-' m'*) ↑) • H • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ cright cright cright cright cright cleft (cleft aux) ⟩
    (CZ • ⟦ m* ⟧ₘ ↑) • ( H ↑ • S^ y ↑) • M ((-' m'*) ⁻¹) ↑ • S^ s' • H ^ 3 • (CZ • M (-' m'*) ↑) • H • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ cright cright cright cright cright special-assoc (□ ^ 2 • □ ^ 2 ) (□ • □ ^  2 • □) auto ⟩
    (CZ • ⟦ m* ⟧ₘ ↑) • ( H ↑ • S^ y ↑) • M ((-' m'*) ⁻¹) ↑ • S^ s' • H ^ 3 • CZ • (M (-' m'*) ↑ • H) • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨  cright cright cright cright cright cright sym (cleft lemma-comm-H-w↑ (M (-' m'*))) ⟩
    (CZ • ⟦ m* ⟧ₘ ↑) • (H ↑ • S^ y ↑) • M ((-' m'*) ⁻¹) ↑ • S^ s' • H ^ 3 • CZ • (H • M (-' m'*) ↑) • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ special-assoc (□ ^ 2 • □ ^ 2 • □ • □ • □ • □ • □ ^ 2 • □) (□ ^ 3 • □ ^ 2 • □ • □ ^ 3 • □ ^ 2) auto ⟩
    (CZ • ⟦ m* ⟧ₘ ↑ • H ↑) • (S^ y ↑ • M ((-' m'*) ⁻¹) ↑) • S^ s' • (H ^ 3 • CZ • H) • M (-' m'*) ↑ • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ cright cleft cright lemma-cong↑ _ _ (L0.aux-MM (((-' m'*) ⁻¹) .proj₂) ((-'₁ *' m'* ⁻¹) .proj₂) aux2) ⟩
    (CZ • ⟦ m* ⟧ₘ ↑ • H ↑) • (S^ y ↑ • M (-'₁ *' m'* ⁻¹) ↑) • S^ s' • (H ^ 3 • CZ • H) • M (-' m'*) ↑ • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ cright cleft cright sym (axiom (cong↑ (M-mul -'₁ (m'* ⁻¹)))) ⟩
    (CZ • ⟦ m* ⟧ₘ ↑ • H ↑) • (S^ y ↑ • M -'₁ ↑ • M (m'* ⁻¹) ↑) • S^ s' • (H ^ 3 • CZ • H) • M (-' m'*) ↑ • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ cright cleft sym assoc ⟩
    (CZ • ⟦ m* ⟧ₘ ↑ • H ↑) • ((S^ y ↑ • M -'₁ ↑) • M (m'* ⁻¹) ↑) • S^ s' • (H ^ 3 • CZ • H) • M (-' m'*) ↑ • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ cright cleft cleft cright sym (lemma-cong↑ _ _ L0.lemma-HH-M-1) ⟩
    (CZ • ⟦ m* ⟧ₘ ↑ • H ↑) • ((S^ y ↑ • HH ↑) • M (m'* ⁻¹) ↑) • S^ s' • (H ^ 3 • CZ • H) • M (-' m'*) ↑ • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ cright cleft cleft lemma-cong↑ _ _ (PP1.word-comm (toℕ y) 1 (PB1.trans (PB1.sym (PB1.axiom comm-HHS)) (PB1.sym PB1.assoc))) ⟩
    (CZ • ⟦ m* ⟧ₘ ↑ • H ↑) • ((HH ↑ • S^ y ↑) • M (m'* ⁻¹) ↑) • S^ s' • (H ^ 3 • CZ • H) • M (-' m'*) ↑ • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ special-assoc (□ ^ 3 • ((□ ^ 2 • □) • □) • □) (□ ^ 5 • □ ^ 2 • □) auto ⟩
    (CZ • ⟦ m* ⟧ₘ ↑ • H ↑ ^ 3) • (S^ y ↑ • M (m'* ⁻¹) ↑) • S^ s' • (H ^ 3 • CZ • H) • M (-' m'*) ↑ • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ cright cleft lemma-cong↑ _ _ (L0.lemma-S^kM m'⁻¹ y ((m'* ⁻¹).proj₂)) ⟩
    (CZ • ⟦ m* ⟧ₘ ↑ • H ↑ ^ 3) • (M (m'* ⁻¹) ↑ • S^ (y * (m'⁻¹⁻¹ * m'⁻¹⁻¹)) ↑) • S^ s' • (H ^ 3 • CZ • H) • M (-' m'*) ↑ • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ special-assoc (□ ^ 5 • □ ^ 2 • □) (□ ^ 2 • (□ ^ 3 • □) • □ ^ 2) auto ⟩
    (CZ • ⟦ m* ⟧ₘ ↑) • (H ↑ ^ 3 • M (m'* ⁻¹) ↑) • S^ (y * (m'⁻¹⁻¹ * m'⁻¹⁻¹)) ↑ • S^ s' • (H ^ 3 • CZ • H) • M (-' m'*) ↑ • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ cright cong (lemma-cong↑ _ _ (L0.aux-H³M' m'*)) (cleft aux3) ⟩
    (CZ • ⟦ m* ⟧ₘ ↑) • (M m'* ↑ • H ↑ ^ 3) • S^ (y * (m' * m')) ↑ • S^ s' • (H ^ 3 • CZ • H) • M (-' m'*) ↑ • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ special-assoc (□ ^ 2 • □ ^ 2 • □) (□ ^ 3 • □ ^ 2) auto ⟩
    (CZ • ⟦ m* ⟧ₘ ↑ • M m'* ↑) • H ↑ ^ 3 • S^ (y * (m' * m')) ↑ • S^ s' • (H ^ 3 • CZ • H) • M (-' m'*) ↑ • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ cleft cright lemma-cong↑ _ _ (PB1.axiom (M-mul (m , nzm) (m' , nzm'))) ⟩
    (CZ • ⟦ m* *' m'* ⟧ₘ ↑) • H ↑ ^ 3 • S^ (y * (m' * m')) ↑ • S^ s' • (H ^ 3 • CZ • H) • M (-' m'*) ↑ • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ cleft lemma-CZM↑ ((m* *' m'*) .proj₁) ((m* *' m'*) .proj₂) ⟩
    (⟦ m* *' m'* ⟧ₘ ↑ • CZ^ (((m* *' m'*) ⁻¹) .proj₁)) • H ↑ ^ 3 • S^ (y * (m' * m')) ↑ • S^ s' • (H ^ 3 • CZ • H) • M (-' m'*) ↑ • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ special-assoc (□ ^ 2 • □) (□ ^ 3) auto ⟩
    ⟦ m* *' m'* ⟧ₘ ↑ • CZ^ (((m* *' m'*) ⁻¹) .proj₁) • H ↑ ^ 3 • S^ (y * (m' * m')) ↑ • S^ s' • (H ^ 3 • CZ • H) • (M (-' m'*)) ↑ • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ cright cright cright cright cright (cright (cleft sym right-unit)) ⟩
    ⟦ m* *' m'* ⟧ₘ ↑ • CZ^ (((m* *' m'*) ⁻¹) .proj₁) • H ↑ ^ 3 • S^ (y * (m' * m')) ↑ • S^ s' • (H ^ 3 • CZ • H) • (M (-' m'*) • ε) ↑ • ⟦ m'* , HS^ k' ⟧ₘ₊ ≈⟨ refl ⟩
    ⟦ m* *' m'* ⟧ₘ ↑ • ⟦ case-|| ((m* *' m'*) ⁻¹) (y * (m' * m')) (s' , ((-' m'*) , ε) , (m'* , HS^ k') ) ⟧₂  ∎
    where
    aux : CZ^ (-m'⁻¹ * -m') ≈ CZ
    aux = begin
      CZ^ (-m'⁻¹ * -m') ≈⟨ refl' (Eq.cong CZ^ (Eq.sym (-‿distribʳ-* -m'⁻¹ m'))) ⟩
      CZ^ (-(-m'⁻¹ * m')) ≈⟨ refl' (Eq.cong CZ^ (Eq.sym (Eq.cong -_ (-‿distribˡ-* m'⁻¹ m'))))  ⟩
      CZ^ (- -(m'⁻¹ * m')) ≈⟨ refl' (Eq.cong CZ^ (-‿involutive (m'⁻¹ * m')))  ⟩
      CZ^ ((m'⁻¹ * m')) ≈⟨ refl' (Eq.cong CZ^ (lemma-⁻¹ˡ m' {{nztoℕ {y = m'} {neq0 = m'* .proj₂}}}))  ⟩
      CZ ∎

    aux2 : ((-' m'*) ⁻¹) .proj₁ ≡ (-'₁ *' m'* ⁻¹) .proj₁
    aux2 = Eq.trans (inv-neg-comm m'*) (Eq.sym (-1*x≈-x m'⁻¹))
    aux3 : S^ (y * (m'⁻¹⁻¹ * m'⁻¹⁻¹)) ↑ ≈ S^ (y * (m' * m')) ↑
    aux3 = begin
      S^ (y * (m'⁻¹⁻¹ * m'⁻¹⁻¹)) ↑ ≈⟨ refl' (Eq.cong₂ (\ xx  yy -> S^ (y * (xx * yy)) ↑) (inv-involutive m'*) (inv-involutive m'*) ) ⟩
      S^ (y * (m' * m')) ↑ ∎


