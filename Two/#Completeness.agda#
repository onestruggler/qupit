{-# OPTIONS --safe #-}
open import Level using (0‚Ñì)

open import Relation.Binary using (Rel)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Binary.Morphism.Definitions using (Homomorphic‚ÇÇ)
open import Relation.Binary.PropositionalEquality using (_‚â°_ ; inspect ; setoid ; module ‚â°-Reasoning) renaming ([_] to [_]')
import Relation.Binary.Reasoning.Setoid as SR
import Relation.Binary.PropositionalEquality as Eq
open import Relation.Nullary.Decidable using (yes ; no)


open import Function using (_‚àò_ ; id)
open import Function.Definitions using (Injective)

open import Data.Product using (_√ó_ ; _,_ ; proj‚ÇÅ ; proj‚ÇÇ ; map‚ÇÅ ; ‚àÉ)
open import Data.Product.Relation.Binary.Pointwise.NonDependent as PW using (‚â°√ó‚â°‚áí‚â° ; Pointwise ; ‚â°‚áí‚â°√ó‚â°)
open import Data.Nat hiding (_^_ ; _+_ ; _*_ ; _%_ ; _/_)
open import Agda.Builtin.Nat using ()
import Data.Nat as Nat
open import Data.Fin hiding (_+_ ; _-_)
open import Data.Bool
open import Data.List hiding ([_])

open import Data.Maybe
open import Data.Sum using (_‚äé_ ; inj‚ÇÅ ; inj‚ÇÇ ; [_,_])
open import Data.Unit using (‚ä§ ; tt)
open import Data.Empty using (‚ä• ; ‚ä•-elim)

open import Word.Base as WB hiding (wfoldl ; _*)
open import Word.Properties
import Presentation.Base as PB
import Presentation.Properties as PP
open PP using (NFProperty ; NFProperty')
import Presentation.CosetNF as CA
import Presentation.Reidemeister-Schreier as RS
module RSF = RS.Star-Injective-Full.Reidemeister-Schreier-Full

open import Presentation.Construct.Base hiding (_*_)
import Presentation.Construct.Properties.SemiDirectProduct2 as SDP2
import Presentation.Construct.Properties.DirectProduct as DP
import Presentation.Groups.Cyclic as Cyclic


open import Data.Fin.Properties using (suc-injective ; to‚Ñï-inject‚ÇÅ ; to‚Ñï-from‚Ñï)
import Data.Nat.Properties as NP
open import Presentation.GroupLike
open import One.SymplecticZp

module One.Completeness where

open import Data.Nat.Primality
open import Data.Nat.Coprimality hiding (sym)
open import Data.Nat.GCD
open B√©zout
open import Data.Empty
open import Algebra.Properties.Group

pattern auto = Eq.refl

pattern ‚ÇÄ = zero
pattern ‚ÇÅ = suc ‚ÇÄ
pattern ‚ÇÇ = suc ‚ÇÅ
pattern ‚ÇÉ = suc ‚ÇÇ
pattern ‚ÇÑ = suc ‚ÇÉ

pattern ‚ÇÅ‚Çä n = suc n
pattern ‚ÇÇ‚Çä n = suc (suc n)
pattern ‚ÇÉ‚Çä n = suc (‚ÇÇ‚Çä n)
pattern ‚ÇÑ‚Çä n = suc (‚ÇÉ‚Çä n)

module Completeness (p-2 : ‚Ñï) (p-prime : Prime (‚ÇÇ‚Çä p-2)) where

  open import Zp.ModularArithmetic
  open PrimeModulus p-2 p-prime hiding (p)
  open NF1 p-2 p-prime hiding (p)
  open Sym‚Ñï p-2 p-prime renaming (M to Mz)

  open Symplectic-Powers p-2 p-prime
  open Symplectic-Rewriting-HH p-2 p-prime
  open Lemmas p-2 p-prime

  open PB _===_ hiding (_===_)
  open PP _===_
  open SR word-setoid
  open Pattern-Assoc

--  update-nf : ‚àÄ (nf : NF1) (g : Gen) -> NF1

  PrimitiveGen : Gen -> Set
  PrimitiveGen (Sym‚Ñï.H-gen ‚ÇÅ) = ‚ä§
  PrimitiveGen (Sym‚Ñï.S-gen ‚ÇÅ) = ‚ä§
  PrimitiveGen (Sym‚Ñï.H-gen x) = ‚ä•
  PrimitiveGen (Sym‚Ñï.S-gen x) = ‚ä•

  PrimitiveWord : Word Gen -> Set
  PrimitiveWord [ x ‚Üë] = PrimitiveGen x
  PrimitiveWord Œµ = ‚ä§
  PrimitiveWord (w ‚Ä¢ w‚ÇÅ) = PrimitiveWord w √ó PrimitiveWord w‚ÇÅ

  desugar-gen : Gen -> Word Gen
  desugar-gen (Sym‚Ñï.H-gen x) = H ^ to‚Ñï x
  desugar-gen (Sym‚Ñï.S-gen x) = S ^ to‚Ñï x

  desugar-word = desugar-gen WB.*

  lemma-H^-Prim : ‚àÄ x -> PrimitiveWord (H ^ x)
  lemma-H^-Prim ‚ÇÄ = tt
  lemma-H^-Prim ‚ÇÅ = tt
  lemma-H^-Prim (‚ÇÇ‚Çä k) = tt , (lemma-H^-Prim (‚ÇÅ‚Çä k))
  
  lemma-S^-Prim : ‚àÄ x -> PrimitiveWord (S ^ x)
  lemma-S^-Prim ‚ÇÄ = tt
  lemma-S^-Prim ‚ÇÅ = tt
  lemma-S^-Prim (‚ÇÇ‚Çä k) = tt , (lemma-S^-Prim (‚ÇÅ‚Çä k))
  
  lemma-desugar-gen : (g : Gen) -> PrimitiveWord (desugar-gen g)
  lemma-desugar-gen (Sym‚Ñï.H-gen x) = lemma-H^-Prim (to‚Ñï x)
  lemma-desugar-gen (Sym‚Ñï.S-gen x) = lemma-S^-Prim (to‚Ñï x)

  lemma-desugar-word : (w : Word Gen) -> PrimitiveWord (desugar-word w)
  lemma-desugar-word [ x ‚Üë] = lemma-desugar-gen x
  lemma-desugar-word Œµ = tt
  lemma-desugar-word (w ‚Ä¢ w‚ÇÅ) = (lemma-desugar-word w) , (lemma-desugar-word w‚ÇÅ)

  lemma-desugar-gen-‚âà : (g : Gen) -> desugar-gen g ‚âà [ g ‚Üë]
  lemma-desugar-gen-‚âà (Sym‚Ñï.H-gen x) = sym (axiom (derived-H x))
  lemma-desugar-gen-‚âà (Sym‚Ñï.S-gen x) = sym (axiom (derived-S x))

  lemma-desugar-word-‚âà : (w : Word Gen) -> desugar-word w ‚âà w
  lemma-desugar-word-‚âà [ x ‚Üë] = lemma-desugar-gen-‚âà x
  lemma-desugar-word-‚âà Œµ = refl
  lemma-desugar-word-‚âà (w ‚Ä¢ w‚ÇÅ) = cong (lemma-desugar-word-‚âà w) (lemma-desugar-word-‚âà w‚ÇÅ)


  Lemma-single-qupit-completeness :
    
    ‚àÄ (nf : NF1) (g : Gen) (pg : PrimitiveGen g) ->
    -----------------------------------------------
    ‚àÉ \ nf' -> ‚ü¶ nf ‚üß ‚Ä¢ [ g ‚Üë] ‚âà ‚ü¶ nf' ‚üß
    
  Lemma-single-qupit-completeness nf@(s ‚àô m ‚àô Œµ) (Sym‚Ñï.H-gen ‚ÇÅ) pg = (s ‚àô m ‚àô HS ‚ÇÄ) , claim
    where
    claim : (‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò ‚Ä¢ Œµ) ‚Ä¢ [ H-gen ‚ÇÅ ‚Üë] ‚âà ‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò ‚Ä¢ H ‚Ä¢ S^ ‚ÇÄ
    claim = begin
      (‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò ‚Ä¢ Œµ) ‚Ä¢ H ‚âà‚ü® _‚âà_.cong (_‚âà_.cong refl right-unit) refl ‚ü©
      (‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò) ‚Ä¢ H ‚âà‚ü® by-assoc auto ‚ü©
      (‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò) ‚Ä¢ H ‚Ä¢ Œµ ‚âà‚ü® (cright cright _‚âà_.sym (axiom (derived-S ‚ÇÄ))) ‚ü©
      (‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò) ‚Ä¢ H ‚Ä¢ S^ ‚ÇÄ ‚âà‚ü® assoc ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò ‚Ä¢ H ‚Ä¢ S^ ‚ÇÄ ‚àé
  Lemma-single-qupit-completeness nf@(s ‚àô M x ‚àô HS ‚ÇÄ) (Sym‚Ñï.H-gen ‚ÇÅ) pg = nf' , claim
    where
    x'  = x *' -'‚ÇÅ
    nf' = s ‚àô M x' ‚àô Œµ
    claim : ‚ü¶ s ‚àô M x ‚àô HS ‚ÇÄ ‚üß ‚Ä¢ [ H-gen ‚ÇÅ ‚Üë] ‚âà ‚ü¶ nf' ‚üß
    claim = begin
      ‚ü¶ s ‚àô M x ‚àô HS ‚ÇÄ ‚üß ‚Ä¢ [ H-gen ‚ÇÅ ‚Üë] ‚âà‚ü® (cleft (cright (cright (cright axiom (derived-S ‚ÇÄ))))) ‚ü©
      (‚ü¶ s ‚üß‚Çõ ‚Ä¢ Mz x ‚Ä¢ (H ‚Ä¢ Œµ)) ‚Ä¢ H ‚âà‚ü® trans assoc (cright assoc) ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ Mz x ‚Ä¢ (H ‚Ä¢ Œµ) ‚Ä¢ H ‚âà‚ü® (cright cright cong right-unit refl) ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ Mz x ‚Ä¢ HH ‚âà‚ü® (cright cright lemma-HH-M-1) ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ Mz x ‚Ä¢ Mz -'‚ÇÅ ‚âà‚ü® (cright axiom (M-mul x -'‚ÇÅ)) ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ Mz (x *' -'‚ÇÅ) ‚âà‚ü® sym (cong refl right-unit) ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ Mz (x *' -'‚ÇÅ) ‚Ä¢ Œµ ‚âà‚ü® refl ‚ü©
      ‚ü¶ nf' ‚üß ‚àé
    
  Lemma-single-qupit-completeness nf@(ùïä l ‚àô M (y , nzy) ‚àô HS x@(‚ÇÅ‚Çä k')) (Sym‚Ñï.H-gen ‚ÇÅ) pg = nf' , claim
    where
    x' : ‚Ñ§* ‚Çö
    x' = (x , Œª ())
    nz = x' .proj‚ÇÇ
    x‚Åª¬π = ((x , nz) ‚Åª¬π) .proj‚ÇÅ
    x‚Åª¬π‚Åª¬π = (((x , nz) ‚Åª¬π) ‚Åª¬π) .proj‚ÇÅ
    -x‚Åª¬π = - x‚Åª¬π
    -y/x' = (((y , nzy) *' ((x , nz) ‚Åª¬π)) *' -'‚ÇÅ)
    -y/x = -y/x' .proj‚ÇÅ

    nf' = ùïä (l + -x‚Åª¬π * (y * y)) ‚àô M -y/x' ‚àô (HS -x‚Åª¬π)
    claim : ‚ü¶ ùïä l ‚àô M (y , nzy) ‚àô HS (‚ÇÅ‚Çä k') ‚üß ‚Ä¢ [ H-gen ‚ÇÅ ‚Üë] ‚âà ‚ü¶ nf' ‚üß
    claim = begin
      ‚ü¶ ùïä l ‚àô M (y , nzy) ‚àô HS (‚ÇÅ‚Çä k') ‚üß ‚Ä¢ [ H-gen ‚ÇÅ ‚Üë] ‚âà‚ü® trans assoc (cong refl assoc) ‚ü©
      S^ l ‚Ä¢ Mz (y , nzy) ‚Ä¢ (H ‚Ä¢ S^ (‚ÇÅ‚Çä k')) ‚Ä¢ H ‚âà‚ü® (cright cright assoc) ‚ü©
      S^ l ‚Ä¢ Mz (y , nzy) ‚Ä¢ H ‚Ä¢ S^ (‚ÇÅ‚Çä k') ‚Ä¢ H ‚âà‚ü® (cright derived-7 x y nz nzy) ‚ü©
      S^ l ‚Ä¢ S^ (-x‚Åª¬π * (y * y)) ‚Ä¢ Mz -y/x' ‚Ä¢ (H ‚Ä¢ S^ -x‚Åª¬π) ‚âà‚ü® sym assoc ‚ü©
      (S^ l ‚Ä¢ S^ (-x‚Åª¬π * (y * y))) ‚Ä¢ Mz -y/x' ‚Ä¢ (H ‚Ä¢ S^ -x‚Åª¬π) ‚âà‚ü® (cleft lemma-S^k+l l (-x‚Åª¬π * (y * y))) ‚ü©
      ‚ü¶ nf' ‚üß ‚àé
  
  Lemma-single-qupit-completeness nf@(ùïä l ‚àô M (y , nzy) ‚àô Œµ) (Sym‚Ñï.S-gen ‚ÇÅ) pg = nf' , claim
    where
    nf' = ùïä (l + y * y) ‚àô M (y , nzy) ‚àô Œµ
    claim : ‚ü¶ ùïä l ‚àô M (y , nzy) ‚àô Œµ ‚üß ‚Ä¢ [ S-gen ‚ÇÅ ‚Üë] ‚âà ‚ü¶ nf' ‚üß
    claim = begin
      ‚ü¶ ùïä l ‚àô M (y , nzy) ‚àô Œµ ‚üß ‚Ä¢ [ S-gen ‚ÇÅ ‚Üë] ‚âà‚ü® trans assoc (cong refl assoc) ‚ü©
      S^ l ‚Ä¢ Mz (y , nzy) ‚Ä¢ Œµ ‚Ä¢ [ S-gen ‚ÇÅ ‚Üë] ‚âà‚ü® cong refl (cong refl left-unit) ‚ü©
      S^ l ‚Ä¢ Mz (y , nzy) ‚Ä¢ S ‚âà‚ü® (cright axiom (semi-MS (y , nzy))) ‚ü©
      S^ l ‚Ä¢ S^ (y * y) ‚Ä¢ Mz (y , nzy) ‚âà‚ü® sym assoc ‚ü©
      (S^ l ‚Ä¢ S^ (y * y)) ‚Ä¢ Mz (y , nzy) ‚âà‚ü® (cleft lemma-S^k+l l (y * y)) ‚ü©
      S^ (l + (y * y)) ‚Ä¢ Mz (y , nzy) ‚âà‚ü® sym (cong refl right-unit) ‚ü©
      ‚ü¶ nf' ‚üß ‚àé
      
  Lemma-single-qupit-completeness nf@(s ‚àô m ‚àô HS k) (Sym‚Ñï.S-gen ‚ÇÅ) pg = nf' , claim
    where
    k' = k + ‚ÇÅ
    nf' = s ‚àô m ‚àô HS k'
    claim : ‚ü¶ s ‚àô m ‚àô HS k ‚üß ‚Ä¢ [ S-gen ‚ÇÅ ‚Üë] ‚âà ‚ü¶ nf' ‚üß
    claim = begin
      ‚ü¶ s ‚àô m ‚àô HS k ‚üß ‚Ä¢ [ S-gen ‚ÇÅ ‚Üë] ‚âà‚ü® trans assoc (cong refl assoc) ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò ‚Ä¢ (H ‚Ä¢ S^ k) ‚Ä¢ S ‚âà‚ü® refl ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò ‚Ä¢ (H ‚Ä¢ S^ k) ‚Ä¢ S^ ‚ÇÅ ‚âà‚ü® (cright cright assoc) ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò ‚Ä¢ H ‚Ä¢ S^ k ‚Ä¢ S^ ‚ÇÅ ‚âà‚ü® (cright cright cright lemma-S^k+l k ‚ÇÅ) ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò ‚Ä¢ H ‚Ä¢ S^ (k + ‚ÇÅ) ‚âà‚ü® refl ‚ü©t
      ‚ü¶ nf' ‚üß ‚àé

  Corollary-single-qupit-completeness :
    
    ‚àÄ (nf : NF1) (w : Word Gen) (pw : PrimitiveWord w) ->
    -----------------------------------------------
    ‚àÉ \ nf' -> ‚ü¶ nf ‚üß ‚Ä¢ w ‚âà ‚ü¶ nf' ‚üß

  Corollary-single-qupit-completeness nf [ x ‚Üë] pw = Lemma-single-qupit-completeness nf x pw
  Corollary-single-qupit-completeness nf Œµ pw = nf , right-unit
  Corollary-single-qupit-completeness nf (w ‚Ä¢ w‚ÇÅ) (pwl , pwr) with Corollary-single-qupit-completeness nf w pwl
  ... | (nf' , ih) with Corollary-single-qupit-completeness nf' w‚ÇÅ pwr
  ... | (nf'' , ih2) = nf'' , claim
    where
    claim : (‚ü¶ nf ‚üß ‚Ä¢ w ‚Ä¢ w‚ÇÅ) ‚âà ‚ü¶ nf'' ‚üß
    claim = begin
      (‚ü¶ nf ‚üß ‚Ä¢ w ‚Ä¢ w‚ÇÅ) ‚âà‚ü® sym assoc ‚ü©
      (‚ü¶ nf ‚üß ‚Ä¢ w) ‚Ä¢ w‚ÇÅ ‚âà‚ü® (cleft ih) ‚ü©
      (‚ü¶ nf' ‚üß) ‚Ä¢ w‚ÇÅ ‚âà‚ü® ih2 ‚ü©
      ‚ü¶ nf'' ‚üß ‚àé
    

  Theorem-single-qupit-completeness :
    
    ‚àÄ (nf : NF1) (g : Gen) ->
    ------------------------------------
    ‚àÉ \ nf' -> ‚ü¶ nf ‚üß ‚Ä¢ [ g ‚Üë] ‚âà ‚ü¶ nf' ‚üß
    
  Theorem-single-qupit-completeness nf g with Corollary-single-qupit-completeness nf (desugar-gen g) (lemma-desugar-gen g)
  ... | (nf' , hyp) = nf' , claim
    where
    claim : ‚ü¶ nf ‚üß ‚Ä¢ [ g ‚Üë] ‚âà ‚ü¶ nf' ‚üß
    claim = begin
      ‚ü¶ nf ‚üß ‚Ä¢ [ g ‚Üë] ‚âà‚ü® sym (cright lemma-desugar-gen-‚âà g) ‚ü©
      ‚ü¶ nf ‚üß ‚Ä¢ desugar-gen g ‚âà‚ü® hyp ‚ü©
      ‚ü¶ nf' ‚üß ‚àé

  nf‚ÇÄ = (ùïä ‚ÇÄ ‚àô M (‚ÇÅ , Œª ()) ‚àô Œµ)
  lemma-nf‚ÇÄ : ‚ü¶ nf‚ÇÄ ‚üß ‚âà Œµ
  lemma-nf‚ÇÄ = begin
    ‚ü¶ nf‚ÇÄ ‚üß ‚âà‚ü® cong (axiom (derived-S ‚ÇÄ)) (cong (sym lemma-M1) refl) ‚ü©
    Œµ ‚Ä¢ Œµ ‚Ä¢ Œµ ‚âà‚ü® trans left-unit left-unit ‚ü©
    Œµ ‚àé

  Theorem-single-qupit-completeness-nfw :
    
    ‚àÄ (w : Word Gen) ->
    ----------------------
    ‚àÉ \ nf' -> w ‚âà ‚ü¶ nf' ‚üß

  Theorem-single-qupit-completeness-nfw [ x ‚Üë] with Theorem-single-qupit-completeness nf‚ÇÄ x
  ... | (nf' , hyp) = nf' , claim
    where
    claim : [ x ‚Üë] ‚âà ‚ü¶ nf' ‚üß
    claim = begin
      [ x ‚Üë] ‚âà‚ü® sym left-unit ‚ü©
      Œµ ‚Ä¢ [ x ‚Üë] ‚âà‚ü® cleft sym lemma-nf‚ÇÄ ‚ü©
      (S^ ‚ÇÄ ‚Ä¢ M‚ÇÅ ‚Ä¢ Œµ) ‚Ä¢ [ x ‚Üë] ‚âà‚ü® hyp ‚ü©
      ‚ü¶ nf' ‚üß ‚àé
  Theorem-single-qupit-completeness-nfw Œµ = nf‚ÇÄ , sym lemma-nf‚ÇÄ
  Theorem-single-qupit-completeness-nfw (w ‚Ä¢ w‚ÇÅ) with Theorem-single-qupit-completeness-nfw w
  ... | (nf1 , ih1) with Corollary-single-qupit-completeness nf1 (desugar-word w‚ÇÅ) (lemma-desugar-word w‚ÇÅ)
  ... | (nf2 , hyp)= nf2 , claim
    where
    claim : w ‚Ä¢ w‚ÇÅ ‚âà ‚ü¶ nf2 ‚üß
    claim = begin
      w ‚Ä¢ w‚ÇÅ ‚âà‚ü® cong ih1 refl ‚ü©
      ‚ü¶ nf1 ‚üß ‚Ä¢ w‚ÇÅ ‚âà‚ü® (cright sym (lemma-desugar-word-‚âà w‚ÇÅ)) ‚ü©
      ‚ü¶ nf1 ‚üß ‚Ä¢ desugar-word w‚ÇÅ ‚âà‚ü® hyp ‚ü©
      ‚ü¶ nf2 ‚üß ‚àé

module Iso (p-2 : ‚Ñï) (p-prime : Prime (‚ÇÇ‚Çä p-2)) where
  p : ‚Ñï
  p = ‚ÇÇ‚Çä p-2
  open import Zp.ModularArithmetic
  open PrimeModulus p-2 p-prime hiding (p ; 0‚Çö ; 1‚Çö ; 0‚Çö‚â¢1‚Çö)

  module Sym  = Symplectic p-2 p-prime
  module SymDerived  = Sym‚Ñï p-2 p-prime
  open Sym renaming (grouplike to grouplike‚ÇÅ ; Gen to Gen‚ÇÅ) using ()
  open SymDerived renaming (grouplike to grouplike‚ÇÇ ; Gen to Gen‚ÇÇ) using ()



  f : Sym.Gen -> SymDerived.Gen
  f Symplectic.H-gen = SymDerived.H-gen ‚ÇÅ
  f Symplectic.S-gen = SymDerived.S-gen ‚ÇÅ

  g : SymDerived.Gen -> Word Sym.Gen
  g (SymDerived.H-gen k) = Sym.H ^ to‚Ñï k
  g (SymDerived.S-gen k) = Sym.S ^ to‚Ñï k
  

  open PB Sym._===_ renaming (_===_ to _===‚ÇÅ_ ; _‚âà_ to _‚âà‚ÇÅ_) using ()
  open PB SymDerived._===_ renaming (_===_ to _===‚ÇÇ_ ; _‚âà_ to _‚âà‚ÇÇ_) using ()

  open import Presentation.Morphism _===‚ÇÅ_ _===‚ÇÇ_
  open GroupMorphs grouplike‚ÇÅ grouplike‚ÇÇ

  open PP Sym._===_ renaming (by-assoc-and to by-assoc-and‚ÇÅ ; word-setoid to ws‚ÇÅ)
  open PP SymDerived._===_ renaming (by-assoc-and to by-assoc-and‚ÇÇ ; word-setoid to ws‚ÇÇ ; by-assoc to by-assoc‚ÇÇ) using ()

  open PB hiding (_===_)
  open SymDerived hiding (p)

  f* = wmap f
  f' = [_‚Üë] ‚àò f
  f'* = f' WB.*
  
  lemma-f* : ‚àÄ k -> f* (Sym.S ^ k) ‚âà‚ÇÇ SymDerived.S ^ k
  lemma-f* ‚ÇÄ = _‚âà‚ÇÇ_.refl
  lemma-f* ‚ÇÅ = _‚âà‚ÇÇ_.refl
  lemma-f* (‚ÇÇ‚Çä k) = cong _‚âà‚ÇÇ_.refl (lemma-f* (‚ÇÅ‚Çä k))

  lemma-f'* : ‚àÄ k -> f'* (Sym.S ^ k) ‚âà‚ÇÇ SymDerived.S ^ k
  lemma-f'* ‚ÇÄ = _‚âà‚ÇÇ_.refl
  lemma-f'* ‚ÇÅ = _‚âà‚ÇÇ_.refl
  lemma-f'* (‚ÇÇ‚Çä k) = cong _‚âà‚ÇÇ_.refl (lemma-f'* (‚ÇÅ‚Çä k))

  lemma-f'*-H : ‚àÄ k -> f'* (Sym.H ^ k) ‚âà‚ÇÇ SymDerived.H ^ k
  lemma-f'*-H ‚ÇÄ = _‚âà‚ÇÇ_.refl
  lemma-f'*-H ‚ÇÅ = _‚âà‚ÇÇ_.refl
  lemma-f'*-H (‚ÇÇ‚Çä k) = cong _‚âà‚ÇÇ_.refl (lemma-f'*-H (‚ÇÅ‚Çä k))

  lemma-f'*-M : ‚àÄ x -> f'* (Sym.M x) ‚âà‚ÇÇ SymDerived.M x
  lemma-f'*-M x' = begin
    f'* (Sym.M x') ‚âà‚ü® _‚âà‚ÇÇ_.refl ‚ü©
    f'* (Sym.S^ x ‚Ä¢ Sym.H ‚Ä¢ Sym.S^ x‚Åª¬π ‚Ä¢ Sym.H ‚Ä¢ Sym.S^ x ‚Ä¢ Sym.H) ‚âà‚ü® _‚âà‚ÇÇ_.refl ‚ü©
    f'* (Sym.S^ x) ‚Ä¢ f'* Sym.H ‚Ä¢ f'* (Sym.S^ x‚Åª¬π) ‚Ä¢ f'* Sym.H ‚Ä¢ f'* (Sym.S^ x) ‚Ä¢ f'* (Sym.H) ‚âà‚ü® cong (lemma-f'* (to‚Ñï x)) (cong _‚âà‚ÇÇ_.refl (cong (lemma-f'* (to‚Ñï x‚Åª¬π)) (cong _‚âà‚ÇÇ_.refl (cong (lemma-f'* (to‚Ñï x)) _‚âà‚ÇÇ_.refl)))) ‚ü©
    (S ^ to‚Ñï x) ‚Ä¢ H ‚Ä¢ (S ^ to‚Ñï x‚Åª¬π) ‚Ä¢ H ‚Ä¢ (S ^ to‚Ñï x) ‚Ä¢ (H) ‚âà‚ü® cong (_‚âà‚ÇÇ_.sym (_‚âà‚ÇÇ_.axiom (derived-S x))) (cong _‚âà‚ÇÇ_.refl (cong (_‚âà‚ÇÇ_.sym (_‚âà‚ÇÇ_.axiom (derived-S x‚Åª¬π))) (cong _‚âà‚ÇÇ_.refl (_‚âà‚ÇÇ_.sym (_‚âà‚ÇÇ_.cong (_‚âà‚ÇÇ_.axiom (derived-S x)) _‚âà‚ÇÇ_.refl))))) ‚ü©
    (S^ x) ‚Ä¢ H ‚Ä¢ (S^ x‚Åª¬π) ‚Ä¢ H ‚Ä¢ (S^ x) ‚Ä¢ (H) ‚âà‚ü® _‚âà‚ÇÇ_.refl ‚ü©
    M x' ‚àé
    where
    open SR ws‚ÇÇ
    x = x' .proj‚ÇÅ
    x‚Åª¬π = ((x' ‚Åª¬π) .proj‚ÇÅ )
    

  f-well-defined : ‚àÄ {w v} -> w ===‚ÇÅ v -> f'* w ‚âà‚ÇÇ f'* v
  f-well-defined Symplectic.order-S = begin
    f'* (Sym.S ‚Ä¢ Sym.S ^ ‚ÇÅ‚Çä p-2) ‚â°‚ü® lemma-* ([ Sym.S-gen ‚Üë] ‚Ä¢ Sym.S ^ ‚ÇÅ‚Çä p-2) ‚ü©
    (wmap f) (Sym.S ‚Ä¢ Sym.S ^ ‚ÇÅ‚Çä p-2) ‚âà‚ü® lemma-f* (‚ÇÇ‚Çä p-2) ‚ü©
    SymDerived.S ^ p ‚âà‚ü® _‚âà‚ÇÇ_.axiom order-S ‚ü©
    f'* Œµ ‚àé
    where
    open SR ws‚ÇÇ
  f-well-defined Symplectic.order-H = axiom order-H
  f-well-defined Symplectic.order-SH = _‚âà‚ÇÇ_.axiom order-SH
  f-well-defined Symplectic.comm-HHS = _‚âà‚ÇÇ_.axiom comm-HHS
  f-well-defined (Symplectic.M-mul x y) = begin
    f'* (Sym.M x ‚Ä¢ Sym.M y) ‚âà‚ü® _‚âà‚ÇÇ_.refl ‚ü©
    f'* (Sym.M x) ‚Ä¢ f'* (Sym.M y) ‚âà‚ü® cong (lemma-f'*-M x) (lemma-f'*-M y) ‚ü©
    (SymDerived.M x) ‚Ä¢ (SymDerived.M y) ‚âà‚ü® axiom (M-mul x y) ‚ü©
    (SymDerived.M (x *' y)) ‚âà‚ü® sym (lemma-f'*-M (x *' y)) ‚ü©
    f'* (Sym.M (x *' y)) ‚àé
    where
    open SR ws‚ÇÇ
  f-well-defined (Symplectic.semi-MS (x , nz)) = begin
    f'* (Sym.M (x , nz) ‚Ä¢ Sym.S) ‚âà‚ü® cong (lemma-f'*-M (x , nz)) (lemma-f'* ‚ÇÅ) ‚ü©
    (M (x , nz) ‚Ä¢ S) ‚âà‚ü® _‚âà‚ÇÇ_.axiom (semi-MS (x , nz)) ‚ü©
    (S^ (x * x) ‚Ä¢ M (x , nz)) ‚âà‚ü® _‚âà‚ÇÇ_.cong (_‚âà‚ÇÇ_.axiom (derived-S (x * x))) _‚âà‚ÇÇ_.refl ‚ü©
    (S ^ to‚Ñï (x * x) ‚Ä¢ M (x , nz)) ‚âà‚ü® cong (sym (lemma-f'* (to‚Ñï (x * x)))) (sym (lemma-f'*-M (x , nz))) ‚ü©
    f'* (Sym.S^ (x * x) ‚Ä¢ Sym.M (x , nz)) ‚àé
    where
    open SR ws‚ÇÇ

  g* = g WB.*

  lemma-g* : ‚àÄ k -> g* (S ^ k) ‚âà‚ÇÅ Sym.S ^ k
  lemma-g* ‚ÇÄ = refl
  lemma-g* ‚ÇÅ = refl
  lemma-g* (‚ÇÇ‚Çä k) = cong refl (lemma-g* (‚ÇÅ‚Çä k))

  lemma-g*-H : ‚àÄ k -> g* (H ^ k) ‚âà‚ÇÅ Sym.H ^ k
  lemma-g*-H ‚ÇÄ = refl
  lemma-g*-H ‚ÇÅ = refl
  lemma-g*-H (‚ÇÇ‚Çä k) = cong refl (lemma-g*-H (‚ÇÅ‚Çä k))

  lemma-g*'-H : ‚àÄ k -> g* (H^ k) ‚âà‚ÇÅ Sym.H ^ to‚Ñï k
  lemma-g*'-H ‚ÇÄ = refl
  lemma-g*'-H ‚ÇÅ = refl
  lemma-g*'-H ‚ÇÇ = refl
  lemma-g*'-H ‚ÇÉ = refl


  lemma-g*-M : ‚àÄ x -> g* (M x) ‚âà‚ÇÅ Sym.M x
  lemma-g*-M x' = begin
    g* (M x') ‚âà‚ü® refl ‚ü©
    g* (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H) ‚âà‚ü® refl ‚ü©
    g* (S^ x) ‚Ä¢ g* H ‚Ä¢ g* (S^ x‚Åª¬π) ‚Ä¢ g* H ‚Ä¢ g* (S^ x) ‚Ä¢ g* (H) ‚âà‚ü® cong (sym ( lemma-g* (to‚Ñï x))) (cong refl (cong (sym ( lemma-g* (to‚Ñï x‚Åª¬π))) (cong refl (sym (cong ( lemma-g* (to‚Ñï x)) refl))))) ‚ü©
    g* (S ^ to‚Ñï x) ‚Ä¢ g* H ‚Ä¢ g* (S ^ to‚Ñï x‚Åª¬π) ‚Ä¢ g* H ‚Ä¢ g* (S ^ to‚Ñï x) ‚Ä¢ g* (H) ‚âà‚ü® cong (lemma-g* (to‚Ñï x)) (cong refl (cong (lemma-g* (to‚Ñï x‚Åª¬π)) (cong refl (cong (lemma-g* (to‚Ñï x)) refl)))) ‚ü©
    (Sym.S ^ to‚Ñï x) ‚Ä¢ Sym.H ‚Ä¢ (Sym.S ^ to‚Ñï x‚Åª¬π) ‚Ä¢ Sym.H ‚Ä¢ (Sym.S ^ to‚Ñï x) ‚Ä¢ (Sym.H) ‚âà‚ü® refl ‚ü©
    (Sym.S^ x) ‚Ä¢ Sym.H ‚Ä¢ (Sym.S^ x‚Åª¬π) ‚Ä¢ Sym.H ‚Ä¢ (Sym.S^ x) ‚Ä¢ (Sym.H) ‚âà‚ü® refl ‚ü©
    Sym.M x' ‚àé
    where
    open SR ws‚ÇÅ
    x = x' .proj‚ÇÅ
    x‚Åª¬π = ((x' ‚Åª¬π) .proj‚ÇÅ )

  g-well-defined : ‚àÄ {w v} -> w ===‚ÇÇ v -> g* w ‚âà‚ÇÅ g* v
  g-well-defined Sym‚Ñï.order-S = begin
    g* (S ‚Ä¢ S ^ ‚ÇÅ‚Çä p-2) ‚âà‚ü® lemma-g* p ‚ü©
    (Sym.S ^ p) ‚âà‚ü® axiom Sym.order-S ‚ü©
    g* Œµ ‚àé
    where open SR ws‚ÇÅ
  g-well-defined Sym‚Ñï.order-H = axiom Sym.order-H
  g-well-defined Sym‚Ñï.order-SH = axiom Sym.order-SH
  g-well-defined Sym‚Ñï.comm-HHS = axiom Sym.comm-HHS
  g-well-defined (Sym‚Ñï.M-mul x y) = begin
    g* (M x ‚Ä¢ M y) ‚âà‚ü® refl ‚ü©
    g* (M x) ‚Ä¢ g* (M y) ‚âà‚ü® cong (lemma-g*-M x) (lemma-g*-M y) ‚ü©
    (Sym.M x) ‚Ä¢ (Sym.M y) ‚âà‚ü® axiom (Sym.M-mul x y) ‚ü©
    (Sym.M (x *' y)) ‚âà‚ü® sym (lemma-g*-M (x *' y)) ‚ü©
    g* (M (x *' y)) ‚àé
    where
    open SR ws‚ÇÅ
  g-well-defined (Sym‚Ñï.semi-MS (x , nz)) = begin
    g* (M (x , nz) ‚Ä¢ S) ‚âà‚ü® cong (lemma-g*-M (x , nz)) (lemma-g* ‚ÇÅ) ‚ü©
    (Sym.M (x , nz) ‚Ä¢ Sym.S) ‚âà‚ü® axiom (Sym.semi-MS (x , nz)) ‚ü©
    (Sym.S^ (x * x) ‚Ä¢ Sym.M (x , nz)) ‚âà‚ü® cong (refl) refl ‚ü©
    (Sym.S ^ to‚Ñï (x * x) ‚Ä¢ Sym.M (x , nz)) ‚âà‚ü® cong (sym (lemma-g* (to‚Ñï (x * x)))) (sym (lemma-g*-M (x , nz))) ‚ü©
    g* (S ^ to‚Ñï (x * x) ‚Ä¢ M (x , nz)) ‚âà‚ü® cong (sym (g-well-defined (derived-S (from‚Ñï< _)))) refl ‚ü©
    g* (S^ (x * x) ‚Ä¢ M (x , nz)) ‚àé
    where
    open SR ws‚ÇÅ
  g-well-defined (Sym‚Ñï.derived-S k) = begin
    g* [ S-gen k ‚Üë] ‚âà‚ü® refl ‚ü©
    Sym.S ^ to‚Ñï k ‚âà‚ü® sym (lemma-g* (to‚Ñï k)) ‚ü©
    g* (S ^ to‚Ñï k) ‚àé
    where
    open SR ws‚ÇÅ
  g-well-defined (Sym‚Ñï.derived-H k) = begin
    g* [ H-gen k ‚Üë] ‚âà‚ü® lemma-g*'-H k ‚ü©
    Sym.H ^ to‚Ñï k ‚âà‚ü® sym (lemma-g*-H (to‚Ñï k)) ‚ü©
    g* (H ^ to‚Ñï k) ‚àé
    where
    open SR ws‚ÇÅ


  f-left-inv-gen : ‚àÄ x -> [ x ‚Üë] ‚âà‚ÇÇ (f'*) (g x)
  f-left-inv-gen (SymDerived.H-gen k) = begin
    [ H-gen k ‚Üë] ‚âà‚ü® _‚âà‚ÇÇ_.axiom (derived-H k) ‚ü©
    H ^ to‚Ñï k ‚âà‚ü® sym (lemma-f'*-H (to‚Ñï k)) ‚ü©
    f'* (Sym.H ^ to‚Ñï k) ‚àé
    where open SR ws‚ÇÇ
  f-left-inv-gen (SymDerived.S-gen k) = begin
    [ S-gen k ‚Üë] ‚âà‚ü® _‚âà‚ÇÇ_.axiom (derived-S k) ‚ü©
    S ^ to‚Ñï k ‚âà‚ü® sym (lemma-f'* (to‚Ñï k)) ‚ü©
    f'* (Sym.S ^ to‚Ñï k) ‚àé
    where open SR ws‚ÇÇ

  g-left-inv-gen : ‚àÄ x -> [ x ‚Üë] ‚âà‚ÇÅ (g*) (f' x)
  g-left-inv-gen Sym.S-gen = refl
  g-left-inv-gen Sym.H-gen = refl

  open import Algebra.Bundles using (Group)
  open import Algebra.Morphism.Structures using (module GroupMorphisms)

  open import Presentation.Morphism
  open GroupMorphisms
  module G1 = Group-Lemmas Sym.Gen Sym._===_ Sym.grouplike
  module G2 = Group-Lemmas SymDerived.Gen SymDerived._===_ SymDerived.grouplike

  Theorem-Sym-iso-SymDerived : IsGroupIsomorphism (Group.rawGroup G1.‚Ä¢-Œµ-group) (Group.rawGroup G2.‚Ä¢-Œµ-group) (f'*)
  Theorem-Sym-iso-SymDerived = StarGroupIsomorphism.isGroupIsomorphism f' g f-well-defined  f-left-inv-gen g-well-defined  g-left-inv-gen

