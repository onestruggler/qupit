{-# OPTIONS --safe #-}
open import Level using (0‚Ñì)

open import Relation.Binary using (Rel)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Binary.Morphism.Definitions using (Homomorphic‚ÇÇ)
open import Relation.Binary.PropositionalEquality using (_‚â°_ ; inspect ; setoid ; module ‚â°-Reasoning ; _‚â¢_) renaming ([_] to [_]')
import Relation.Binary.Reasoning.Setoid as SR
import Relation.Binary.PropositionalEquality as Eq
open import Relation.Nullary.Decidable using (yes ; no)


open import Function using (_‚àò_ ; id)
open import Function.Definitions using (Injective)

open import Data.Product using (_√ó_ ; _,_ ; proj‚ÇÅ ; proj‚ÇÇ ; map‚ÇÅ ; ‚àÉ)
open import Data.Product.Relation.Binary.Pointwise.NonDependent as PW using (‚â°√ó‚â°‚áí‚â° ; Pointwise ; ‚â°‚áí‚â°√ó‚â°)
open import Data.Nat hiding (_^_ ; _+_ ; _*_ ; _%_ ; _/_)
open import Agda.Builtin.Nat using ()
import Data.Nat as Nat
open import Data.Fin hiding (_+_ ; _-_)
open import Data.Bool
open import Data.List hiding ([_])

open import Data.Maybe
open import Data.Sum using (_‚äé_ ; inj‚ÇÅ ; inj‚ÇÇ ; [_,_])
open import Data.Unit using (‚ä§ ; tt)
open import Data.Empty using (‚ä• ; ‚ä•-elim)

open import Word.Base hiding (wfoldl ; _*)
open import Word.Properties
import Presentation.Base as PB
import Presentation.Properties as PP
open PP using (NFProperty ; NFProperty')
import Presentation.CosetNF as CA
import Presentation.Reidemeister-Schreier as RS
module RSF = RS.Star-Injective-Full.Reidemeister-Schreier-Full

open import Presentation.Construct.Base hiding (_*_)
import Presentation.Construct.Properties.SemiDirectProduct2 as SDP2
import Presentation.Construct.Properties.DirectProduct as DP
import Presentation.Groups.Cyclic as Cyclic


open import Data.Fin.Properties using (suc-injective ; to‚Ñï-inject‚ÇÅ ; to‚Ñï-from‚Ñï)
import Data.Nat.Properties as NP
open import Presentation.GroupLike

module One.SymplecticZp where

open import Data.Nat.Primality
open import Data.Nat.Coprimality hiding (sym)
open import Data.Nat.GCD
open B√©zout
open import Data.Empty
open import Algebra.Properties.Group

pattern auto = Eq.refl
pattern ‚ÇÄ = zero
pattern ‚ÇÅ = suc ‚ÇÄ
pattern ‚ÇÇ = suc ‚ÇÅ
pattern ‚ÇÉ = suc ‚ÇÇ
pattern ‚ÇÑ = suc ‚ÇÉ

pattern ‚ÇÅ‚Çä n = suc n
pattern ‚ÇÇ‚Çä n = suc (suc n)
pattern ‚ÇÉ‚Çä n = suc (‚ÇÇ‚Çä n)
pattern ‚ÇÑ‚Çä n = suc (‚ÇÉ‚Çä n)


module Symplectic (p-2 : ‚Ñï) (p-prime : Prime (‚ÇÇ‚Çä p-2)) where

  p : ‚Ñï
  p = ‚ÇÇ‚Çä p-2
  open import Zp.ModularArithmetic
  open PrimeModulus p-2 p-prime hiding (p ; 0‚Çö ; 1‚Çö ; 0‚Çö‚â¢1‚Çö)

  data Gen : Set where
    H-gen : Gen
    S-gen : Gen

  H : Word Gen
  H = [ H-gen ‚Üë]

  H‚Åª¬π : Word Gen
  H‚Åª¬π = H ^ 3

  HH : Word Gen
  HH = H ‚Ä¢ H

  S : Word Gen
  S = [ S-gen ‚Üë]

  S' : Word Gen
  S' = HH ‚Ä¢ S ‚Ä¢ HH

  SS : Word Gen
  SS = S ‚Ä¢ S

  X : Word Gen
  X = H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H

  Z : Word Gen
  Z = HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS

  H^ : ‚Ñ§ ‚ÇÑ -> Word Gen
  H^ k = H ^ to‚Ñï k

  S^ : ‚Ñ§ ‚Çö -> Word Gen
  S^ k = S ^ to‚Ñï k

  M : ‚Ñ§* ‚Çö -> Word Gen
  M x' = S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H
    where
    x = x' .proj‚ÇÅ
    x‚Åª¬π = ((x' ‚Åª¬π) .proj‚ÇÅ )

  infix 4 _===_
  data _===_ : WRel Gen where
    order-S : S ^ p === Œµ
    order-H : H ^ 4 === Œµ
    order-SH : (S ‚Ä¢ H) ^ 3 === Œµ
    comm-HHS : H ‚Ä¢ H ‚Ä¢ S === S ‚Ä¢ H ‚Ä¢ H
    
    M-mul : ‚àÄ (x y : ‚Ñ§* ‚Çö) -> M x ‚Ä¢ M y === M (x *' y)
    semi-MS : ‚àÄ (x : ‚Ñ§* ‚Çö) -> let x' = x .proj‚ÇÅ in M x ‚Ä¢ S === S^ (x' * x') ‚Ä¢ M x


  open PP _===_
  open PB _===_ hiding (_===_)
  grouplike : Grouplike _===_
  grouplike (H-gen) = H ^ 3 , by-assoc-and (axiom order-H) auto auto
  grouplike (S-gen) = S ^ p-1 , claim
    where
    open SR word-setoid
    claim : S ^ p-1 ‚Ä¢ S ‚âà Œµ
    claim = begin
      S ^ p-1 ‚Ä¢ S ‚âà‚ü® sym (lemma-^-+ S p-1 1) ‚ü©
      S ^ (p-1 Nat.+ 1) ‚â°‚ü® Eq.cong (S ^_) (NP.+-comm p-1 1) ‚ü©
      (S ^ p) ‚âà‚ü® axiom order-S ‚ü©
      Œµ ‚àé

module Sym‚Ñï (p-2 : ‚Ñï) (p-prime : Prime (‚ÇÇ‚Çä p-2)) where

  p : ‚Ñï
  p = ‚ÇÇ‚Çä p-2
  open import Zp.ModularArithmetic
  open PrimeModulus p-2 p-prime hiding (p ; 0‚Çö ; 1‚Çö ; 0‚Çö‚â¢1‚Çö)

  data Gen : Set where
    H-gen : ‚Ñ§ ‚ÇÑ -> Gen
    S-gen : ‚Ñ§ ‚Çö -> Gen

  H^ : ‚Ñ§ ‚ÇÑ -> Word Gen
  H^ k = [ H-gen k ‚Üë]

  S^ : ‚Ñ§ ‚Çö -> Word Gen
  S^ k = [ S-gen k ‚Üë]

  H : Word Gen
  H = [ H-gen ‚ÇÅ ‚Üë]

  H‚Åª¬π : Word Gen
  H‚Åª¬π = H ^ 3

  HH : Word Gen
  HH = H ‚Ä¢ H

  S : Word Gen
  S = [ S-gen ‚ÇÅ ‚Üë]

  S‚Åª¬π : Word Gen
  S‚Åª¬π = S ^ p-1

  S' : Word Gen
  S' = HH ‚Ä¢ S ‚Ä¢ HH

  SS : Word Gen
  SS = S ‚Ä¢ S

  X : Word Gen
  X = H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H

  Z : Word Gen
  Z = HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS

  M : ‚Ñ§* ‚Çö -> Word Gen
  M x' = S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H
    where
    x = x' .proj‚ÇÅ
    x‚Åª¬π = ((x' ‚Åª¬π) .proj‚ÇÅ )
    
  open Eq using (_‚â¢_)
  
  infix 4 _===_
  data _===_ : WRel Gen where
    order-S : S ^ p === Œµ
    order-H : H ^ 4 === Œµ
    order-SH : (S ‚Ä¢ H) ^ 3 === Œµ    
    comm-HHS : H ‚Ä¢ H ‚Ä¢ S === S ‚Ä¢ H ‚Ä¢ H
    
    M-mul : ‚àÄ (x y : ‚Ñ§* ‚Çö) -> M x ‚Ä¢ M y === M (x *' y)
    semi-MS : ‚àÄ (x : ‚Ñ§* ‚Çö) -> let x' = x .proj‚ÇÅ in M x ‚Ä¢ S === S^ (x' * x') ‚Ä¢ M x

    derived-S : ‚àÄ (k : ‚Ñ§ ‚Çö) -> S^ k === S ^ to‚Ñï k
    derived-H : ‚àÄ (k : ‚Ñ§ ‚ÇÑ) -> H^ k === H ^ to‚Ñï k


  open PP _===_
  open PB _===_ hiding (_===_)
  grouplike : Grouplike _===_
  grouplike (H-gen k) = (H ^ to‚Ñï k) ^ 3 , claim
    where
    open SR word-setoid
    claim : (H ^ to‚Ñï k) ^ 3 ‚Ä¢ H^ k ‚âà Œµ
    claim = begin
      (H ^ to‚Ñï k) ^ 3 ‚Ä¢ H^ k ‚âà‚ü® (cright axiom (derived-H k)) ‚ü©
      (H ^ to‚Ñï k) ^ 3 ‚Ä¢ H ^ to‚Ñï k ‚âà‚ü® sym (lemma-^-+ (H ^ to‚Ñï k) 3 1) ‚ü©
      (H ^ to‚Ñï k) ^ 4 ‚âà‚ü® lemma-^^' H (to‚Ñï k) 4 ‚ü©
      (H ^ 4) ^ to‚Ñï k ‚âà‚ü® lemma-^-cong (H ^ 4) Œµ (to‚Ñï k) (axiom order-H) ‚ü©
      (Œµ) ^ to‚Ñï k ‚âà‚ü® lemma-Œµ^k=Œµ (to‚Ñï k) ‚ü©
      Œµ ‚àé
  grouplike (S-gen k) = (S ^ to‚Ñï k) ^ p-1 ,  claim
    where
    open SR word-setoid
    claim : (S ^ to‚Ñï k) ^ p-1 ‚Ä¢ S^ k ‚âà Œµ
    claim = begin
      (S ^ to‚Ñï k) ^ p-1 ‚Ä¢ S^ k ‚âà‚ü® (cright axiom (derived-S k)) ‚ü©
      (S ^ to‚Ñï k) ^ p-1 ‚Ä¢ S ^ to‚Ñï k ‚âà‚ü® sym (lemma-^-+ (S ^ to‚Ñï k) p-1 1) ‚ü©
      (S ^ to‚Ñï k) ^ (p-1 Nat.+ 1) ‚âà‚ü® lemma-^^' S (to‚Ñï k) (p-1 Nat.+ 1) ‚ü©
      (S ^ (p-1 Nat.+ 1)) ^ to‚Ñï k ‚âà‚ü® lemma-^-cong (S ^ (p-1 Nat.+ 1)) (S ^ p) (to‚Ñï k) (refl' (Eq.cong (S ^_) (NP.+-comm p-1 1))) ‚ü©
      (S ^ p) ^ to‚Ñï k ‚âà‚ü® lemma-^-cong (S ^ p) Œµ (to‚Ñï k) (axiom order-S) ‚ü©
      (Œµ) ^ to‚Ñï k ‚âà‚ü® lemma-Œµ^k=Œµ (to‚Ñï k) ‚ü©
      Œµ ‚àé


-- ----------------------------------------------------------------------
-- * Data required for applying word tactics to Symplectic generators

module CommData (p-2 : ‚Ñï) (p-prime : Prime (‚ÇÇ‚Çä p-2)) where

  open import Zp.ModularArithmetic
  open PrimeModulus p-2 p-prime hiding (p)
  open Sym‚Ñï p-2 p-prime renaming (M to Mz)

  open PB _===_
  
  -- Commutativity.
  comm~ : (x y : Gen) -> Maybe (([ x ‚Üë] ‚Ä¢ [ y ‚Üë]) ‚âà ([ y ‚Üë] ‚Ä¢ [ x ‚Üë]))
  comm~ _ _ = nothing


  -- We number the generators for the purpose of ordering them.
  ord : Gen -> ‚Ñï
  ord (S-gen k) = 0 Nat.+ to‚Ñï k
  ord (H-gen k) = p Nat.+ to‚Ñï k

  -- Ordering of generators.
  les : Gen -> Gen -> Bool
  les x y with ord x Nat.<? ord y
  les x y | yes _ = true
  les x y | no _ = false

open import Presentation.Tactics hiding ([_])
module Commuting-Symplectic (p-2 : ‚Ñï) (p-prime : Prime (‚ÇÇ‚Çä p-2)) where
 open Commuting (Sym‚Ñï._===_ p-2 p-prime) (CommData.comm~ p-2 p-prime) (CommData.les p-2 p-prime) public

-- ----------------------------------------------------------------------
-- * Lemmas

module Symplectic-Powers (p-2 : ‚Ñï) (p-prime : Prime (‚ÇÇ‚Çä p-2)) where

  open import Zp.ModularArithmetic
  open PrimeModulus p-2 p-prime hiding (p)
  open Sym‚Ñï p-2 p-prime renaming (M to Mz)

  -- This module provides a rewrite system for reducing powers of
  -- Symplectic operators (for example, S‚Å¥ ‚Üí I). It also commutes
  -- generators on different qubits (for example, H1 H0 ‚Üí H0 H1).
  -- Finally, it moves scalars to the end of the word. While this is
  -- not yet a very powerful rewrite system, it is a useful
  -- bootstrapping step.

  open Rewriting
  
  open PB _===_ hiding (_===_)

  -- ----------------------------------------------------------------------
  -- * Lemmas

  -- The following lemmas are needed to justify the rewrite steps.

  -- ----------------------------------------------------------------------
  -- * Rewrite rules for monoidal structure and order of generators

  step-order : Step-Function Gen _===_

  -- Order of generators.
  step-order (H-gen ‚ÇÅ ‚à∑ H-gen ‚ÇÅ ‚à∑ H-gen ‚ÇÅ ‚à∑ H-gen ‚ÇÅ ‚à∑ xs) = just (xs , at-head (axiom order-H))
  step-order (S-gen ‚ÇÅ ‚à∑ H-gen ‚ÇÅ ‚à∑ S-gen ‚ÇÅ ‚à∑ H-gen ‚ÇÅ ‚à∑ S-gen ‚ÇÅ ‚à∑ H-gen ‚ÇÅ ‚à∑ xs) = just (xs , at-head (axiom order-SH))

  -- Commuting of generators.

  -- Catch-all
  step-order _ = nothing

  -- From this rewrite relation, we extract a tactic 'general-powers'.
  open Rewriting.Step (step-cong step-order) renaming (general-rewrite to general-powers) public


module Symplectic-Rewriting-HH (p-2 : ‚Ñï) (p-prime : Prime (‚ÇÇ‚Çä p-2)) where

  open import Zp.ModularArithmetic
  open PrimeModulus p-2 p-prime hiding (p)
  open Sym‚Ñï p-2 p-prime renaming (M to Mz)

  open Rewriting
  open Symplectic-Powers

  open PB _===_ hiding (_===_)
  open PP _===_
  open SR word-setoid


  -- ----------------------------------------------------------------------
  -- * Rewrite rules for 1-qubit Symplectic relations
  
  step-symplectic1 : Step-Function Gen _===_

  -- Rules for unary gates.
  -- Order of generators.
  
  step-symplectic1 (H-gen ‚ÇÅ ‚à∑ H-gen ‚ÇÅ ‚à∑ S-gen ‚ÇÅ ‚à∑ xs) = just (S-gen ‚ÇÅ ‚à∑ H-gen ‚ÇÅ ‚à∑ H-gen ‚ÇÅ ‚à∑ xs , at-head (axiom comm-HHS))

  -- Catch-all
  step-symplectic1 _ = nothing

  -- From this rewrite relation, we extract a tactic 'rewrite-symplectic1'.
  open Rewriting.Step (step-cong (step-order p-2 p-prime) then step-cong step-symplectic1) renaming (general-rewrite to rewrite-HH) public

module Lemmas (p-2 : ‚Ñï) (p-prime : Prime (‚ÇÇ‚Çä p-2)) where

  open import Zp.ModularArithmetic
  open PrimeModulus p-2 p-prime hiding (p)
  open Sym‚Ñï p-2 p-prime

  open Symplectic-Rewriting-HH p-2 p-prime
  open Symplectic-Powers p-2 p-prime

  open PB _===_ hiding (_===_)
  open PP _===_
  open SR word-setoid
  open Pattern-Assoc
  open import Data.Nat.DivMod
  open import Data.Fin.Properties

  lemma-S^k+l : ‚àÄ k l -> S^ k ‚Ä¢ S^ l ‚âà S^ (k + l)
  lemma-S^k+l k l = begin
    S^ k ‚Ä¢ S^ l ‚âà‚ü® cong (axiom (derived-S k)) (axiom (derived-S l)) ‚ü©
    S ^ to‚Ñï k ‚Ä¢ S ^ to‚Ñï l ‚âà‚ü® sym (lemma-^-+ S (to‚Ñï k) (to‚Ñï l)) ‚ü©
    S ^ (to‚Ñï k Nat.+ to‚Ñï l) ‚â°‚ü® Eq.cong (S ^_) (m‚â°m%n+[m/n]*n k+l p) ‚ü©
    S ^ (k+l Nat.% p Nat.+ (k+l Nat./ p) Nat.* p) ‚âà‚ü® lemma-^-+ S (k+l Nat.% p) (((k+l Nat./ p) Nat.* p)) ‚ü©
    S ^ (k+l Nat.% p) ‚Ä¢ S ^ ((k+l Nat./ p) Nat.* p) ‚âà‚ü® cong (refl' (Eq.cong (S ^_) (Eq.sym (to‚Ñï-from‚Ñï< (m%n<n k+l p))))) (refl' (Eq.cong (S ^_) (NP.*-comm ((k+l Nat./ p)) p))) ‚ü©
    S ^ to‚Ñï (from‚Ñï< (m%n<n k+l p)) ‚Ä¢ S ^ (p Nat.* (k+l Nat./ p) ) ‚âà‚ü® cong (sym (axiom (derived-S (k + l)))) (sym (lemma-^^ S p (k+l Nat./ p))) ‚ü©
    S^ (k + l) ‚Ä¢ (S ^ p) ^ (k+l Nat./ p) ‚âà‚ü® cright (lemma-^-cong (S ^ p) Œµ (k+l Nat./ p) (axiom order-S)) ‚ü©
    S^ (k + l) ‚Ä¢ Œµ ^ (k+l Nat./ p) ‚âà‚ü® cright lemma-Œµ^k=Œµ (k+l Nat./ p) ‚ü©
    S^ (k + l) ‚Ä¢ Œµ ‚âà‚ü® right-unit ‚ü©
    S^ (k + l) ‚àé
    where
    k+l = to‚Ñï k Nat.+ to‚Ñï l


  lemma-S^k-k : ‚àÄ k -> S^ k ‚Ä¢ S^ (- k) ‚âà Œµ
  lemma-S^k-k k = begin
    S^ k ‚Ä¢ S^ (- k) ‚âà‚ü® lemma-S^k+l k (- k) ‚ü©
    S^ (k + - k) ‚â°‚ü® Eq.cong S^ (+-inverse ≥ k) ‚ü©
    S^ ‚ÇÄ ‚âà‚ü® axiom (derived-S ‚ÇÄ) ‚ü©
    Œµ ‚àé
    where
    k-k = to‚Ñï k Nat.+ to‚Ñï (- k)

  lemma-S^-k+k : ‚àÄ k -> S^ (- k) ‚Ä¢ S^ k ‚âà Œµ
  lemma-S^-k+k k = begin
    S^ (- k) ‚Ä¢ S^ k ‚âà‚ü® cong (axiom (derived-S (- k))) (axiom (derived-S k)) ‚ü©
    S ^ to‚Ñï (- k) ‚Ä¢ S ^ to‚Ñï k ‚âà‚ü® word-comm (to‚Ñï (- k)) (to‚Ñï ( k)) refl ‚ü©
    S ^ to‚Ñï k ‚Ä¢ S ^ to‚Ñï (- k) ‚âà‚ü® cong (sym (axiom (derived-S k))) (sym (axiom (derived-S (- k)))) ‚ü©
    S^ k ‚Ä¢ S^ (- k) ‚âà‚ü® lemma-S^k-k k ‚ü©
    Œµ ‚àé

  open Eq using (_‚â¢_)

  ‚ÇÅ‚Åª¬π = ((‚ÇÅ , Œª ()) ‚Åª¬π) .proj‚ÇÅ

  M‚ÇÅ = M (‚ÇÅ , Œª ())
  
  lemma-M1 : Œµ ‚âà M (‚ÇÅ , Œª ())
  lemma-M1 = begin
    Œµ ‚âà‚ü® _‚âà_.sym (axiom order-SH) ‚ü©
    (S ‚Ä¢ H) ^ 3 ‚âà‚ü® by-assoc auto ‚ü©
    S ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚â°‚ü® auto ‚ü©
    S^ ‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ ‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ ‚ÇÅ ‚Ä¢ H ‚â°‚ü® Eq.cong (\ xx -> S^ ‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ xx ‚Ä¢ H ‚Ä¢ S^ ‚ÇÅ ‚Ä¢ H) (Eq.sym inv-‚ÇÅ) ‚ü©
    S^ ‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ ‚ÇÅ‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ ‚ÇÅ ‚Ä¢ H ‚âà‚ü® refl ‚ü©
    M (‚ÇÅ , Œª ()) ‚àé



  lemma-[H‚Åª¬πS‚Åª¬π]^3 : (H‚Åª¬π ‚Ä¢ S‚Åª¬π) ^ 3 ‚âà Œµ
  lemma-[H‚Åª¬πS‚Åª¬π]^3 = begin
    (H‚Åª¬π ‚Ä¢ S‚Åª¬π) ^ 3 ‚âà‚ü® _‚âà_.sym assoc ‚ü©
    (H‚Åª¬π ‚Ä¢ S‚Åª¬π) ^' 3 ‚âà‚ü® lemma-cong-inv (axiom order-SH) ‚ü©
    winv Œµ ‚âà‚ü® refl ‚ü©
    Œµ ‚àé
    where
    open Group-Lemmas _ _ grouplike renaming (_‚Åª¬π to winv)

  lemma-[S‚Åª¬πH‚Åª¬π]^3 : (S‚Åª¬π ‚Ä¢ H‚Åª¬π) ^ 3 ‚âà Œµ
  lemma-[S‚Åª¬πH‚Åª¬π]^3 = begin
    (S‚Åª¬π ‚Ä¢ H‚Åª¬π) ^ 3 ‚âà‚ü® sym (trans (cright lemma-left-inverse) right-unit) ‚ü©
    (S‚Åª¬π ‚Ä¢ H‚Åª¬π) ^ 3 ‚Ä¢ (S‚Åª¬π ‚Ä¢ S) ‚âà‚ü® special-assoc ((‚ñ° ‚Ä¢ ‚ñ°) ^ 3 ‚Ä¢ ‚ñ° ‚Ä¢ ‚ñ°) (‚ñ° ‚Ä¢ (‚ñ° ‚Ä¢ ‚ñ°) ^ 3 ‚Ä¢ ‚ñ°) auto ‚ü©
    S‚Åª¬π ‚Ä¢ (H‚Åª¬π ‚Ä¢ S‚Åª¬π) ^ 3 ‚Ä¢ S ‚âà‚ü® cright cleft lemma-[H‚Åª¬πS‚Åª¬π]^3 ‚ü©
    S‚Åª¬π ‚Ä¢ Œµ ‚Ä¢ S ‚âà‚ü® by-assoc auto ‚ü©
    S‚Åª¬π ‚Ä¢ S ‚âà‚ü® lemma-left-inverse ‚ü©
    Œµ ‚àé
    where
    open Group-Lemmas _ _ grouplike renaming (_‚Åª¬π to winv)

  lemma-S‚Åª¬π : S‚Åª¬π ‚âà S^ ‚Çö‚Çã‚ÇÅ
  lemma-S‚Åª¬π = begin
    S‚Åª¬π ‚âà‚ü® refl ‚ü©
    S ^ p-1 ‚â°‚ü® Eq.cong (S ^_) (Eq.sym lemma-to‚Ñï-‚Çö‚Çã‚ÇÅ) ‚ü©
    S ^ to‚Ñï ‚Çö‚Çã‚ÇÅ ‚âà‚ü® sym (axiom (derived-S ‚Çö‚Çã‚ÇÅ)) ‚ü©
    S^ ‚Çö‚Çã‚ÇÅ ‚àé

  lemma-HH-M-1 : let -'‚ÇÅ = -' ((‚ÇÅ , Œª ())) in HH ‚âà M -'‚ÇÅ
  lemma-HH-M-1 = begin
    HH ‚âà‚ü® trans (sym right-unit) (cright sym lemma-[S‚Åª¬πH‚Åª¬π]^3) ‚ü©
    HH ‚Ä¢ (S‚Åª¬π ‚Ä¢ H‚Åª¬π) ^ 3 ‚âà‚ü® (cright lemma-^-cong (S‚Åª¬π ‚Ä¢ H‚Åª¬π) (S‚Åª¬π ‚Ä¢ H ‚Ä¢ HH) 3 refl) ‚ü©
    HH ‚Ä¢ (S‚Åª¬π ‚Ä¢ H ‚Ä¢ HH) ^ 3 ‚âà‚ü® refl ‚ü©
    HH ‚Ä¢ (S‚Åª¬π ‚Ä¢ H ‚Ä¢ HH) ‚Ä¢ (S‚Åª¬π ‚Ä¢ H ‚Ä¢ HH) ‚Ä¢ (S‚Åª¬π ‚Ä¢ H ‚Ä¢ HH) ‚âà‚ü® (cright cong (cright sym assoc) (special-assoc (‚ñ° ^ 3 ‚Ä¢ ‚ñ° ^ 3) (‚ñ° ^ 2 ‚Ä¢ ‚ñ° ^ 2 ‚Ä¢ ‚ñ° ^ 2) auto)) ‚ü©
    HH ‚Ä¢ (S‚Åª¬π ‚Ä¢ HH ‚Ä¢ H) ‚Ä¢ (S‚Åª¬π ‚Ä¢ H) ‚Ä¢ (HH ‚Ä¢ S‚Åª¬π) ‚Ä¢ H ‚Ä¢ HH ‚âà‚ü® (cright cong (sym assoc) (cright cleft word-comm 1 p-1 (trans assoc (axiom comm-HHS)))) ‚ü©
    HH ‚Ä¢ ((S‚Åª¬π ‚Ä¢ HH) ‚Ä¢ H) ‚Ä¢ (S‚Åª¬π ‚Ä¢ H) ‚Ä¢ (S‚Åª¬π ‚Ä¢ HH) ‚Ä¢ H ‚Ä¢ HH ‚âà‚ü® (cright cong (cleft word-comm p-1 1 (sym (trans assoc (axiom comm-HHS)))) (cright assoc)) ‚ü©
    HH ‚Ä¢ ((HH ‚Ä¢ S‚Åª¬π) ‚Ä¢ H) ‚Ä¢ (S‚Åª¬π ‚Ä¢ H) ‚Ä¢ S‚Åª¬π ‚Ä¢ HH ‚Ä¢ H ‚Ä¢ HH ‚âà‚ü® (cright cright cright cright general-powers 100 auto) ‚ü©
    HH ‚Ä¢ ((HH ‚Ä¢ S‚Åª¬π) ‚Ä¢ H) ‚Ä¢ (S‚Åª¬π ‚Ä¢ H) ‚Ä¢ S‚Åª¬π ‚Ä¢ H ‚âà‚ü® special-assoc (‚ñ° ‚Ä¢ (‚ñ° ^ 2 ‚Ä¢ ‚ñ°) ‚Ä¢ ‚ñ°) (‚ñ° ^ 2 ‚Ä¢ ‚ñ° ^ 2 ‚Ä¢ ‚ñ°) auto ‚ü©
    (HH ‚Ä¢ HH) ‚Ä¢ (S‚Åª¬π ‚Ä¢ H) ‚Ä¢ (S‚Åª¬π ‚Ä¢ H) ‚Ä¢ S‚Åª¬π ‚Ä¢ H ‚âà‚ü® (cleft general-powers 100 auto) ‚ü©
    Œµ ‚Ä¢ (S‚Åª¬π ‚Ä¢ H) ‚Ä¢ (S‚Åª¬π ‚Ä¢ H) ‚Ä¢ S‚Åª¬π ‚Ä¢ H ‚âà‚ü® left-unit ‚ü©
    (S‚Åª¬π ‚Ä¢ H) ‚Ä¢ (S‚Åª¬π ‚Ä¢ H) ‚Ä¢ S‚Åª¬π ‚Ä¢ H ‚âà‚ü® special-assoc ((‚ñ° ^ 2) ^ 3) (‚ñ° ^ 6) auto ‚ü©
    S‚Åª¬π ‚Ä¢ H ‚Ä¢ S‚Åª¬π ‚Ä¢ H ‚Ä¢ S‚Åª¬π ‚Ä¢ H ‚âà‚ü® cong lemma-S‚Åª¬π (cright cong lemma-S‚Åª¬π (cright (cleft lemma-S‚Åª¬π))) ‚ü©
    S^ ‚Çö‚Çã‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ ‚Çö‚Çã‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ ‚Çö‚Çã‚ÇÅ ‚Ä¢ H ‚â°‚ü® Eq.cong (\ xx -> S^ ‚Çö‚Çã‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ ‚Çö‚Çã‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ xx ‚Ä¢ H) p-1=-1‚Çö ‚ü©
    S^ ‚Çö‚Çã‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ ‚Çö‚Çã‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ -‚ÇÅ ‚Ä¢ H ‚â°‚ü® Eq.cong‚ÇÇ (\ xx yy -> S^ xx ‚Ä¢ H ‚Ä¢ S^ yy ‚Ä¢ H ‚Ä¢ S^ -‚ÇÅ ‚Ä¢ H) (p-1=-1‚Çö) p-1=-1‚Çö ‚ü©
    S^ -‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ -‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ -‚ÇÅ ‚Ä¢ H ‚â°‚ü® Eq.cong (\ xx -> S^ -‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ xx ‚Ä¢ H ‚Ä¢ S^ -‚ÇÅ ‚Ä¢ H) (Eq.sym aux-‚ÇÅ‚Åª¬π) ‚ü©
    S^ -‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ -‚ÇÅ‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ -‚ÇÅ ‚Ä¢ H ‚âà‚ü® refl ‚ü©
    S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H ‚â°‚ü® Eq.refl ‚ü©
    M x' ‚àé
    where
    -'‚ÇÅ = -' ((‚ÇÅ , Œª ()))
    x' = -'‚ÇÅ
    -‚ÇÅ = -'‚ÇÅ .proj‚ÇÅ
    -‚ÇÅ‚Åª¬π = (-'‚ÇÅ ‚Åª¬π) .proj‚ÇÅ
    x = x' .proj‚ÇÅ
    x‚Åª¬π = (x' ‚Åª¬π) .proj‚ÇÅ

  derived-D : ‚àÄ x -> (nz : x ‚â¢ ‚ÇÄ) -> let x‚Åª¬π = ((x , nz) ‚Åª¬π) .proj‚ÇÅ in let -x‚Åª¬π = - x‚Åª¬π in
    H ‚Ä¢ S^ x ‚Ä¢ H ‚âà H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π
  derived-D  x nz = begin
    H ‚Ä¢ S^ x ‚Ä¢ H ‚âà‚ü® (cright cright sym right-unit) ‚ü©
    H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ Œµ ‚âà‚ü® cright cright cright sym (lemma-S^k-k x‚Åª¬π) ‚ü©
    H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® cright cright cright cright sym left-unit ‚ü©
    H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ Œµ ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® cright cright cright cright sym (cong (axiom order-H) refl) ‚ü©
    H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ^ 4 ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cright cright cright cright special-assoc (‚ñ° ^ 4 ‚Ä¢ ‚ñ°) (‚ñ° ‚Ä¢ ‚ñ° ^ 3 ‚Ä¢ ‚ñ°) auto) ‚ü©
    H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π ‚àé
    where
    x‚Åª¬π = ((x , nz) ‚Åª¬π) .proj‚ÇÅ
    -x‚Åª¬π = - x‚Åª¬π 

  derived-5 : ‚àÄ x k -> (nz : x ‚â¢ ‚ÇÄ) -> let x‚Åª¬π = ((x , nz) ‚Åª¬π) .proj‚ÇÅ in let -x‚Åª¬π = - x‚Åª¬π in
    M (x , nz) ‚Ä¢ S ^ k ‚âà S ^ (k Nat.* to‚Ñï (x * x)) ‚Ä¢ M (x , nz)
  derived-5 x k@0 nz = trans right-unit (sym left-unit)
  derived-5 x k@1 nz = begin  
    M (x , nz) ‚Ä¢ S ^ k ‚âà‚ü® refl ‚ü©
    M (x , nz) ‚Ä¢ S ‚âà‚ü® axiom (semi-MS (x , nz)) ‚ü©
    S^ (x * x) ‚Ä¢ M (x , nz) ‚âà‚ü® cong (axiom (derived-S (x * x))) refl ‚ü©
    S ^ to‚Ñï (x * x) ‚Ä¢ M (x , nz) ‚âà‚ü® (cleft refl' (Eq.cong (S ^_) (Eq.sym ( NP.*-identityÀ° (to‚Ñï (x * x)))))) ‚ü©
    S ^ (k Nat.* to‚Ñï (x * x)) ‚Ä¢ M (x , nz) ‚àé
  derived-5 x k@(‚ÇÇ‚Çä k') nz = begin  
    M (x , nz) ‚Ä¢ S ^ k ‚âà‚ü® refl ‚ü©
    M (x , nz) ‚Ä¢ S ‚Ä¢ S ^ ‚ÇÅ‚Çä k' ‚âà‚ü® sym assoc ‚ü©
    (M (x , nz) ‚Ä¢ S) ‚Ä¢ S ^ ‚ÇÅ‚Çä k' ‚âà‚ü® (cleft derived-5 x 1 nz) ‚ü©
    (S ^ (1 Nat.* to‚Ñï (x * x)) ‚Ä¢ M (x , nz)) ‚Ä¢ S ^ ‚ÇÅ‚Çä k' ‚âà‚ü® assoc ‚ü©
    S ^ (1 Nat.* to‚Ñï (x * x)) ‚Ä¢ M (x , nz) ‚Ä¢ S ^ ‚ÇÅ‚Çä k' ‚âà‚ü® (cright derived-5 x (‚ÇÅ‚Çä k') nz) ‚ü©
    S ^ (1 Nat.* to‚Ñï (x * x)) ‚Ä¢ S ^ (‚ÇÅ‚Çä k' Nat.* to‚Ñï (x * x)) ‚Ä¢ M (x , nz) ‚âà‚ü® sym assoc ‚ü©
    (S ^ (1 Nat.* to‚Ñï (x * x)) ‚Ä¢ S ^ (‚ÇÅ‚Çä k' Nat.* to‚Ñï (x * x))) ‚Ä¢ M (x , nz) ‚âà‚ü® (cleft sym (lemma-^-+ S ((1 Nat.* to‚Ñï (x * x))) ((‚ÇÅ‚Çä k' Nat.* to‚Ñï (x * x))))) ‚ü©
    (S ^ ((1 Nat.* to‚Ñï (x * x)) Nat.+ (‚ÇÅ‚Çä k' Nat.* to‚Ñï (x * x)))) ‚Ä¢ M (x , nz) ‚âà‚ü® (cleft refl' (Eq.cong (S ^_) (Eq.sym (NP.*-distrib ≥-+ (to‚Ñï (x * x)) ‚ÇÅ (‚ÇÅ‚Çä k'))))) ‚ü©
    S ^ ((1 Nat.+ ‚ÇÅ‚Çä k') Nat.* to‚Ñï (x * x) ) ‚Ä¢ M (x , nz) ‚âà‚ü® refl ‚ü©
    S ^ (k Nat.* to‚Ñï (x * x)) ‚Ä¢ M (x , nz) ‚àé

  lemma-S^ab : ‚àÄ (a b : ‚Ñ§ ‚Çö) -> S ^ to‚Ñï (a * b) ‚âà S ^ (to‚Ñï a Nat.* to‚Ñï b)
  lemma-S^ab a b = begin
    S ^ to‚Ñï (a * b) ‚â°‚ü® auto ‚ü©
    S ^ to‚Ñï (from‚Ñï< (m%n<n (to‚Ñï a Nat.* to‚Ñï b) p)) ‚â°‚ü® Eq.cong (S ^_) (to‚Ñï-from‚Ñï< (m%n<n (to‚Ñï a Nat.* to‚Ñï b) p)) ‚ü©
    S ^ ((to‚Ñï a Nat.* to‚Ñï b) % p) ‚âà‚ü® sym right-unit ‚ü©
    S ^ (ab Nat.% p) ‚Ä¢ Œµ ‚âà‚ü® (cright sym (lemma-Œµ^k=Œµ (ab Nat./ p))) ‚ü©
    S ^ (ab Nat.% p) ‚Ä¢ (Œµ) ^ (ab Nat./ p) ‚âà‚ü® (cright sym (lemma-^-cong (S ^ p) Œµ (ab Nat./ p) (axiom order-S))) ‚ü©
    S ^ (ab Nat.% p) ‚Ä¢ (S ^ p) ^ (ab Nat./ p) ‚âà‚ü® (cright lemma-^^ S p (ab Nat./ p)) ‚ü©
    S ^ (ab Nat.% p) ‚Ä¢ S ^ (p Nat.* (ab Nat./ p)) ‚âà‚ü® (cright refl' (Eq.cong (S ^_) (NP.*-comm p (ab Nat./ p)))) ‚ü©
    S ^ (ab Nat.% p) ‚Ä¢ S ^ (ab Nat./ p Nat.* p) ‚âà‚ü® sym (lemma-^-+ S (ab Nat.% p) (ab Nat./ p Nat.* p)) ‚ü©
    S ^ (ab Nat.% p Nat.+ ab Nat./ p Nat.* p) ‚â°‚ü® Eq.cong (S ^_) (Eq.sym (m‚â°m%n+[m/n]*n ab p)) ‚ü©
    S ^ (to‚Ñï a Nat.* to‚Ñï b) ‚àé
    where
    ab = to‚Ñï a Nat.* to‚Ñï b

  -'‚ÇÅ = -' ((‚ÇÅ , Œª ()))

  derived-7 : ‚àÄ x y -> (nz : x ‚â¢ ‚ÇÄ) -> (nzy : y ‚â¢ ‚ÇÄ) -> let -'‚ÇÅ = -' ((‚ÇÅ , Œª ())) in let x‚Åª¬π = ((x , nz) ‚Åª¬π) .proj‚ÇÅ in let -x‚Åª¬π = - x‚Åª¬π in let -y/x' = (((y , nzy) *' ((x , nz) ‚Åª¬π)) *' -'‚ÇÅ) in let -y/x = -y/x' .proj‚ÇÅ in
    M (y , nzy) ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H ‚âà S^ (-x‚Åª¬π * (y * y)) ‚Ä¢ M -y/x' ‚Ä¢ (H ‚Ä¢ S^ -x‚Åª¬π)
  derived-7 x y nzx nzy = begin
    M (y , nzy) ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H ‚âà‚ü® (cright derived-D x nzx) ‚ü©
    M (y , nzy) ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cright special-assoc (‚ñ° ‚Ä¢ ‚ñ° ‚Ä¢ ‚ñ° ‚Ä¢ ‚ñ° ‚Ä¢ ‚ñ° ‚Ä¢ ‚ñ° ‚Ä¢ ‚ñ°) (‚ñ° ^ 5 ‚Ä¢ ‚ñ° ‚Ä¢ ‚ñ°) auto) ‚ü©
    M (y , nzy) ‚Ä¢ (H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H) ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cright cleft sym left-unit) ‚ü©
    M (y , nzy) ‚Ä¢ (Œµ ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H) ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cright cleft cleft sym (lemma-S^-k+k x‚Åª¬π)) ‚ü©
    M (y , nzy) ‚Ä¢ ((S^ -x‚Åª¬π ‚Ä¢ S^ x‚Åª¬π) ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H) ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® special-assoc (‚ñ° ‚Ä¢ (‚ñ° ^ 2 ‚Ä¢ ‚ñ° ^ 5) ‚Ä¢ ‚ñ°) (‚ñ° ^ 2 ‚Ä¢ ‚ñ° ^ 6 ‚Ä¢ ‚ñ°) auto ‚ü©
    (M (y , nzy) ‚Ä¢ S^ -x‚Åª¬π) ‚Ä¢ (S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H) ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cleft (cright axiom (derived-S -x‚Åª¬π))) ‚ü©
    (M (y , nzy) ‚Ä¢ S ^ to‚Ñï -x‚Åª¬π) ‚Ä¢ (S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H) ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cleft derived-5 y (to‚Ñï -x‚Åª¬π) nzy) ‚ü©
    (S ^ (to‚Ñï -x‚Åª¬π Nat.* to‚Ñï (y * y)) ‚Ä¢ M (y , nzy)) ‚Ä¢ (S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H) ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® special-assoc (‚ñ° ^ 2 ‚Ä¢ ‚ñ° ^ 2) (‚ñ° ‚Ä¢ ‚ñ° ^ 2 ‚Ä¢ ‚ñ°) auto ‚ü©
    S ^ (to‚Ñï -x‚Åª¬π Nat.* to‚Ñï (y * y)) ‚Ä¢ (M (y , nzy) ‚Ä¢ (S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H)) ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cright cleft (cright (cright cright cleft refl' (Eq.cong S^ (Eq.sym (inv-involutive ((x , nz)))))))) ‚ü©
    S ^ (to‚Ñï -x‚Åª¬π Nat.* to‚Ñï (y * y)) ‚Ä¢ (M (y , nzy) ‚Ä¢ M ((x , nz) ‚Åª¬π)) ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cright cleft axiom (M-mul (y , nzy) ((x , nz) ‚Åª¬π))) ‚ü©
    S ^ (to‚Ñï -x‚Åª¬π Nat.* to‚Ñï (y * y)) ‚Ä¢ M ((y , nzy) *' ((x , nz) ‚Åª¬π)) ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cright special-assoc (‚ñ° ‚Ä¢ ‚ñ° ^ 3 ‚Ä¢ ‚ñ°) (‚ñ° ^ 3 ‚Ä¢ ‚ñ° ^ 2) auto) ‚ü©
    S ^ (to‚Ñï -x‚Åª¬π Nat.* to‚Ñï (y * y)) ‚Ä¢ (M ((y , nzy) *' ((x , nz) ‚Åª¬π)) ‚Ä¢ HH) ‚Ä¢ H ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cright cleft (cright lemma-HH-M-1)) ‚ü©
    S ^ (to‚Ñï -x‚Åª¬π Nat.* to‚Ñï (y * y)) ‚Ä¢ (M ((y , nzy) *' ((x , nz) ‚Åª¬π)) ‚Ä¢ M -'‚ÇÅ) ‚Ä¢ H ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cright cleft axiom (M-mul (((y , nzy) *' ((x , nz) ‚Åª¬π))) -'‚ÇÅ)) ‚ü©
    S ^ (to‚Ñï -x‚Åª¬π Nat.* to‚Ñï (y * y)) ‚Ä¢ (M (((y , nzy) *' ((x , nz) ‚Åª¬π)) *' -'‚ÇÅ) ) ‚Ä¢ H ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cleft sym (lemma-S^ab -x‚Åª¬π (y * y))) ‚ü©
    S ^ to‚Ñï (-x‚Åª¬π * (y * y)) ‚Ä¢ M -y/x' ‚Ä¢ (H ‚Ä¢ S^ -x‚Åª¬π) ‚âà‚ü® cong (sym (axiom (derived-S (-x‚Åª¬π * (y * y))))) refl ‚ü©
    S^ (-x‚Åª¬π * (y * y)) ‚Ä¢ M -y/x' ‚Ä¢ (H ‚Ä¢ S^ -x‚Åª¬π) ‚àé
    where
    nz = nzx
    x‚Åª¬π = ((x , nz) ‚Åª¬π) .proj‚ÇÅ
    x‚Åª¬π‚Åª¬π = (((x , nz) ‚Åª¬π) ‚Åª¬π) .proj‚ÇÅ
    -x‚Åª¬π = - x‚Åª¬π
    -y/x' = (((y , nzy) *' ((x , nz) ‚Åª¬π)) *' -'‚ÇÅ)
    -y/x = -y/x' .proj‚ÇÅ



module NF1 (p-2 : ‚Ñï) (p-prime : Prime (‚ÇÇ‚Çä p-2)) where

  open import Zp.ModularArithmetic
  open PrimeModulus p-2 p-prime hiding (p)
  open Sym‚Ñï p-2 p-prime hiding (p) renaming (M to Mz)
  
  data C1 : Set where
    Œµ : C1
    HS : ‚Ñ§ ‚Çö -> C1

  data ZMultiplier : Set where
    M : (x : ‚Ñ§* ‚Çö) -> ZMultiplier

  data S·µè : Set where
    ùïä : ‚Ñ§ ‚Çö -> S·µè

  NF1' = ‚Ñ§ ‚Çö √ó ‚Ñ§* ‚Çö √ó (‚ä§ ‚äé ‚Ñ§ ‚Çö)
  
  data NF1 : Set where
    _‚àô_‚àô_ : S·µè -> ZMultiplier -> C1 -> NF1

  ‚ü¶_‚üß‚ÇÅ : C1 -> Word Gen
  ‚ü¶ Œµ ‚üß‚ÇÅ = Œµ
  ‚ü¶ HS x ‚üß‚ÇÅ = H ‚Ä¢ S^ x

  ‚ü¶_‚üß'‚ÇÅ : ‚ä§ ‚äé ‚Ñ§ ‚Çö -> Word Gen
  ‚ü¶ inj‚ÇÅ tt ‚üß'‚ÇÅ = Œµ
  ‚ü¶ inj‚ÇÇ x ‚üß'‚ÇÅ = H ‚Ä¢ S^ x

  ‚ü¶_‚üß‚Çõ : S·µè -> Word Gen
  ‚ü¶ ùïä x ‚üß‚Çõ = S^ x

  ‚ü¶_‚üß'‚Çõ : S·µè -> Word Gen
  ‚ü¶ ùïä x ‚üß'‚Çõ = S^ x

  ‚ü¶_‚üß‚Çò : ZMultiplier -> Word Gen
  ‚ü¶ M x' ‚üß‚Çò = Mz x'
    where
    x = to‚Ñï (x' .proj‚ÇÅ)
    x‚Åª¬π = to‚Ñï ((x' ‚Åª¬π) .proj‚ÇÅ )

  ‚ü¶_‚üß : NF1 -> Word Gen
  ‚ü¶ s ‚àô m ‚àô c ‚üß = ‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò ‚Ä¢ ‚ü¶ c ‚üß‚ÇÅ

  ‚ü¶_‚üß' : NF1' -> Word Gen
  ‚ü¶ s , m , c ‚üß' = S^ s ‚Ä¢ Mz m ‚Ä¢ ‚ü¶ c ‚üß'‚ÇÅ

  Pauli1 = ‚Ñ§ ‚Çö √ó ‚Ñ§ ‚Çö
  
  -- mod p equality
  p : ‚Ñï
  p = (‚ÇÇ‚Çä p-2)
  ùï° = p
  norm1 : Pauli1 ‚Üí Pauli1 ‚Üí ‚Ñ§ ‚Çö
  norm1 (a , b) (c , d) = (- a) * d + c * b

  open import Algebra.Properties.Ring (+-*-ring p-2)
  
  norm1-antisym : ‚àÄ (p q : Pauli1) -> norm1 p q ‚â° - norm1 q p
  norm1-antisym p@(a , b) q@(c , d) = begin
    norm1 (a , b) (c , d) ‚â°‚ü® auto ‚ü©
    (- a) * d + c * b ‚â°‚ü® +-comm (- a * d) (c * b) ‚ü©
    (c * b) + - a * d ‚â°‚ü® Eq.cong (_+ - a * d) (Eq.cong (_* b) (Eq.sym (-‚Äøinvolutive c))) ‚ü©
    (- - c * b) + - a * d ‚â°‚ü® Eq.cong‚ÇÇ _+_ (Eq.sym (-‚ÄødistribÀ°-* (- c) b)) (Eq.sym (-‚ÄødistribÀ°-* a d)) ‚ü©
    - (- c * b) + - (a * d) ‚â°‚ü® (-‚Äø+-comm (- c * b) (a * d)) ‚ü©
    - ((- c) * b + a * d) ‚â°‚ü® auto ‚ü©
    - norm1 (c , d) (a , b) ‚àé
    where
    open import Data.Integer.Tactic.RingSolver
    open ‚â°-Reasoning


  act1 : Gen ‚Üí Pauli1 ‚Üí Pauli1
  act1 (H-gen ‚ÇÄ) (a , b) = (a , b)
  act1 (H-gen ‚ÇÅ) (a , b) = (- b , a)
  act1 (H-gen ‚ÇÇ) (a , b) = (- a , - b)
  act1 (H-gen ‚ÇÉ) (a , b) = (b , - a)
  act1 (S-gen k) (a , b) = (a , b + a * k)

  act : Word Gen ‚Üí Pauli1 ‚Üí Pauli1
  act = word-act act1

  pI : Pauli1
  pI = (‚ÇÄ , ‚ÇÄ)

  pZ : Pauli1
  pZ = (‚ÇÄ , ‚ÇÅ)

  pX : Pauli1
  pX = (‚ÇÅ , ‚ÇÄ)


  open Eq
  0‚â¢1 : 0 ‚â¢ 1
  0‚â¢1 ()

  0‚â¢1+n : ‚àÄ n -> 0 ‚â¢ ‚ÇÅ‚Çä n
  0‚â¢1+n n ()

{-
  open import Data.Nat.DivMod using (m%n<n ; m*n%n‚â°0 ; m<n‚áím%n‚â°m)
  open import Data.Fin.Properties hiding (0‚â¢1+n )
  open import Data.Empty
  open import Relation.Nullary.Negation.Core 
  open import Data.Integer.DivMod
  open import Data.Integer.Properties
  open import Data.Integer.Divisibility.Signed
  open import Data.Integer.Tactic.RingSolver

  +x*+x‚Åª¬π=+1 : ‚àÄ x' ->
    let +x = + to‚Ñï (x' .proj‚ÇÅ) in
    let +x‚Åª¬π = + to‚Ñï ((x' ‚Åª¬π) .proj‚ÇÅ ) in
    
    (+x * +x‚Åª¬π) % ùï° ‚â° ‚ÇÅ
  +x*+x‚Åª¬π=+1 x' = begin
    (+x * +x‚Åª¬π) % ùï° ‚â°‚ü® auto ‚ü©
    (+ x * + x‚Åª¬π) % ùï° ‚â°‚ü® cong (_% ùï°) (sym (pos-* x x‚Åª¬π)) ‚ü©
    (+ (x Nat.* x‚Åª¬π)) % ùï° ‚â°‚ü® lemma-‚Åª¬π ≥' ( x' .proj‚ÇÅ) {{nzto‚Ñï {y = x' .proj‚ÇÅ} {neq0 = x' .proj‚ÇÇ}}} ‚ü©
    ‚ÇÅ ‚àé
    where
    open ‚â°-Reasoning
    x = to‚Ñï (x' .proj‚ÇÅ)
    x‚Åª¬π = to‚Ñï ((x' ‚Åª¬π) .proj‚ÇÅ )
    +x = + x
    +x‚Åª¬π = + x‚Åª¬π

  +x‚Åª¬π*+x=+1 : ‚àÄ x' ->
    let +x = + to‚Ñï (x' .proj‚ÇÅ) in
    let +x‚Åª¬π = + to‚Ñï ((x' ‚Åª¬π) .proj‚ÇÅ ) in
    
    (+x‚Åª¬π * +x) % ùï° ‚â° ‚ÇÅ
  +x‚Åª¬π*+x=+1 x' = begin
    (+x‚Åª¬π * +x) % ùï° ‚â°‚ü® auto ‚ü©
    (+ x‚Åª¬π * + x) % ùï° ‚â°‚ü® cong (_% ùï°) (sym (pos-* x‚Åª¬π x)) ‚ü©
    (+ (x‚Åª¬π Nat.* x)) % ùï° ‚â°‚ü® lemma-‚Åª¬πÀ°' ( x' .proj‚ÇÅ) {{nzto‚Ñï {y = x' .proj‚ÇÅ} {neq0 = x' .proj‚ÇÇ}}} ‚ü©
    ‚ÇÅ ‚àé
    where
    open ‚â°-Reasoning
    x = to‚Ñï (x' .proj‚ÇÅ)
    x‚Åª¬π = to‚Ñï ((x' ‚Åª¬π) .proj‚ÇÅ )
    +x = + x
    +x‚Åª¬π = + x‚Åª¬π

-}

  lemma-HS : ‚àÄ a b -> (neq0 : a ‚â¢ ‚ÇÄ) -> let a‚Åª¬π = (a , neq0) ‚Åª¬π in let -b/a = - b * a‚Åª¬π .proj‚ÇÅ in

    act (H ‚Ä¢ S^ -b/a) (a , b) ‚â° (‚ÇÄ , a)
    
  lemma-HS a b neq0 = begin
    act (H ‚Ä¢ S^ -b/a) (a , b) ‚â°‚ü® auto ‚ü©
    act (H) (a , b + a * -b/a) ‚â°‚ü® auto ‚ü©
    (- (b + a * -b/a) , a) ‚â°‚ü® cong (_, a) (cong -_ aux-ba) ‚ü©
    (- ‚ÇÄ , a) ‚â°‚ü® cong (_, a) -0#‚âà0# ‚ü©
    (‚ÇÄ , a) ‚àé
    where
    open ‚â°-Reasoning
    a‚Åª¬π = (a , neq0) ‚Åª¬π
    -b/a = - b * a‚Åª¬π .proj‚ÇÅ
    aux-ba : b + a * -b/a ‚â° ‚ÇÄ
    aux-ba = begin
      b + a * -b/a ‚â°‚ü® cong (b +_) (cong (a *_) (*-comm (- b) (a‚Åª¬π .proj‚ÇÅ))) ‚ü© -- cong (b +_) (sym (*-assoc a (- b) (a‚Åª¬π .proj‚ÇÅ))) ‚ü©
      b + a * (a‚Åª¬π .proj‚ÇÅ * - b) ‚â°‚ü® cong (b +_) (sym (*-assoc a (a‚Åª¬π .proj‚ÇÅ) (- b) )) ‚ü©
      b + a * a‚Åª¬π .proj‚ÇÅ * - b ‚â°‚ü® cong (b +_) (cong (_* - b) (lemma-‚Åª¬π ≥ a {{nzto‚Ñï {y = a} {neq0 = neq0}}})) ‚ü©
      b + 1‚Çö * - b ‚â°‚ü® cong (b +_) (*-identityÀ° (- b)) ‚ü©
      b + - b ‚â°‚ü®  +-inverse ≥ b ‚ü©
      ‚ÇÄ ‚àé


  lemma-HS-x : ‚àÄ k a b -> 

    act (H ‚Ä¢ S^ k) (a , b) ‚â° (- (b + a * k) , a)
    
  lemma-HS-x a b neq0 = auto

  lemma-Mz : ‚àÄ a b x' ->
    let x = (x' .proj‚ÇÅ) in
    let x‚Åª¬π = ((x' ‚Åª¬π) .proj‚ÇÅ) in
    
    act (Mz x') (a , b) ‚â° (a * x‚Åª¬π , b * x)
    
  lemma-Mz a b x' = begin
    act (Mz x') (a , b) ‚â°‚ü® auto ‚ü©
    act (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H) (a , b) ‚â°‚ü® auto ‚ü©
    act (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x) (- b , a) ‚â°‚ü® auto ‚ü©
    act (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H) (- b , a + (- b) * x) ‚â°‚ü® auto ‚ü©
    act (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π) ( - (a + (- b) * x) , - b) ‚â°‚ü® auto ‚ü©
    act (S^ x ‚Ä¢ H) ( - (a + (- b) * x) , - b + (- (a + (- b) * x)) * (x‚Åª¬π)) ‚â°‚ü® auto ‚ü©
    act (S^ x) ( - (- b + (- (a + (- b) * x)) * (x‚Åª¬π)) , - (a + (- b) * x) ) ‚â°‚ü® auto ‚ü©
    - (- b + - (a + - b * x) * x‚Åª¬π) , - (a + - b * x) + - (- b + - (a + - b * x) * x‚Åª¬π) * x ‚â°‚ü® Eq.sym (‚â°√ó‚â°‚áí‚â° (-‚Äø+-comm (- b) (- (a + - b * x) * x‚Åª¬π) , Eq.cong‚ÇÇ _+_ (-‚Äø+-comm a (- b * x)) (Eq.cong (_* x) (-‚Äø+-comm (- b) (- (a + - b * x) * x‚Åª¬π))))) ‚ü©
    - - b + - ((- (a + - b * x)) * x‚Åª¬π) , - a + - (- b * x) + (- - b + - (- (a + - b * x) * x‚Åª¬π)) * x ‚â°‚ü® ‚â°√ó‚â°‚áí‚â° (cong‚ÇÇ _+_ (-‚Äøinvolutive b) (-‚ÄødistribÀ°-* ((- (a + - b * x))) x‚Åª¬π) , cong‚ÇÇ _+_ (cong (- a +_) (-‚ÄødistribÀ°-* (- b) x)) (cong‚ÇÇ (\ xx yy -> (xx + yy) * x) (-‚Äøinvolutive b) (-‚ÄødistribÀ°-* (- (a + - b * x)) x‚Åª¬π))) ‚ü©
    b + - (- (a + - b * x)) * x‚Åª¬π , - a + - - b * x + (b + - - (a + - b * x) * x‚Åª¬π) * x ‚â°‚ü® ‚â°√ó‚â°‚áí‚â° (Eq.cong (\ xx -> b + xx * x‚Åª¬π) (-‚Äøinvolutive (a + - b * x)) ,  cong‚ÇÇ _+_ (cong (\ xx -> - a + xx * x) (-‚Äøinvolutive b)) (cong (\ xx -> (b + xx * x‚Åª¬π) * x) (-‚Äøinvolutive (a + - b * x)))) ‚ü©
    b + (a + - b * x) * x‚Åª¬π , - a + b * x + (b + (a + - b * x) * x‚Åª¬π) * x ‚â°‚ü® ‚â°√ó‚â°‚áí‚â° ((cong (b +_) (*-distrib ≥-+ x‚Åª¬π a (- b * x))) , cong (\ xx -> - a + b * x + xx) (*-distrib ≥-+ x b ((a + - b * x) * x‚Åª¬π))) ‚ü©
    b + (a * x‚Åª¬π + - b * x * x‚Åª¬π) , - a + b * x + (b * x + (a + - b * x) * x‚Åª¬π * x) ‚â°‚ü® ‚â°√ó‚â°‚áí‚â° ((cong (\ xx -> b + (a * x‚Åª¬π + xx)) (*-assoc (- b) x x‚Åª¬π)) , (cong (\ xx -> - a + b * x + (b * x + xx)) (*-assoc ((a + - b * x)) x‚Åª¬π x))) ‚ü©
    b + (a * x‚Åª¬π + - b * (x * x‚Åª¬π)) , - a + b * x + (b * x + (a + - b * x) * (x‚Åª¬π * x)) ‚â°‚ü® ‚â°√ó‚â°‚áí‚â° ((cong (\ xx -> b + (a * x‚Åª¬π + - b * xx)) (lemma-‚Åª¬π ≥ x {{nzto‚Ñï {y = x} {neq0 = x' .proj‚ÇÇ}}}) , (cong (\ xx -> - a + b * x + (b * x + (a + - b * x) * xx)) (lemma-‚Åª¬πÀ° x {{nzto‚Ñï {y = x} {neq0 = x' .proj‚ÇÇ}}})))) ‚ü©
    b + (a * x‚Åª¬π + - b * ‚ÇÅ) , - a + b * x + (b * x + (a + - b * x) * ‚ÇÅ) ‚â°‚ü® ‚â°√ó‚â°‚áí‚â° ((cong (\ xx -> b + (a * x‚Åª¬π + xx)) (*-identity ≥ (- b)) , (cong (\ xx -> - a + b * x + (b * x + xx)) (*-identity ≥ (a + - b * x))))) ‚ü©
    b + (a * x‚Åª¬π + - b) , - a + b * x + (b * x + (a + - b * x)) ‚â°‚ü® ‚â°√ó‚â°‚áí‚â° ((cong (b +_) (+-comm (a * x‚Åª¬π) (- b))) , (cong (\ xx -> - a + b * x + xx) (+-comm (b * x) ((a + - b * x))))) ‚ü©
    b + (- b + a * x‚Åª¬π) , - a + b * x + ((a + - b * x) + b * x) ‚â°‚ü® sym (‚â°√ó‚â°‚áí‚â° ((+-assoc b (- b) (a * x‚Åª¬π)) , (+-assoc (- a + b * x) ((a + - b * x)) (b * x)))) ‚ü©
    b + - b + a * x‚Åª¬π , - a + b * x + (a + - b * x) + b * x ‚â°‚ü® ‚â°√ó‚â°‚áí‚â° ((cong (_+ a * x‚Åª¬π) (+-inverse ≥ b)) , (cong (_+ b * x) (+-assoc (- a) (b * x) ((a + - b * x))))) ‚ü©
    ‚ÇÄ + a * x‚Åª¬π , - a + (b * x + (a + - b * x)) + b * x ‚â°‚ü® ‚â°√ó‚â°‚áí‚â° ((+-identityÀ° (a * x‚Åª¬π)) , cong (\ xx -> - a + (b * x + xx) + b * x) (+-comm a (- b * x))) ‚ü©
    a * x‚Åª¬π , - a + (b * x + (- b * x + a)) + b * x ‚â°‚ü® cong (\ xx -> a * x‚Åª¬π , - a + xx + b * x) (sym (+-assoc (b * x) (- b * x) a)) ‚ü©
    a * x‚Åª¬π , - a + (b * x + - b * x + a) + b * x ‚â°‚ü® cong (\ xx -> a * x‚Åª¬π , - a + (b * x + xx + a) + b * x) (sym (-‚ÄødistribÀ°-* b x)) ‚ü©
    a * x‚Åª¬π , - a + (b * x + - (b * x) + a) + b * x ‚â°‚ü® cong (\ xx -> a * x‚Åª¬π , - a + (xx + a) + b * x) (+-inverse ≥ (b * x)) ‚ü©
    a * x‚Åª¬π , - a + (‚ÇÄ + a) + b * x ‚â°‚ü® cong (\ xx -> a * x‚Åª¬π , - a + xx + b * x) (+-identityÀ° a) ‚ü©
    a * x‚Åª¬π , - a + a + b * x ‚â°‚ü® cong (\ xx -> a * x‚Åª¬π , xx + b * x) (+-inverseÀ° a) ‚ü©
    a * x‚Åª¬π , ‚ÇÄ + b * x ‚â°‚ü® cong (\ xx -> a * x‚Åª¬π , xx) (+-identityÀ° (b * x)) ‚ü©
    a * x‚Åª¬π , b * x ‚àé
    where
    open ‚â°-Reasoning
    x = (x' .proj‚ÇÅ)
    x‚Åª¬π = ((x' ‚Åª¬π) .proj‚ÇÅ )


  norm-pI-q=0 : ‚àÄ (p : Pauli1) -> norm1 pI p ‚â° ‚ÇÄ
  norm-pI-q=0 (c , d) = begin
    norm1 pI (c , d) ‚â°‚ü® auto ‚ü©
    (- ‚ÇÄ) * d + c * ‚ÇÄ ‚â°‚ü® cong‚ÇÇ _+_ (cong (_* d) -0#‚âà0#) (*-comm c ‚ÇÄ) ‚ü©
    ‚ÇÄ * d + ‚ÇÄ * c ‚â°‚ü® auto ‚ü©
    ‚ÇÄ ‚àé
    where open ‚â°-Reasoning

  norm-0b : ‚àÄ b c d -> norm1 (‚ÇÄ , b) (c , d) ‚â° b * c
  norm-0b b c d = begin
    norm1 (‚ÇÄ , b) (c , d) ‚â°‚ü® auto ‚ü©
    (- ‚ÇÄ) * d + c * b ‚â°‚ü® cong (\ xx -> xx * d + c * b) -0#‚âà0# ‚ü©
    ‚ÇÄ * d + c * b ‚â°‚ü® auto ‚ü©
    ‚ÇÄ + c * b ‚â°‚ü® +-identityÀ° (c * b) ‚ü©
    c * b ‚â°‚ü® *-comm c b ‚ü©
    b * c ‚àé
    where open ‚â°-Reasoning

  aux3 : ‚àÄ (k c q : ‚Ñ§ ‚Çö) -> k * q * c ‚â° (k * c) * q
  aux3 k c q = begin
    (k * q) * c ‚â°‚ü® (*-assoc k q c) ‚ü©
    k * (q * c) ‚â°‚ü® cong (k *_) (*-comm q c) ‚ü©
    k * (c * q) ‚â°‚ü® sym (*-assoc k c q) ‚ü©
    (k * c) * q ‚àé
    where
    open ‚â°-Reasoning
    open Sol p-2 renaming (solve to sol)

  aux4 : ‚àÄ b k c p -> b ‚â° k * p -> b * c ‚â° (k * c) * p
  aux4 b k c p eq = begin
    b * c ‚â°‚ü® cong (_* c) eq ‚ü©
    k * p * c ‚â°‚ü® aux3 k c p ‚ü©
    (k * c) * p ‚àé
    where open ‚â°-Reasoning

{-
  aux6 : ‚àÄ k p-2 -> let p = (‚ÇÇ‚Çä p-2) in (k * p) % p ‚â° 0
  aux6 (+_ ‚ÇÄ) p-2 = auto
  aux6 +[1+ n ] p-2 = let p = + (‚ÇÇ‚Çä p-2) in m*n%n‚â°0 (‚ÇÅ‚Çä n)  ‚à£ p ‚à£
  aux6 k@(-[1+ n ]) p-2 with ((Nat.suc n) Nat.* (‚ÇÇ‚Çä p-2)) Nat.% (‚ÇÇ‚Çä p-2) | inspect ( Nat._% (‚ÇÇ‚Çä p-2)) ((Nat.suc n) Nat.* (‚ÇÇ‚Çä p-2))
  ... | ‚ÇÄ | [ eqh ]' = auto
  ... | ‚ÇÅ‚Çä hyp | [ eqh ]' with 0‚â¢1+n hyp (trans (Eq.sym (m*n%n‚â°0 ((Nat.suc n) ) ((‚ÇÇ‚Çä p-2)))) eqh)
  ... | ()
-}


  Theorem-NF1 :

    ‚àÄ (p q : Pauli1) ->
    norm1 p q ‚â° ‚ÇÅ ->
    -------------------------------
    ‚àÉ \ nf -> act ‚ü¶ nf ‚üß p ‚â° pZ √ó
              act ‚ü¶ nf ‚üß q ‚â° pX

  Theorem-NF1 p@((‚ÇÄ , ‚ÇÄ)) q@(q1) eq with 0‚Çö‚â¢1‚Çö (Eq.trans (Eq.sym (norm-pI-q=0 q)) (eq))
  ... | ()


  Theorem-NF1 p@(‚ÇÄ , b@(‚ÇÅ‚Çä b')) q@(c , d) eq = nf , claim1 , claim2
    where
    open ‚â°-Reasoning
    -b = - b

    -bnz : - b ‚â¢ 0‚Çö
    -bnz = (-' (b , Œª ())) .proj‚ÇÇ

    b‚Åª¬π = (b , Œª ()) ‚Åª¬π
    -b‚Åª¬π = -' b‚Åª¬π

    x‚Åª¬π = _‚Åª¬π b‚Åª¬π .proj‚ÇÅ
    x = b‚Åª¬π .proj‚ÇÅ

    -dx = - (d * x)

    nf = ùïä -dx ‚àô M b‚Åª¬π ‚àô Œµ
    claim1 : act ‚ü¶ nf ‚üß p ‚â° pZ
    claim1 = begin
      act ‚ü¶ nf ‚üß p ‚â°‚ü® auto ‚ü©
      act (S^ -dx ‚Ä¢ (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H) ‚Ä¢ Œµ) p ‚â°‚ü® auto ‚ü©
      act (S^ -dx ‚Ä¢ (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H)) p ‚â°‚ü® auto ‚ü©
      act (S^ -dx ‚Ä¢ (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H)) p ‚â°‚ü® auto ‚ü©
      act (S^ -dx) (act (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H) p) ‚â°‚ü® cong (act (S^ -dx)) (lemma-Mz (p .proj‚ÇÅ) (p .proj‚ÇÇ) b‚Åª¬π) ‚ü©
      act (S^ -dx) (‚ÇÄ * x‚Åª¬π , b * x ) ‚â°‚ü® cong (\ xx -> act (S^ -dx) (‚ÇÄ , xx )) (*-comm b x) ‚ü©
      act (S^ -dx) (‚ÇÄ , x * b ) ‚â°‚ü® cong (\ xx -> act (S^ -dx) (‚ÇÄ , xx)) (lemma-‚Åª¬πÀ° b {{nzto‚Ñï {y = b} {neq0 = Œª ()}}}) ‚ü©
      pZ ‚àé

    cb=1 : c * b ‚â° 1‚Çö
    cb=1 = begin
      c * b ‚â°‚ü® *-comm c b ‚ü©
      b * c ‚â°‚ü® sym (norm-0b b c d) ‚ü©
      norm1 p q ‚â°‚ü® eq ‚ü©
      1‚Çö ‚àé
      
    claim2 : act ‚ü¶ nf ‚üß q ‚â° pX
    claim2 = begin
      act ‚ü¶ nf ‚üß q ‚â°‚ü® cong (act (S^ -dx)) (lemma-Mz c d b‚Åª¬π) ‚ü©
      act (S^ -dx) (c * x‚Åª¬π , d * x ) ‚â°‚ü® cong (\ xx -> act (S^ -dx) (c * xx , d * x )) (inv-involutive ((b , Œª ()))) ‚ü©
      act (S^ -dx) (c * b , d * x ) ‚â°‚ü® cong (\ xx -> act (S^ -dx) (xx , d * x )) cb=1 ‚ü©
      act (S^ -dx) (1‚Çö , d * x ) ‚â°‚ü® auto ‚ü©
      (1‚Çö , d * x + 1‚Çö * -dx) ‚â°‚ü® cong (\ xx -> 1‚Çö , d * x + xx) (*-identityÀ° -dx) ‚ü©
      (1‚Çö , d * x + -dx) ‚â°‚ü®  cong (\ xx -> 1‚Çö , xx) (+-inverse ≥ (d * x)) ‚ü©
      pX ‚àé

  Theorem-NF1 p@(a@(‚ÇÅ‚Çä _) , b) q@(c , d) eq = nf , (claim1 , claim2)
    where
    open ‚â°-Reasoning
    
    a‚Åª¬π = (a , Œª ()) ‚Åª¬π
    1/a = a‚Åª¬π .proj‚ÇÅ
    -b/a = - b * 1/a
    x = 1/a
    x‚Åª¬π = (a‚Åª¬π ‚Åª¬π) .proj‚ÇÅ
    -c/a = - c * 1/a

    nf = ùïä -c/a ‚àô M a‚Åª¬π ‚àô HS -b/a
    p' = act (H ‚Ä¢ S^ -b/a) p
    
    claim1 : act ‚ü¶ nf ‚üß p ‚â° pZ
    claim1 = begin
      act ‚ü¶ nf ‚üß p ‚â°‚ü® auto ‚ü©
      act (S^ -c/a ‚Ä¢ (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H) ‚Ä¢ (H ‚Ä¢ S^ -b/a)) p ‚â°‚ü® auto ‚ü©
      act (S^ -c/a ‚Ä¢ (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H)) p' ‚â°‚ü® auto ‚ü©
      act (S^ -c/a ‚Ä¢ (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H)) p' ‚â°‚ü® auto ‚ü©
      act (S^ -c/a) (act (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H) p') ‚â°‚ü® cong (\ xx -> act (S^ -c/a) (act (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H) xx)) (lemma-HS a b (Œª ())) ‚ü©
      act (S^ -c/a) (act (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H) (‚ÇÄ , a)) ‚â°‚ü® cong (act (S^ -c/a)) (lemma-Mz (‚ÇÄ) (a) a‚Åª¬π) ‚ü©
      act (S^ -c/a) (‚ÇÄ * x‚Åª¬π , a * x ) ‚â°‚ü® cong (\ xx -> act (S^ -c/a) (‚ÇÄ , xx )) (lemma-‚Åª¬π ≥ a {{nzto‚Ñï {y = a} {neq0 = Œª ()}}}) ‚ü©
      act (S^ -c/a) (‚ÇÄ , ‚ÇÅ ) ‚â°‚ü® auto ‚ü©
      act (S^ -c/a) (‚ÇÄ , ‚ÇÅ + ‚ÇÄ * -c/a ) ‚â°‚ü® auto ‚ü©
      pZ ‚àé

    q' = act (H ‚Ä¢ S^ -b/a) q

    aux-dca : - (d + c * -b/a) * a ‚â° ‚ÇÅ
    aux-dca = begin
      - (d + c * -b/a) * a ‚â°‚ü® cong (_* a) (sym (-‚Äø+-comm d (c * -b/a))) ‚ü©
      (- d + -(c * -b/a)) * a ‚â°‚ü® cong (\ xx -> (- d + xx) * a ) (-‚ÄødistribÀ°-* c -b/a) ‚ü©
      (- d + - c * -b/a) * a ‚â°‚ü® *-distrib ≥-+ a (- d) (- c * -b/a) ‚ü©
      - d * a + - c * -b/a * a ‚â°‚ü® auto ‚ü©
      - d * a + - c * (- b * 1/a) * a ‚â°‚ü® cong (\ xx -> - d * a + xx) (*-assoc (- c) (- b * 1/a) a) ‚ü©
      - d * a + - c * ((- b * 1/a) * a) ‚â°‚ü®  cong (\ xx -> - d * a + - c * xx) (*-assoc (- b) 1/a a) ‚ü©
      - d * a + - c * (- b * (1/a * a)) ‚â°‚ü® cong (\ xx -> - d * a + - c * (- b * xx)) (lemma-‚Åª¬πÀ° a {{nzto‚Ñï {y = a} {neq0 = Œª ()}}}) ‚ü©
      - d * a + - c * (- b * ‚ÇÅ) ‚â°‚ü® cong (\ xx -> - d * a + - c * (xx)) (*-identity ≥ (- b)) ‚ü©
      - d * a + - c * - b ‚â°‚ü® cong (\ xx -> - d * a + xx) (sym (-‚Äødistrib ≥-* (- c) b)) ‚ü©
      - d * a + - (- c * b) ‚â°‚ü® cong (\ xx -> - d * a + - xx) (sym (-‚ÄødistribÀ°-* (c) b)) ‚ü©
      - d * a + - - (c * b) ‚â°‚ü® cong‚ÇÇ _+_ (*-comm (- d) a) (-‚Äøinvolutive (c * b)) ‚ü©
      a * - d + (c * b) ‚â°‚ü® cong (_+ (c * b)) (trans (sym (-‚Äødistrib ≥-* a d)) ((-‚ÄødistribÀ°-* a d))) ‚ü©
      - a * d + (c * b) ‚â°‚ü® eq ‚ü©
      ‚ÇÅ ‚àé

    aux-dx : c * x + ‚ÇÅ * -c/a ‚â° ‚ÇÄ
    aux-dx = begin
      c * x + ‚ÇÅ * -c/a ‚â°‚ü® auto ‚ü©
      c * 1/a + ‚ÇÅ * -c/a ‚â°‚ü® cong (c * 1/a +_) (*-identityÀ° -c/a) ‚ü©
      c * 1/a + -c/a ‚â°‚ü® sym (*-distrib ≥-+ 1/a c (- c)) ‚ü©
      (c + - c) * 1/a ‚â°‚ü® cong (_* 1/a) (+-inverse ≥ c) ‚ü©
      ‚ÇÄ * 1/a ‚â°‚ü® auto ‚ü©
      ‚ÇÄ ‚àé

    claim2 : act ‚ü¶ nf ‚üß q ‚â° pX
    claim2 = begin
      act ‚ü¶ nf ‚üß q ‚â°‚ü® auto ‚ü©
      act (S^ -c/a ‚Ä¢ (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H)) (- (d + c * -b/a) , c) ‚â°‚ü® cong (act (S^ -c/a)) (lemma-Mz (- (d + c * -b/a)) c a‚Åª¬π) ‚ü©
      act (S^ -c/a) (- (d + c * -b/a) * x‚Åª¬π , c * x ) ‚â°‚ü® cong (\ xx -> act (S^ -c/a) (- (d + c * -b/a) * xx , c * x )) (inv-involutive (a , (Œª ()))) ‚ü©
      act (S^ -c/a) (- (d + c * -b/a) * a , c * x ) ‚â°‚ü® cong (\ xx -> act (S^ -c/a) (xx , c * x )) aux-dca ‚ü©
      act (S^ -c/a) (‚ÇÅ , c * x ) ‚â°‚ü® auto ‚ü©
      (‚ÇÅ , c * x + ‚ÇÅ * -c/a ) ‚â°‚ü® cong (‚ÇÅ ,_) aux-dx ‚ü©
      pX ‚àé


