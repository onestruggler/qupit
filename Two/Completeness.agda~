{-# OPTIONS --safe #-}
open import Level using (0‚Ñì)

open import Relation.Binary using (Rel)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Binary.Morphism.Definitions using (Homomorphic‚ÇÇ)
open import Relation.Binary.PropositionalEquality using (_‚â°_ ; inspect ; setoid ; module ‚â°-Reasoning) renaming ([_] to [_]')
import Relation.Binary.Reasoning.Setoid as SR
import Relation.Binary.PropositionalEquality as Eq
open import Relation.Nullary.Decidable using (yes ; no)


open import Function using (_‚àò_ ; id)
open import Function.Definitions using (Injective)

open import Data.Product using (_√ó_ ; _,_ ; proj‚ÇÅ ; proj‚ÇÇ ; map‚ÇÅ ; ‚àÉ)
open import Data.Product.Relation.Binary.Pointwise.NonDependent as PW using (‚â°√ó‚â°‚áí‚â° ; Pointwise ; ‚â°‚áí‚â°√ó‚â°)
open import Data.Nat hiding (_^_ ; _+_ ; _*_ ; _%_ ; _/_)
open import Agda.Builtin.Nat using ()
import Data.Nat as Nat
open import Data.Fin hiding (_+_ ; _-_)
open import Data.Bool
open import Data.List hiding ([_])

open import Data.Maybe
open import Data.Sum using (_‚äé_ ; inj‚ÇÅ ; inj‚ÇÇ ; [_,_])
open import Data.Unit using (‚ä§ ; tt)
open import Data.Empty using (‚ä• ; ‚ä•-elim)

open import Word.Base hiding (wfoldl ; _*)
open import Word.Properties
import Presentation.Base as PB
import Presentation.Properties as PP
open PP using (NFProperty ; NFProperty')
import Presentation.CosetNF as CA
import Presentation.Reidemeister-Schreier as RS
module RSF = RS.Star-Injective-Full.Reidemeister-Schreier-Full

open import Presentation.Construct.Base hiding (_*_)
import Presentation.Construct.Properties.SemiDirectProduct2 as SDP2
import Presentation.Construct.Properties.DirectProduct as DP
import Presentation.Groups.Cyclic as Cyclic


open import Data.Fin.Properties using (suc-injective ; to‚Ñï-inject‚ÇÅ ; to‚Ñï-from‚Ñï)
import Data.Nat.Properties as NP
open import Presentation.GroupLike

module One.SymplecticZp where

pattern auto = Eq.refl

module Symplectic where

  data Gen : Set where
    H-gen : Gen
    S-gen : Gen

  H : Word Gen
  H = [ H-gen ‚Üë]

  H‚Åª¬π : Word Gen
  H‚Åª¬π = H ^ 3

  HH : Word Gen
  HH = H ‚Ä¢ H

  S : Word Gen
  S = [ S-gen ‚Üë]

  S' : Word Gen
  S' = HH ‚Ä¢ S ‚Ä¢ HH

  SS : Word Gen
  SS = S ‚Ä¢ S

  X : Word Gen
  X = H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H

  Z : Word Gen
  Z = HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS

  infix 4 _===_
  data _===_ : WRel Gen where
    order-S : S ^ 3 === Œµ
    order-H : H ^ 4 === Œµ
    order-SH : (S ‚Ä¢ H) ^ 3 === Œµ
    
    comm-HHS : H ‚Ä¢ H ‚Ä¢ S === S ‚Ä¢ H ‚Ä¢ H



open import Data.Nat.Primality
open import Data.Nat.Coprimality hiding (sym)
open import Data.Nat.GCD
open B√©zout
open import Data.Empty
open import Algebra.Properties.Group

pattern ‚ÇÄ = zero
pattern ‚ÇÅ = suc ‚ÇÄ
pattern ‚ÇÇ = suc ‚ÇÅ
pattern ‚ÇÉ = suc ‚ÇÇ
pattern ‚ÇÑ = suc ‚ÇÉ

pattern ‚ÇÅ‚Çä n = suc n
pattern ‚ÇÇ‚Çä n = suc (suc n)
pattern ‚ÇÉ‚Çä n = suc (‚ÇÇ‚Çä n)
pattern ‚ÇÑ‚Çä n = suc (‚ÇÉ‚Çä n)

module Sym‚Ñï (p-2 : ‚Ñï) (p-prime : Prime (‚ÇÇ‚Çä p-2)) where

  p : ‚Ñï
  p = ‚ÇÇ‚Çä p-2
  open import Zp.ModularArithmetic
  open PrimeModulus p-2 p-prime hiding (p ; 0‚Çö ; 1‚Çö ; 0‚Çö‚â¢1‚Çö)

  data Gen : Set where
    H-gen : ‚Ñ§ ‚ÇÑ -> Gen
    S-gen : ‚Ñ§ ‚Çö -> Gen

  H^ : ‚Ñ§ ‚ÇÑ -> Word Gen
  H^ k = [ H-gen k ‚Üë]

  S^ : ‚Ñ§ ‚Çö -> Word Gen
  S^ k = [ S-gen k ‚Üë]

  H : Word Gen
  H = [ H-gen ‚ÇÅ ‚Üë]

  H‚Åª¬π : Word Gen
  H‚Åª¬π = H ^ 3

  HH : Word Gen
  HH = H ‚Ä¢ H

  S : Word Gen
  S = [ S-gen ‚ÇÅ ‚Üë]

  S‚Åª¬π : Word Gen
  S‚Åª¬π = S ^ p-1

  S' : Word Gen
  S' = HH ‚Ä¢ S ‚Ä¢ HH

  SS : Word Gen
  SS = S ‚Ä¢ S

  X : Word Gen
  X = H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H

  Z : Word Gen
  Z = HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS

  M : ‚Ñ§* ‚Çö -> Word Gen
  M x' = S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H
    where
    x = x' .proj‚ÇÅ
    x‚Åª¬π = ((x' ‚Åª¬π) .proj‚ÇÅ )
    
  open Eq using (_‚â¢_)
  
  infix 4 _===_
  data _===_ : WRel Gen where
  
    order-S : S ^ p === Œµ
    order-H : H ^ 4 === Œµ
    order-SH : (S ‚Ä¢ H) ^ 3 === Œµ    
    comm-HHS : H ‚Ä¢ H ‚Ä¢ S === S ‚Ä¢ H ‚Ä¢ H
    M-mul : ‚àÄ x y -> M x ‚Ä¢ M y === M (x *' y)
    semi-MS : ‚àÄ x (nz : x ‚â¢ ‚ÇÄ) -> M (x , nz) ‚Ä¢ S === S^ (x * x) ‚Ä¢ M (x , nz)

    derived-S : ‚àÄ k -> S^ k === S ^ to‚Ñï k
    derived-H : ‚àÄ k -> H^ k === H ^ to‚Ñï k


  open PP _===_
  open PB _===_ hiding (_===_)
  grouplike : Grouplike _===_
  grouplike (H-gen k) = (H ^ to‚Ñï k) ^ 3 , claim
    where
    open SR word-setoid
    claim : (H ^ to‚Ñï k) ^ 3 ‚Ä¢ H^ k ‚âà Œµ
    claim = begin
      (H ^ to‚Ñï k) ^ 3 ‚Ä¢ H^ k ‚âà‚ü® (cright axiom (derived-H k)) ‚ü©
      (H ^ to‚Ñï k) ^ 3 ‚Ä¢ H ^ to‚Ñï k ‚âà‚ü® sym (lemma-^-+ (H ^ to‚Ñï k) 3 1) ‚ü©
      (H ^ to‚Ñï k) ^ 4 ‚âà‚ü® lemma-^^' H (to‚Ñï k) 4 ‚ü©
      (H ^ 4) ^ to‚Ñï k ‚âà‚ü® lemma-^-cong (H ^ 4) Œµ (to‚Ñï k) (axiom order-H) ‚ü©
      (Œµ) ^ to‚Ñï k ‚âà‚ü® lemma-Œµ^k=Œµ (to‚Ñï k) ‚ü©
      Œµ ‚àé
  grouplike (S-gen k) = (S ^ to‚Ñï k) ^ p-1 ,  claim
    where
    open SR word-setoid
    claim : (S ^ to‚Ñï k) ^ p-1 ‚Ä¢ S^ k ‚âà Œµ
    claim = begin
      (S ^ to‚Ñï k) ^ p-1 ‚Ä¢ S^ k ‚âà‚ü® (cright axiom (derived-S k)) ‚ü©
      (S ^ to‚Ñï k) ^ p-1 ‚Ä¢ S ^ to‚Ñï k ‚âà‚ü® sym (lemma-^-+ (S ^ to‚Ñï k) p-1 1) ‚ü©
      (S ^ to‚Ñï k) ^ (p-1 Nat.+ 1) ‚âà‚ü® lemma-^^' S (to‚Ñï k) (p-1 Nat.+ 1) ‚ü©
      (S ^ (p-1 Nat.+ 1)) ^ to‚Ñï k ‚âà‚ü® lemma-^-cong (S ^ (p-1 Nat.+ 1)) (S ^ p) (to‚Ñï k) (refl' (Eq.cong (S ^_) (NP.+-comm p-1 1))) ‚ü©
      (S ^ p) ^ to‚Ñï k ‚âà‚ü® lemma-^-cong (S ^ p) Œµ (to‚Ñï k) (axiom order-S) ‚ü©
      (Œµ) ^ to‚Ñï k ‚âà‚ü® lemma-Œµ^k=Œµ (to‚Ñï k) ‚ü©
      Œµ ‚àé


-- ----------------------------------------------------------------------
-- * Data required for applying word tactics to Symplectic generators

module CommData (p-2 : ‚Ñï) (p-prime : Prime (‚ÇÇ‚Çä p-2)) where

  open import Zp.ModularArithmetic
  open PrimeModulus p-2 p-prime hiding (p)
  open Sym‚Ñï p-2 p-prime renaming (M to Mz)

  open PB _===_
  
  -- Commutativity.
  comm~ : (x y : Gen) -> Maybe (([ x ‚Üë] ‚Ä¢ [ y ‚Üë]) ‚âà ([ y ‚Üë] ‚Ä¢ [ x ‚Üë]))
  comm~ _ _ = nothing


  -- We number the generators for the purpose of ordering them.
  ord : Gen -> ‚Ñï
  ord (S-gen k) = 0 Nat.+ to‚Ñï k
  ord (H-gen k) = p Nat.+ to‚Ñï k

  -- Ordering of generators.
  les : Gen -> Gen -> Bool
  les x y with ord x Nat.<? ord y
  les x y | yes _ = true
  les x y | no _ = false

open import Presentation.Tactics hiding ([_])
module Commuting-Symplectic (p-2 : ‚Ñï) (p-prime : Prime (‚ÇÇ‚Çä p-2)) where
 open Commuting (Sym‚Ñï._===_ p-2 p-prime) (CommData.comm~ p-2 p-prime) (CommData.les p-2 p-prime) public

-- ----------------------------------------------------------------------
-- * Lemmas

module Symplectic-Powers (p-2 : ‚Ñï) (p-prime : Prime (‚ÇÇ‚Çä p-2)) where

  open import Zp.ModularArithmetic
  open PrimeModulus p-2 p-prime hiding (p)
  open Sym‚Ñï p-2 p-prime renaming (M to Mz)

  -- This module provides a rewrite system for reducing powers of
  -- Symplectic operators (for example, S‚Å¥ ‚Üí I). It also commutes
  -- generators on different qubits (for example, H1 H0 ‚Üí H0 H1).
  -- Finally, it moves scalars to the end of the word. While this is
  -- not yet a very powerful rewrite system, it is a useful
  -- bootstrapping step.

  open Rewriting
  
  open PB _===_ hiding (_===_)

  -- ----------------------------------------------------------------------
  -- * Lemmas

  -- The following lemmas are needed to justify the rewrite steps.

  -- ----------------------------------------------------------------------
  -- * Rewrite rules for monoidal structure and order of generators

  step-order : Step-Function Gen _===_

  -- Order of generators.
  step-order (H-gen ‚ÇÅ ‚à∑ H-gen ‚ÇÅ ‚à∑ H-gen ‚ÇÅ ‚à∑ H-gen ‚ÇÅ ‚à∑ xs) = just (xs , at-head (axiom order-H))
  step-order (S-gen ‚ÇÅ ‚à∑ H-gen ‚ÇÅ ‚à∑ S-gen ‚ÇÅ ‚à∑ H-gen ‚ÇÅ ‚à∑ S-gen ‚ÇÅ ‚à∑ H-gen ‚ÇÅ ‚à∑ xs) = just (xs , at-head (axiom order-SH))

  -- Commuting of generators.

  -- Catch-all
  step-order _ = nothing

  -- From this rewrite relation, we extract a tactic 'general-powers'.
  open Rewriting.Step (step-cong step-order) renaming (general-rewrite to general-powers) public


module Symplectic-Rewriting-HH (p-2 : ‚Ñï) (p-prime : Prime (‚ÇÇ‚Çä p-2)) where

  open import Zp.ModularArithmetic
  open PrimeModulus p-2 p-prime hiding (p)
  open Sym‚Ñï p-2 p-prime renaming (M to Mz)

  open Rewriting
  open Symplectic-Powers

  open PB _===_ hiding (_===_)
  open PP _===_
  open SR word-setoid


  -- ----------------------------------------------------------------------
  -- * Rewrite rules for 1-qubit Symplectic relations
  
  step-symplectic1 : Step-Function Gen _===_

  -- Rules for unary gates.
  -- Order of generators.
  
  step-symplectic1 (H-gen ‚ÇÅ ‚à∑ H-gen ‚ÇÅ ‚à∑ S-gen ‚ÇÅ ‚à∑ xs) = just (S-gen ‚ÇÅ ‚à∑ H-gen ‚ÇÅ ‚à∑ H-gen ‚ÇÅ ‚à∑ xs , at-head (axiom comm-HHS))

  -- Catch-all
  step-symplectic1 _ = nothing

  -- From this rewrite relation, we extract a tactic 'rewrite-symplectic1'.
  open Rewriting.Step (step-cong (step-order p-2 p-prime) then step-cong step-symplectic1) renaming (general-rewrite to rewrite-HH) public

module Lemmas (p-2 : ‚Ñï) (p-prime : Prime (‚ÇÇ‚Çä p-2)) where

  open import Zp.ModularArithmetic
  open PrimeModulus p-2 p-prime hiding (p)
  open Sym‚Ñï p-2 p-prime renaming (M to Mz)

  open Symplectic-Rewriting-HH p-2 p-prime
  open Symplectic-Powers p-2 p-prime

  open PB _===_ hiding (_===_)
  open PP _===_
  open SR word-setoid
  open Pattern-Assoc
  open import Data.Nat.DivMod
  open import Data.Fin.Properties

  lemma-S^k-k : ‚àÄ k -> S^ k ‚Ä¢ S^ (- k) ‚âà Œµ
  lemma-S^k-k k = begin
    S^ k ‚Ä¢ S^ (- k) ‚âà‚ü® cong (axiom (derived-S k)) (axiom (derived-S (- k))) ‚ü©
    S ^ to‚Ñï k ‚Ä¢ S ^ to‚Ñï (- k) ‚âà‚ü® sym (lemma-^-+ S (to‚Ñï k) (to‚Ñï (- k))) ‚ü©
    S ^ (to‚Ñï k Nat.+ to‚Ñï (- k)) ‚â°‚ü® Eq.cong (S ^_) (m‚â°m%n+[m/n]*n k-k p) ‚ü©
    S ^ (k-k Nat.% p Nat.+ (k-k Nat./ p) Nat.* p) ‚âà‚ü® lemma-^-+ S (k-k Nat.% p) (((k-k Nat./ p) Nat.* p)) ‚ü©
    S ^ (k-k Nat.% p) ‚Ä¢ S ^ ((k-k Nat./ p) Nat.* p) ‚âà‚ü® cong (refl' (Eq.cong (S ^_) (Eq.sym (to‚Ñï-from‚Ñï< (m%n<n k-k p))))) (refl' (Eq.cong (S ^_) (NP.*-comm ((k-k Nat./ p)) p))) ‚ü©
    S ^ to‚Ñï (from‚Ñï< (m%n<n k-k p)) ‚Ä¢ S ^ (p Nat.* (k-k Nat./ p) ) ‚âà‚ü® cong (sym (axiom (derived-S (k + - k)))) (sym (lemma-^^ S p (k-k Nat./ p))) ‚ü©
    S^ (k + - k) ‚Ä¢ (S ^ p) ^ (k-k Nat./ p) ‚âà‚ü® cong (refl' (Eq.cong S^ (+-inverse ≥ k))) (lemma-^-cong (S ^ p) Œµ (k-k Nat./ p) (axiom order-S)) ‚ü©
    S^ ‚ÇÄ ‚Ä¢ Œµ ^ (k-k Nat./ p) ‚âà‚ü® trans (cong (axiom (derived-S ‚ÇÄ)) refl) left-unit ‚ü©
    Œµ ^ (k-k Nat./ p) ‚âà‚ü® lemma-Œµ^k=Œµ (k-k Nat./ p) ‚ü©
    Œµ ‚àé
    where
    k-k = to‚Ñï k Nat.+ to‚Ñï (- k)

  lemma-S^-k+k : ‚àÄ k -> S^ (- k) ‚Ä¢ S^ k ‚âà Œµ
  lemma-S^-k+k k = begin
    S^ (- k) ‚Ä¢ S^ k ‚âà‚ü® cong (axiom (derived-S (- k))) (axiom (derived-S k)) ‚ü©
    S ^ to‚Ñï (- k) ‚Ä¢ S ^ to‚Ñï k ‚âà‚ü® word-comm (to‚Ñï (- k)) (to‚Ñï ( k)) refl ‚ü©
    S ^ to‚Ñï k ‚Ä¢ S ^ to‚Ñï (- k) ‚âà‚ü® cong (sym (axiom (derived-S k))) (sym (axiom (derived-S (- k)))) ‚ü©
    S^ k ‚Ä¢ S^ (- k) ‚âà‚ü® lemma-S^k-k k ‚ü©
    Œµ ‚àé

  open Eq using (_‚â¢_)

  ‚ÇÅ‚Åª¬π = ((‚ÇÅ , Œª ()) ‚Åª¬π) .proj‚ÇÅ

  lemma-M1 : Œµ ‚âà Mz (‚ÇÅ , Œª ())
  lemma-M1 = begin
    Œµ ‚âà‚ü® _‚âà_.sym (axiom order-SH) ‚ü©
    (S ‚Ä¢ H) ^ 3 ‚âà‚ü® by-assoc auto ‚ü©
    S ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚â°‚ü® auto ‚ü©
    S^ ‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ ‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ ‚ÇÅ ‚Ä¢ H ‚â°‚ü® Eq.cong (\ xx -> S^ ‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ xx ‚Ä¢ H ‚Ä¢ S^ ‚ÇÅ ‚Ä¢ H) (Eq.sym inv-‚ÇÅ) ‚ü©
    S^ ‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ ‚ÇÅ‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ ‚ÇÅ ‚Ä¢ H ‚âà‚ü® refl ‚ü©
    Mz (‚ÇÅ , Œª ()) ‚àé


  lemma-[H‚Åª¬πS‚Åª¬π]^3 : (H‚Åª¬π ‚Ä¢ S‚Åª¬π) ^ 3 ‚âà Œµ
  lemma-[H‚Åª¬πS‚Åª¬π]^3 = begin
    (H‚Åª¬π ‚Ä¢ S‚Åª¬π) ^ 3 ‚âà‚ü® _‚âà_.sym assoc ‚ü©
    (H‚Åª¬π ‚Ä¢ S‚Åª¬π) ^' 3 ‚âà‚ü® lemma-cong-inv (axiom order-SH) ‚ü©
    winv Œµ ‚âà‚ü® refl ‚ü©
    Œµ ‚àé
    where
    open Group-Lemmas _ _ grouplike renaming (_‚Åª¬π to winv)

  lemma-[S‚Åª¬πH‚Åª¬π]^3 : (S‚Åª¬π ‚Ä¢ H‚Åª¬π) ^ 3 ‚âà Œµ
  lemma-[S‚Åª¬πH‚Åª¬π]^3 = begin
    (S‚Åª¬π ‚Ä¢ H‚Åª¬π) ^ 3 ‚âà‚ü® sym (trans (cright lemma-left-inverse) right-unit) ‚ü©
    (S‚Åª¬π ‚Ä¢ H‚Åª¬π) ^ 3 ‚Ä¢ (S‚Åª¬π ‚Ä¢ S) ‚âà‚ü® special-assoc ((‚ñ° ‚Ä¢ ‚ñ°) ^ 3 ‚Ä¢ ‚ñ° ‚Ä¢ ‚ñ°) (‚ñ° ‚Ä¢ (‚ñ° ‚Ä¢ ‚ñ°) ^ 3 ‚Ä¢ ‚ñ°) auto ‚ü©
    S‚Åª¬π ‚Ä¢ (H‚Åª¬π ‚Ä¢ S‚Åª¬π) ^ 3 ‚Ä¢ S ‚âà‚ü® cright cleft lemma-[H‚Åª¬πS‚Åª¬π]^3 ‚ü©
    S‚Åª¬π ‚Ä¢ Œµ ‚Ä¢ S ‚âà‚ü® by-assoc auto ‚ü©
    S‚Åª¬π ‚Ä¢ S ‚âà‚ü® lemma-left-inverse ‚ü©
    Œµ ‚àé
    where
    open Group-Lemmas _ _ grouplike renaming (_‚Åª¬π to winv)

  lemma-S‚Åª¬π : S‚Åª¬π ‚âà S^ ‚Çö‚Çã‚ÇÅ
  lemma-S‚Åª¬π = begin
    S‚Åª¬π ‚âà‚ü® refl ‚ü©
    S ^ p-1 ‚â°‚ü® Eq.cong (S ^_) (Eq.sym lemma-to‚Ñï-‚Çö‚Çã‚ÇÅ) ‚ü©
    S ^ to‚Ñï ‚Çö‚Çã‚ÇÅ ‚âà‚ü® sym (axiom (derived-S ‚Çö‚Çã‚ÇÅ)) ‚ü©
    S^ ‚Çö‚Çã‚ÇÅ ‚àé

  lemma-HH-M-1 : let -'‚ÇÅ = -' ((‚ÇÅ , Œª ())) in HH ‚âà Mz -'‚ÇÅ
  lemma-HH-M-1 = begin
    HH ‚âà‚ü® trans (sym right-unit) (cright sym lemma-[S‚Åª¬πH‚Åª¬π]^3) ‚ü©
    HH ‚Ä¢ (S‚Åª¬π ‚Ä¢ H‚Åª¬π) ^ 3 ‚âà‚ü® (cright lemma-^-cong (S‚Åª¬π ‚Ä¢ H‚Åª¬π) (S‚Åª¬π ‚Ä¢ H ‚Ä¢ HH) 3 refl) ‚ü©
    HH ‚Ä¢ (S‚Åª¬π ‚Ä¢ H ‚Ä¢ HH) ^ 3 ‚âà‚ü® refl ‚ü©
    HH ‚Ä¢ (S‚Åª¬π ‚Ä¢ H ‚Ä¢ HH) ‚Ä¢ (S‚Åª¬π ‚Ä¢ H ‚Ä¢ HH) ‚Ä¢ (S‚Åª¬π ‚Ä¢ H ‚Ä¢ HH) ‚âà‚ü® (cright cong (cright sym assoc) (special-assoc (‚ñ° ^ 3 ‚Ä¢ ‚ñ° ^ 3) (‚ñ° ^ 2 ‚Ä¢ ‚ñ° ^ 2 ‚Ä¢ ‚ñ° ^ 2) auto)) ‚ü©
    HH ‚Ä¢ (S‚Åª¬π ‚Ä¢ HH ‚Ä¢ H) ‚Ä¢ (S‚Åª¬π ‚Ä¢ H) ‚Ä¢ (HH ‚Ä¢ S‚Åª¬π) ‚Ä¢ H ‚Ä¢ HH ‚âà‚ü® (cright cong (sym assoc) (cright cleft word-comm 1 p-1 (trans assoc (axiom comm-HHS)))) ‚ü©
    HH ‚Ä¢ ((S‚Åª¬π ‚Ä¢ HH) ‚Ä¢ H) ‚Ä¢ (S‚Åª¬π ‚Ä¢ H) ‚Ä¢ (S‚Åª¬π ‚Ä¢ HH) ‚Ä¢ H ‚Ä¢ HH ‚âà‚ü® (cright cong (cleft word-comm p-1 1 (sym (trans assoc (axiom comm-HHS)))) (cright assoc)) ‚ü©
    HH ‚Ä¢ ((HH ‚Ä¢ S‚Åª¬π) ‚Ä¢ H) ‚Ä¢ (S‚Åª¬π ‚Ä¢ H) ‚Ä¢ S‚Åª¬π ‚Ä¢ HH ‚Ä¢ H ‚Ä¢ HH ‚âà‚ü® (cright cright cright cright general-powers 100 auto) ‚ü©
    HH ‚Ä¢ ((HH ‚Ä¢ S‚Åª¬π) ‚Ä¢ H) ‚Ä¢ (S‚Åª¬π ‚Ä¢ H) ‚Ä¢ S‚Åª¬π ‚Ä¢ H ‚âà‚ü® special-assoc (‚ñ° ‚Ä¢ (‚ñ° ^ 2 ‚Ä¢ ‚ñ°) ‚Ä¢ ‚ñ°) (‚ñ° ^ 2 ‚Ä¢ ‚ñ° ^ 2 ‚Ä¢ ‚ñ°) auto ‚ü©
    (HH ‚Ä¢ HH) ‚Ä¢ (S‚Åª¬π ‚Ä¢ H) ‚Ä¢ (S‚Åª¬π ‚Ä¢ H) ‚Ä¢ S‚Åª¬π ‚Ä¢ H ‚âà‚ü® (cleft general-powers 100 auto) ‚ü©
    Œµ ‚Ä¢ (S‚Åª¬π ‚Ä¢ H) ‚Ä¢ (S‚Åª¬π ‚Ä¢ H) ‚Ä¢ S‚Åª¬π ‚Ä¢ H ‚âà‚ü® left-unit ‚ü©
    (S‚Åª¬π ‚Ä¢ H) ‚Ä¢ (S‚Åª¬π ‚Ä¢ H) ‚Ä¢ S‚Åª¬π ‚Ä¢ H ‚âà‚ü® special-assoc ((‚ñ° ^ 2) ^ 3) (‚ñ° ^ 6) auto ‚ü©
    S‚Åª¬π ‚Ä¢ H ‚Ä¢ S‚Åª¬π ‚Ä¢ H ‚Ä¢ S‚Åª¬π ‚Ä¢ H ‚âà‚ü® cong lemma-S‚Åª¬π (cright cong lemma-S‚Åª¬π (cright (cleft lemma-S‚Åª¬π))) ‚ü©
    S^ ‚Çö‚Çã‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ ‚Çö‚Çã‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ ‚Çö‚Çã‚ÇÅ ‚Ä¢ H ‚â°‚ü® Eq.cong (\ xx -> S^ ‚Çö‚Çã‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ ‚Çö‚Çã‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ xx ‚Ä¢ H) p-1=-1‚Çö ‚ü©
    S^ ‚Çö‚Çã‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ ‚Çö‚Çã‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ -‚ÇÅ ‚Ä¢ H ‚â°‚ü® Eq.cong‚ÇÇ (\ xx yy -> S^ xx ‚Ä¢ H ‚Ä¢ S^ yy ‚Ä¢ H ‚Ä¢ S^ -‚ÇÅ ‚Ä¢ H) (p-1=-1‚Çö) p-1=-1‚Çö ‚ü©
    S^ -‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ -‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ -‚ÇÅ ‚Ä¢ H ‚â°‚ü® Eq.cong (\ xx -> S^ -‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ xx ‚Ä¢ H ‚Ä¢ S^ -‚ÇÅ ‚Ä¢ H) (Eq.sym aux-‚ÇÅ‚Åª¬π) ‚ü©
    S^ -‚ÇÅ ‚Ä¢ H ‚Ä¢ S^ -‚ÇÅ‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ -‚ÇÅ ‚Ä¢ H ‚âà‚ü® refl ‚ü©
    S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H ‚â°‚ü® Eq.refl ‚ü©
    Mz x' ‚àé
    where
    -'‚ÇÅ = -' ((‚ÇÅ , Œª ()))
    x' = -'‚ÇÅ
    -‚ÇÅ = -'‚ÇÅ .proj‚ÇÅ
    -‚ÇÅ‚Åª¬π = (-'‚ÇÅ ‚Åª¬π) .proj‚ÇÅ
    x = x' .proj‚ÇÅ
    x‚Åª¬π = (x' ‚Åª¬π) .proj‚ÇÅ

  derived-D : ‚àÄ x -> (nz : x ‚â¢ ‚ÇÄ) -> let x‚Åª¬π = ((x , nz) ‚Åª¬π) .proj‚ÇÅ in let -x‚Åª¬π = - x‚Åª¬π in
    H ‚Ä¢ S^ x ‚Ä¢ H ‚âà H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π
  derived-D  x nz = begin
    H ‚Ä¢ S^ x ‚Ä¢ H ‚âà‚ü® (cright cright sym right-unit) ‚ü©
    H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ Œµ ‚âà‚ü® cright cright cright sym (lemma-S^k-k x‚Åª¬π) ‚ü©
    H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® cright cright cright cright sym left-unit ‚ü©
    H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ Œµ ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® cright cright cright cright sym (cong (axiom order-H) refl) ‚ü©
    H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ^ 4 ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cright cright cright cright special-assoc (‚ñ° ^ 4 ‚Ä¢ ‚ñ°) (‚ñ° ‚Ä¢ ‚ñ° ^ 3 ‚Ä¢ ‚ñ°) auto) ‚ü©
    H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π ‚àé
    where
    x‚Åª¬π = ((x , nz) ‚Åª¬π) .proj‚ÇÅ
    -x‚Åª¬π = - x‚Åª¬π 

  derived-5 : ‚àÄ x k -> (nz : x ‚â¢ ‚ÇÄ) -> let x‚Åª¬π = ((x , nz) ‚Åª¬π) .proj‚ÇÅ in let -x‚Åª¬π = - x‚Åª¬π in
    Mz (x , nz) ‚Ä¢ S ^ k ‚âà S ^ (k Nat.* to‚Ñï (x * x)) ‚Ä¢ Mz (x , nz)
  derived-5 x k@0 nz = trans right-unit (sym left-unit)
  derived-5 x k@1 nz = begin  
    Mz (x , nz) ‚Ä¢ S ^ k ‚âà‚ü® refl ‚ü©
    Mz (x , nz) ‚Ä¢ S ‚âà‚ü® axiom (semi-MS x nz) ‚ü©
    S^ (x * x) ‚Ä¢ Mz (x , nz) ‚âà‚ü® cong (axiom (derived-S (x * x))) refl ‚ü©
    S ^ to‚Ñï (x * x) ‚Ä¢ Mz (x , nz) ‚âà‚ü® (cleft refl' (Eq.cong (S ^_) (Eq.sym ( NP.*-identityÀ° (to‚Ñï (x * x)))))) ‚ü©
    S ^ (k Nat.* to‚Ñï (x * x)) ‚Ä¢ Mz (x , nz) ‚àé
  derived-5 x k@(‚ÇÇ‚Çä k') nz = begin  
    Mz (x , nz) ‚Ä¢ S ^ k ‚âà‚ü® refl ‚ü©
    Mz (x , nz) ‚Ä¢ S ‚Ä¢ S ^ ‚ÇÅ‚Çä k' ‚âà‚ü® sym assoc ‚ü©
    (Mz (x , nz) ‚Ä¢ S) ‚Ä¢ S ^ ‚ÇÅ‚Çä k' ‚âà‚ü® (cleft derived-5 x 1 nz) ‚ü©
    (S ^ (1 Nat.* to‚Ñï (x * x)) ‚Ä¢ Mz (x , nz)) ‚Ä¢ S ^ ‚ÇÅ‚Çä k' ‚âà‚ü® assoc ‚ü©
    S ^ (1 Nat.* to‚Ñï (x * x)) ‚Ä¢ Mz (x , nz) ‚Ä¢ S ^ ‚ÇÅ‚Çä k' ‚âà‚ü® (cright derived-5 x (‚ÇÅ‚Çä k') nz) ‚ü©
    S ^ (1 Nat.* to‚Ñï (x * x)) ‚Ä¢ S ^ (‚ÇÅ‚Çä k' Nat.* to‚Ñï (x * x)) ‚Ä¢ Mz (x , nz) ‚âà‚ü® sym assoc ‚ü©
    (S ^ (1 Nat.* to‚Ñï (x * x)) ‚Ä¢ S ^ (‚ÇÅ‚Çä k' Nat.* to‚Ñï (x * x))) ‚Ä¢ Mz (x , nz) ‚âà‚ü® (cleft sym (lemma-^-+ S ((1 Nat.* to‚Ñï (x * x))) ((‚ÇÅ‚Çä k' Nat.* to‚Ñï (x * x))))) ‚ü©
    (S ^ ((1 Nat.* to‚Ñï (x * x)) Nat.+ (‚ÇÅ‚Çä k' Nat.* to‚Ñï (x * x)))) ‚Ä¢ Mz (x , nz) ‚âà‚ü® (cleft refl' (Eq.cong (S ^_) (Eq.sym (NP.*-distrib ≥-+ (to‚Ñï (x * x)) ‚ÇÅ (‚ÇÅ‚Çä k'))))) ‚ü©
    S ^ ((1 Nat.+ ‚ÇÅ‚Çä k') Nat.* to‚Ñï (x * x) ) ‚Ä¢ Mz (x , nz) ‚âà‚ü® refl ‚ü©
    S ^ (k Nat.* to‚Ñï (x * x)) ‚Ä¢ Mz (x , nz) ‚àé

  lemma-S^ab : ‚àÄ (a b : ‚Ñ§ ‚Çö) -> S ^ to‚Ñï (a * b) ‚âà S ^ (to‚Ñï a Nat.* to‚Ñï b)
  lemma-S^ab a b = begin
    S ^ to‚Ñï (a * b) ‚â°‚ü® auto ‚ü©
    S ^ to‚Ñï (from‚Ñï< (m%n<n (to‚Ñï a Nat.* to‚Ñï b) p)) ‚â°‚ü® Eq.cong (S ^_) (to‚Ñï-from‚Ñï< (m%n<n (to‚Ñï a Nat.* to‚Ñï b) p)) ‚ü©
    S ^ ((to‚Ñï a Nat.* to‚Ñï b) % p) ‚âà‚ü® sym right-unit ‚ü©
    S ^ (ab Nat.% p) ‚Ä¢ Œµ ‚âà‚ü® (cright sym (lemma-Œµ^k=Œµ (ab Nat./ p))) ‚ü©
    S ^ (ab Nat.% p) ‚Ä¢ (Œµ) ^ (ab Nat./ p) ‚âà‚ü® (cright sym (lemma-^-cong (S ^ p) Œµ (ab Nat./ p) (axiom order-S))) ‚ü©
    S ^ (ab Nat.% p) ‚Ä¢ (S ^ p) ^ (ab Nat./ p) ‚âà‚ü® (cright lemma-^^ S p (ab Nat./ p)) ‚ü©
    S ^ (ab Nat.% p) ‚Ä¢ S ^ (p Nat.* (ab Nat./ p)) ‚âà‚ü® (cright refl' (Eq.cong (S ^_) (NP.*-comm p (ab Nat./ p)))) ‚ü©
    S ^ (ab Nat.% p) ‚Ä¢ S ^ (ab Nat./ p Nat.* p) ‚âà‚ü® sym (lemma-^-+ S (ab Nat.% p) (ab Nat./ p Nat.* p)) ‚ü©
    S ^ (ab Nat.% p Nat.+ ab Nat./ p Nat.* p) ‚â°‚ü® Eq.cong (S ^_) (Eq.sym (m‚â°m%n+[m/n]*n ab p)) ‚ü©
    S ^ (to‚Ñï a Nat.* to‚Ñï b) ‚àé
    where
    ab = to‚Ñï a Nat.* to‚Ñï b

  -'‚ÇÅ = -' ((‚ÇÅ , Œª ()))

  derived-7 : ‚àÄ x y -> (nz : x ‚â¢ ‚ÇÄ) -> (nzy : y ‚â¢ ‚ÇÄ) -> let -'‚ÇÅ = -' ((‚ÇÅ , Œª ())) in let x‚Åª¬π = ((x , nz) ‚Åª¬π) .proj‚ÇÅ in let -x‚Åª¬π = - x‚Åª¬π in let -y/x' = (((y , nzy) *' ((x , nz) ‚Åª¬π)) *' -'‚ÇÅ) in let -y/x = -y/x' .proj‚ÇÅ in
    Mz (y , nzy) ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H ‚âà S^ (-x‚Åª¬π * (y * y)) ‚Ä¢ Mz -y/x' ‚Ä¢ (H ‚Ä¢ S^ -x‚Åª¬π)
  derived-7 x y nzx nzy = begin
    Mz (y , nzy) ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H ‚âà‚ü® (cright derived-D x nzx) ‚ü©
    Mz (y , nzy) ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cright special-assoc (‚ñ° ‚Ä¢ ‚ñ° ‚Ä¢ ‚ñ° ‚Ä¢ ‚ñ° ‚Ä¢ ‚ñ° ‚Ä¢ ‚ñ° ‚Ä¢ ‚ñ°) (‚ñ° ^ 5 ‚Ä¢ ‚ñ° ‚Ä¢ ‚ñ°) auto) ‚ü©
    Mz (y , nzy) ‚Ä¢ (H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H) ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cright cleft sym left-unit) ‚ü©
    Mz (y , nzy) ‚Ä¢ (Œµ ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H) ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cright cleft cleft sym (lemma-S^-k+k x‚Åª¬π)) ‚ü©
    Mz (y , nzy) ‚Ä¢ ((S^ -x‚Åª¬π ‚Ä¢ S^ x‚Åª¬π) ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H) ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® special-assoc (‚ñ° ‚Ä¢ (‚ñ° ^ 2 ‚Ä¢ ‚ñ° ^ 5) ‚Ä¢ ‚ñ°) (‚ñ° ^ 2 ‚Ä¢ ‚ñ° ^ 6 ‚Ä¢ ‚ñ°) auto ‚ü©
    (Mz (y , nzy) ‚Ä¢ S^ -x‚Åª¬π) ‚Ä¢ (S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H) ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cleft (cright axiom (derived-S -x‚Åª¬π))) ‚ü©
    (Mz (y , nzy) ‚Ä¢ S ^ to‚Ñï -x‚Åª¬π) ‚Ä¢ (S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H) ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cleft derived-5 y (to‚Ñï -x‚Åª¬π) nzy) ‚ü©
    (S ^ (to‚Ñï -x‚Åª¬π Nat.* to‚Ñï (y * y)) ‚Ä¢ Mz (y , nzy)) ‚Ä¢ (S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H) ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® special-assoc (‚ñ° ^ 2 ‚Ä¢ ‚ñ° ^ 2) (‚ñ° ‚Ä¢ ‚ñ° ^ 2 ‚Ä¢ ‚ñ°) auto ‚ü©
    S ^ (to‚Ñï -x‚Åª¬π Nat.* to‚Ñï (y * y)) ‚Ä¢ (Mz (y , nzy) ‚Ä¢ (S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H)) ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cright cleft (cright (cright cright cleft refl' (Eq.cong S^ (Eq.sym (inv-involutive ((x , nz)))))))) ‚ü©
    S ^ (to‚Ñï -x‚Åª¬π Nat.* to‚Ñï (y * y)) ‚Ä¢ (Mz (y , nzy) ‚Ä¢ Mz ((x , nz) ‚Åª¬π)) ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cright cleft axiom (M-mul (y , nzy) ((x , nz) ‚Åª¬π))) ‚ü©
    S ^ (to‚Ñï -x‚Åª¬π Nat.* to‚Ñï (y * y)) ‚Ä¢ Mz ((y , nzy) *' ((x , nz) ‚Åª¬π)) ‚Ä¢ H ^ 3 ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cright special-assoc (‚ñ° ‚Ä¢ ‚ñ° ^ 3 ‚Ä¢ ‚ñ°) (‚ñ° ^ 3 ‚Ä¢ ‚ñ° ^ 2) auto) ‚ü©
    S ^ (to‚Ñï -x‚Åª¬π Nat.* to‚Ñï (y * y)) ‚Ä¢ (Mz ((y , nzy) *' ((x , nz) ‚Åª¬π)) ‚Ä¢ HH) ‚Ä¢ H ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cright cleft (cright lemma-HH-M-1)) ‚ü©
    S ^ (to‚Ñï -x‚Åª¬π Nat.* to‚Ñï (y * y)) ‚Ä¢ (Mz ((y , nzy) *' ((x , nz) ‚Åª¬π)) ‚Ä¢ Mz -'‚ÇÅ) ‚Ä¢ H ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cright cleft axiom (M-mul (((y , nzy) *' ((x , nz) ‚Åª¬π))) -'‚ÇÅ)) ‚ü©
    S ^ (to‚Ñï -x‚Åª¬π Nat.* to‚Ñï (y * y)) ‚Ä¢ (Mz (((y , nzy) *' ((x , nz) ‚Åª¬π)) *' -'‚ÇÅ) ) ‚Ä¢ H ‚Ä¢ S^ -x‚Åª¬π ‚âà‚ü® (cleft sym (lemma-S^ab -x‚Åª¬π (y * y))) ‚ü©
    S ^ to‚Ñï (-x‚Åª¬π * (y * y)) ‚Ä¢ Mz -y/x' ‚Ä¢ (H ‚Ä¢ S^ -x‚Åª¬π) ‚âà‚ü® cong (sym (axiom (derived-S (-x‚Åª¬π * (y * y))))) refl ‚ü©
    S^ (-x‚Åª¬π * (y * y)) ‚Ä¢ Mz -y/x' ‚Ä¢ (H ‚Ä¢ S^ -x‚Åª¬π) ‚àé
    where
    nz = nzx
    x‚Åª¬π = ((x , nz) ‚Åª¬π) .proj‚ÇÅ
    x‚Åª¬π‚Åª¬π = (((x , nz) ‚Åª¬π) ‚Åª¬π) .proj‚ÇÅ
    -x‚Åª¬π = - x‚Åª¬π
    -y/x' = (((y , nzy) *' ((x , nz) ‚Åª¬π)) *' -'‚ÇÅ)
    -y/x = -y/x' .proj‚ÇÅ



module NF1 (p-2 : ‚Ñï) (p-prime : Prime (‚ÇÇ‚Çä p-2)) where

  open import Zp.ModularArithmetic
  open PrimeModulus p-2 p-prime hiding (p)
  open Sym‚Ñï p-2 p-prime hiding (p) renaming (M to Mz)
  
  data C1 : Set where
    Œµ : C1
    HS : ‚Ñ§ ‚Çö -> C1

  data ZMultiplier : Set where
    M : (x : ‚Ñ§* ‚Çö) -> ZMultiplier

  data S·µè : Set where
    ùïä : ‚Ñ§ ‚Çö -> S·µè

  NF1' = ‚Ñ§ ‚Çö √ó ‚Ñ§* ‚Çö √ó (‚ä§ ‚äé ‚Ñ§ ‚Çö)
  
  data NF1 : Set where
    _‚àô_‚àô_ : S·µè -> ZMultiplier -> C1 -> NF1

  ‚ü¶_‚üß‚ÇÅ : C1 -> Word Gen
  ‚ü¶ Œµ ‚üß‚ÇÅ = Œµ
  ‚ü¶ HS x ‚üß‚ÇÅ = H ‚Ä¢ S^ x

  ‚ü¶_‚üß'‚ÇÅ : ‚ä§ ‚äé ‚Ñ§ ‚Çö -> Word Gen
  ‚ü¶ inj‚ÇÅ tt ‚üß'‚ÇÅ = Œµ
  ‚ü¶ inj‚ÇÇ x ‚üß'‚ÇÅ = H ‚Ä¢ S^ x

  ‚ü¶_‚üß‚Çõ : S·µè -> Word Gen
  ‚ü¶ ùïä x ‚üß‚Çõ = S^ x

  ‚ü¶_‚üß'‚Çõ : S·µè -> Word Gen
  ‚ü¶ ùïä x ‚üß'‚Çõ = S^ x

  ‚ü¶_‚üß‚Çò : ZMultiplier -> Word Gen
  ‚ü¶ M x' ‚üß‚Çò = Mz x'
    where
    x = to‚Ñï (x' .proj‚ÇÅ)
    x‚Åª¬π = to‚Ñï ((x' ‚Åª¬π) .proj‚ÇÅ )

  ‚ü¶_‚üß : NF1 -> Word Gen
  ‚ü¶ s ‚àô m ‚àô c ‚üß = ‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò ‚Ä¢ ‚ü¶ c ‚üß‚ÇÅ

  ‚ü¶_‚üß' : NF1' -> Word Gen
  ‚ü¶ s , m , c ‚üß' = S^ s ‚Ä¢ Mz m ‚Ä¢ ‚ü¶ c ‚üß'‚ÇÅ

  Pauli1 = ‚Ñ§ ‚Çö √ó ‚Ñ§ ‚Çö
  
  -- mod p equality
  p : ‚Ñï
  p = (‚ÇÇ‚Çä p-2)
  ùï° = p
  norm1 : Pauli1 ‚Üí Pauli1 ‚Üí ‚Ñ§ ‚Çö
  norm1 (a , b) (c , d) = (- a) * d + c * b

  open import Algebra.Properties.Ring (+-*-ring p-2)
  
  norm1-antisym : ‚àÄ (p q : Pauli1) -> norm1 p q ‚â° - norm1 q p
  norm1-antisym p@(a , b) q@(c , d) = begin
    norm1 (a , b) (c , d) ‚â°‚ü® auto ‚ü©
    (- a) * d + c * b ‚â°‚ü® +-comm (- a * d) (c * b) ‚ü©
    (c * b) + - a * d ‚â°‚ü® Eq.cong (_+ - a * d) (Eq.cong (_* b) (Eq.sym (-‚Äøinvolutive c))) ‚ü©
    (- - c * b) + - a * d ‚â°‚ü® Eq.cong‚ÇÇ _+_ (Eq.sym (-‚ÄødistribÀ°-* (- c) b)) (Eq.sym (-‚ÄødistribÀ°-* a d)) ‚ü©
    - (- c * b) + - (a * d) ‚â°‚ü® (-‚Äø+-comm (- c * b) (a * d)) ‚ü©
    - ((- c) * b + a * d) ‚â°‚ü® auto ‚ü©
    - norm1 (c , d) (a , b) ‚àé
    where
    open import Data.Integer.Tactic.RingSolver
    open ‚â°-Reasoning


  act1 : Gen ‚Üí Pauli1 ‚Üí Pauli1
  act1 (H-gen ‚ÇÄ) (a , b) = (a , b)
  act1 (H-gen ‚ÇÅ) (a , b) = (- b , a)
  act1 (H-gen ‚ÇÇ) (a , b) = (- a , - b)
  act1 (H-gen ‚ÇÉ) (a , b) = (b , - a)
  act1 (S-gen k) (a , b) = (a , b + a * k)

  act : Word Gen ‚Üí Pauli1 ‚Üí Pauli1
  act = word-act act1

  pI : Pauli1
  pI = (‚ÇÄ , ‚ÇÄ)

  pZ : Pauli1
  pZ = (‚ÇÄ , ‚ÇÅ)

  pX : Pauli1
  pX = (‚ÇÅ , ‚ÇÄ)


  open Eq
  0‚â¢1 : 0 ‚â¢ 1
  0‚â¢1 ()

  0‚â¢1+n : ‚àÄ n -> 0 ‚â¢ ‚ÇÅ‚Çä n
  0‚â¢1+n n ()

{-
  open import Data.Nat.DivMod using (m%n<n ; m*n%n‚â°0 ; m<n‚áím%n‚â°m)
  open import Data.Fin.Properties hiding (0‚â¢1+n )
  open import Data.Empty
  open import Relation.Nullary.Negation.Core 
  open import Data.Integer.DivMod
  open import Data.Integer.Properties
  open import Data.Integer.Divisibility.Signed
  open import Data.Integer.Tactic.RingSolver

  +x*+x‚Åª¬π=+1 : ‚àÄ x' ->
    let +x = + to‚Ñï (x' .proj‚ÇÅ) in
    let +x‚Åª¬π = + to‚Ñï ((x' ‚Åª¬π) .proj‚ÇÅ ) in
    
    (+x * +x‚Åª¬π) % ùï° ‚â° ‚ÇÅ
  +x*+x‚Åª¬π=+1 x' = begin
    (+x * +x‚Åª¬π) % ùï° ‚â°‚ü® auto ‚ü©
    (+ x * + x‚Åª¬π) % ùï° ‚â°‚ü® cong (_% ùï°) (sym (pos-* x x‚Åª¬π)) ‚ü©
    (+ (x Nat.* x‚Åª¬π)) % ùï° ‚â°‚ü® lemma-‚Åª¬π ≥' ( x' .proj‚ÇÅ) {{nzto‚Ñï {y = x' .proj‚ÇÅ} {neq0 = x' .proj‚ÇÇ}}} ‚ü©
    ‚ÇÅ ‚àé
    where
    open ‚â°-Reasoning
    x = to‚Ñï (x' .proj‚ÇÅ)
    x‚Åª¬π = to‚Ñï ((x' ‚Åª¬π) .proj‚ÇÅ )
    +x = + x
    +x‚Åª¬π = + x‚Åª¬π

  +x‚Åª¬π*+x=+1 : ‚àÄ x' ->
    let +x = + to‚Ñï (x' .proj‚ÇÅ) in
    let +x‚Åª¬π = + to‚Ñï ((x' ‚Åª¬π) .proj‚ÇÅ ) in
    
    (+x‚Åª¬π * +x) % ùï° ‚â° ‚ÇÅ
  +x‚Åª¬π*+x=+1 x' = begin
    (+x‚Åª¬π * +x) % ùï° ‚â°‚ü® auto ‚ü©
    (+ x‚Åª¬π * + x) % ùï° ‚â°‚ü® cong (_% ùï°) (sym (pos-* x‚Åª¬π x)) ‚ü©
    (+ (x‚Åª¬π Nat.* x)) % ùï° ‚â°‚ü® lemma-‚Åª¬πÀ°' ( x' .proj‚ÇÅ) {{nzto‚Ñï {y = x' .proj‚ÇÅ} {neq0 = x' .proj‚ÇÇ}}} ‚ü©
    ‚ÇÅ ‚àé
    where
    open ‚â°-Reasoning
    x = to‚Ñï (x' .proj‚ÇÅ)
    x‚Åª¬π = to‚Ñï ((x' ‚Åª¬π) .proj‚ÇÅ )
    +x = + x
    +x‚Åª¬π = + x‚Åª¬π

-}

  lemma-HS : ‚àÄ a b -> (neq0 : a ‚â¢ ‚ÇÄ) -> let a‚Åª¬π = (a , neq0) ‚Åª¬π in let -b/a = - b * a‚Åª¬π .proj‚ÇÅ in

    act (H ‚Ä¢ S^ -b/a) (a , b) ‚â° (‚ÇÄ , a)
    
  lemma-HS a b neq0 = begin
    act (H ‚Ä¢ S^ -b/a) (a , b) ‚â°‚ü® auto ‚ü©
    act (H) (a , b + a * -b/a) ‚â°‚ü® auto ‚ü©
    (- (b + a * -b/a) , a) ‚â°‚ü® cong (_, a) (cong -_ aux-ba) ‚ü©
    (- ‚ÇÄ , a) ‚â°‚ü® cong (_, a) -0#‚âà0# ‚ü©
    (‚ÇÄ , a) ‚àé
    where
    open ‚â°-Reasoning
    a‚Åª¬π = (a , neq0) ‚Åª¬π
    -b/a = - b * a‚Åª¬π .proj‚ÇÅ
    aux-ba : b + a * -b/a ‚â° ‚ÇÄ
    aux-ba = begin
      b + a * -b/a ‚â°‚ü® cong (b +_) (cong (a *_) (*-comm (- b) (a‚Åª¬π .proj‚ÇÅ))) ‚ü© -- cong (b +_) (sym (*-assoc a (- b) (a‚Åª¬π .proj‚ÇÅ))) ‚ü©
      b + a * (a‚Åª¬π .proj‚ÇÅ * - b) ‚â°‚ü® cong (b +_) (sym (*-assoc a (a‚Åª¬π .proj‚ÇÅ) (- b) )) ‚ü©
      b + a * a‚Åª¬π .proj‚ÇÅ * - b ‚â°‚ü® cong (b +_) (cong (_* - b) (lemma-‚Åª¬π ≥ a {{nzto‚Ñï {y = a} {neq0 = neq0}}})) ‚ü©
      b + 1‚Çö * - b ‚â°‚ü® cong (b +_) (*-identityÀ° (- b)) ‚ü©
      b + - b ‚â°‚ü®  +-inverse ≥ b ‚ü©
      ‚ÇÄ ‚àé


  lemma-HS-x : ‚àÄ k a b -> 

    act (H ‚Ä¢ S^ k) (a , b) ‚â° (- (b + a * k) , a)
    
  lemma-HS-x a b neq0 = auto

  lemma-Mz : ‚àÄ a b x' ->
    let x = (x' .proj‚ÇÅ) in
    let x‚Åª¬π = ((x' ‚Åª¬π) .proj‚ÇÅ) in
    
    act (Mz x') (a , b) ‚â° (a * x‚Åª¬π , b * x)
    
  lemma-Mz a b x' = begin
    act (Mz x') (a , b) ‚â°‚ü® auto ‚ü©
    act (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H) (a , b) ‚â°‚ü® auto ‚ü©
    act (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x) (- b , a) ‚â°‚ü® auto ‚ü©
    act (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H) (- b , a + (- b) * x) ‚â°‚ü® auto ‚ü©
    act (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π) ( - (a + (- b) * x) , - b) ‚â°‚ü® auto ‚ü©
    act (S^ x ‚Ä¢ H) ( - (a + (- b) * x) , - b + (- (a + (- b) * x)) * (x‚Åª¬π)) ‚â°‚ü® auto ‚ü©
    act (S^ x) ( - (- b + (- (a + (- b) * x)) * (x‚Åª¬π)) , - (a + (- b) * x) ) ‚â°‚ü® auto ‚ü©

    - (- b + - (a + - b * x) * x‚Åª¬π) , - (a + - b * x) + - (- b + - (a + - b * x) * x‚Åª¬π) * x ‚â°‚ü® Eq.sym (‚â°√ó‚â°‚áí‚â° (-‚Äø+-comm (- b) (- (a + - b * x) * x‚Åª¬π) , Eq.cong‚ÇÇ _+_ (-‚Äø+-comm a (- b * x)) (Eq.cong (_* x) (-‚Äø+-comm (- b) (- (a + - b * x) * x‚Åª¬π))))) ‚ü©
    - - b + - ((- (a + - b * x)) * x‚Åª¬π) , - a + - (- b * x) + (- - b + - (- (a + - b * x) * x‚Åª¬π)) * x ‚â°‚ü® ‚â°√ó‚â°‚áí‚â° (cong‚ÇÇ _+_ (-‚Äøinvolutive b) (-‚ÄødistribÀ°-* ((- (a + - b * x))) x‚Åª¬π) , cong‚ÇÇ _+_ (cong (- a +_) (-‚ÄødistribÀ°-* (- b) x)) (cong‚ÇÇ (\ xx yy -> (xx + yy) * x) (-‚Äøinvolutive b) (-‚ÄødistribÀ°-* (- (a + - b * x)) x‚Åª¬π))) ‚ü©
    b + - (- (a + - b * x)) * x‚Åª¬π , - a + - - b * x + (b + - - (a + - b * x) * x‚Åª¬π) * x ‚â°‚ü® ‚â°√ó‚â°‚áí‚â° (Eq.cong (\ xx -> b + xx * x‚Åª¬π) (-‚Äøinvolutive (a + - b * x)) ,  cong‚ÇÇ _+_ (cong (\ xx -> - a + xx * x) (-‚Äøinvolutive b)) (cong (\ xx -> (b + xx * x‚Åª¬π) * x) (-‚Äøinvolutive (a + - b * x)))) ‚ü©
    b + (a + - b * x) * x‚Åª¬π , - a + b * x + (b + (a + - b * x) * x‚Åª¬π) * x ‚â°‚ü® ‚â°√ó‚â°‚áí‚â° ((cong (b +_) (*-distrib ≥-+ x‚Åª¬π a (- b * x))) , cong (\ xx -> - a + b * x + xx) (*-distrib ≥-+ x b ((a + - b * x) * x‚Åª¬π))) ‚ü©
    b + (a * x‚Åª¬π + - b * x * x‚Åª¬π) , - a + b * x + (b * x + (a + - b * x) * x‚Åª¬π * x) ‚â°‚ü® ‚â°√ó‚â°‚áí‚â° ((cong (\ xx -> b + (a * x‚Åª¬π + xx)) (*-assoc (- b) x x‚Åª¬π)) , (cong (\ xx -> - a + b * x + (b * x + xx)) (*-assoc ((a + - b * x)) x‚Åª¬π x))) ‚ü©
    b + (a * x‚Åª¬π + - b * (x * x‚Åª¬π)) , - a + b * x + (b * x + (a + - b * x) * (x‚Åª¬π * x)) ‚â°‚ü® ‚â°√ó‚â°‚áí‚â° ((cong (\ xx -> b + (a * x‚Åª¬π + - b * xx)) (lemma-‚Åª¬π ≥ x {{nzto‚Ñï {y = x} {neq0 = x' .proj‚ÇÇ}}}) , (cong (\ xx -> - a + b * x + (b * x + (a + - b * x) * xx)) (lemma-‚Åª¬πÀ° x {{nzto‚Ñï {y = x} {neq0 = x' .proj‚ÇÇ}}})))) ‚ü©
    b + (a * x‚Åª¬π + - b * ‚ÇÅ) , - a + b * x + (b * x + (a + - b * x) * ‚ÇÅ) ‚â°‚ü® ‚â°√ó‚â°‚áí‚â° ((cong (\ xx -> b + (a * x‚Åª¬π + xx)) (*-identity ≥ (- b)) , (cong (\ xx -> - a + b * x + (b * x + xx)) (*-identity ≥ (a + - b * x))))) ‚ü©
    b + (a * x‚Åª¬π + - b) , - a + b * x + (b * x + (a + - b * x)) ‚â°‚ü® ‚â°√ó‚â°‚áí‚â° ((cong (b +_) (+-comm (a * x‚Åª¬π) (- b))) , (cong (\ xx -> - a + b * x + xx) (+-comm (b * x) ((a + - b * x))))) ‚ü©
    b + (- b + a * x‚Åª¬π) , - a + b * x + ((a + - b * x) + b * x) ‚â°‚ü® sym (‚â°√ó‚â°‚áí‚â° ((+-assoc b (- b) (a * x‚Åª¬π)) , (+-assoc (- a + b * x) ((a + - b * x)) (b * x)))) ‚ü©
    b + - b + a * x‚Åª¬π , - a + b * x + (a + - b * x) + b * x ‚â°‚ü® ‚â°√ó‚â°‚áí‚â° ((cong (_+ a * x‚Åª¬π) (+-inverse ≥ b)) , (cong (_+ b * x) (+-assoc (- a) (b * x) ((a + - b * x))))) ‚ü©
    ‚ÇÄ + a * x‚Åª¬π , - a + (b * x + (a + - b * x)) + b * x ‚â°‚ü® ‚â°√ó‚â°‚áí‚â° ((+-identityÀ° (a * x‚Åª¬π)) , cong (\ xx -> - a + (b * x + xx) + b * x) (+-comm a (- b * x))) ‚ü©
    a * x‚Åª¬π , - a + (b * x + (- b * x + a)) + b * x ‚â°‚ü® cong (\ xx -> a * x‚Åª¬π , - a + xx + b * x) (sym (+-assoc (b * x) (- b * x) a)) ‚ü©
    a * x‚Åª¬π , - a + (b * x + - b * x + a) + b * x ‚â°‚ü® cong (\ xx -> a * x‚Åª¬π , - a + (b * x + xx + a) + b * x) (sym (-‚ÄødistribÀ°-* b x)) ‚ü©
    a * x‚Åª¬π , - a + (b * x + - (b * x) + a) + b * x ‚â°‚ü® cong (\ xx -> a * x‚Åª¬π , - a + (xx + a) + b * x) (+-inverse ≥ (b * x)) ‚ü©
    a * x‚Åª¬π , - a + (‚ÇÄ + a) + b * x ‚â°‚ü® cong (\ xx -> a * x‚Åª¬π , - a + xx + b * x) (+-identityÀ° a) ‚ü©
    a * x‚Åª¬π , - a + a + b * x ‚â°‚ü® cong (\ xx -> a * x‚Åª¬π , xx + b * x) (+-inverseÀ° a) ‚ü©
    a * x‚Åª¬π , ‚ÇÄ + b * x ‚â°‚ü® cong (\ xx -> a * x‚Åª¬π , xx) (+-identityÀ° (b * x)) ‚ü©
    a * x‚Åª¬π , b * x ‚àé
    where
    open ‚â°-Reasoning
    x = (x' .proj‚ÇÅ)
    x‚Åª¬π = ((x' ‚Åª¬π) .proj‚ÇÅ )


  norm-pI-q=0 : ‚àÄ (p : Pauli1) -> norm1 pI p ‚â° ‚ÇÄ
  norm-pI-q=0 (c , d) = begin
    norm1 pI (c , d) ‚â°‚ü® auto ‚ü©
    (- ‚ÇÄ) * d + c * ‚ÇÄ ‚â°‚ü® cong‚ÇÇ _+_ (cong (_* d) -0#‚âà0#) (*-comm c ‚ÇÄ) ‚ü©
    ‚ÇÄ * d + ‚ÇÄ * c ‚â°‚ü® auto ‚ü©
    ‚ÇÄ ‚àé
    where open ‚â°-Reasoning

  norm-0b : ‚àÄ b c d -> norm1 (‚ÇÄ , b) (c , d) ‚â° b * c
  norm-0b b c d = begin
    norm1 (‚ÇÄ , b) (c , d) ‚â°‚ü® auto ‚ü©
    (- ‚ÇÄ) * d + c * b ‚â°‚ü® cong (\ xx -> xx * d + c * b) -0#‚âà0# ‚ü©
    ‚ÇÄ * d + c * b ‚â°‚ü® auto ‚ü©
    ‚ÇÄ + c * b ‚â°‚ü® +-identityÀ° (c * b) ‚ü©
    c * b ‚â°‚ü® *-comm c b ‚ü©
    b * c ‚àé
    where open ‚â°-Reasoning

  aux3 : ‚àÄ (k c q : ‚Ñ§ ‚Çö) -> k * q * c ‚â° (k * c) * q
  aux3 k c q = begin
    (k * q) * c ‚â°‚ü® (*-assoc k q c) ‚ü©
    k * (q * c) ‚â°‚ü® cong (k *_) (*-comm q c) ‚ü©
    k * (c * q) ‚â°‚ü® sym (*-assoc k c q) ‚ü©
    (k * c) * q ‚àé
    where
    open ‚â°-Reasoning
    open Sol p-2 renaming (solve to sol)

  aux4 : ‚àÄ b k c p -> b ‚â° k * p -> b * c ‚â° (k * c) * p
  aux4 b k c p eq = begin
    b * c ‚â°‚ü® cong (_* c) eq ‚ü©
    k * p * c ‚â°‚ü® aux3 k c p ‚ü©
    (k * c) * p ‚àé
    where open ‚â°-Reasoning

{-
  aux6 : ‚àÄ k p-2 -> let p = (‚ÇÇ‚Çä p-2) in (k * p) % p ‚â° 0
  aux6 (+_ ‚ÇÄ) p-2 = auto
  aux6 +[1+ n ] p-2 = let p = + (‚ÇÇ‚Çä p-2) in m*n%n‚â°0 (‚ÇÅ‚Çä n)  ‚à£ p ‚à£
  aux6 k@(-[1+ n ]) p-2 with ((Nat.suc n) Nat.* (‚ÇÇ‚Çä p-2)) Nat.% (‚ÇÇ‚Çä p-2) | inspect ( Nat._% (‚ÇÇ‚Çä p-2)) ((Nat.suc n) Nat.* (‚ÇÇ‚Çä p-2))
  ... | ‚ÇÄ | [ eqh ]' = auto
  ... | ‚ÇÅ‚Çä hyp | [ eqh ]' with 0‚â¢1+n hyp (trans (Eq.sym (m*n%n‚â°0 ((Nat.suc n) ) ((‚ÇÇ‚Çä p-2)))) eqh)
  ... | ()
-}


  Theorem-NF1 :

    ‚àÄ (p q : Pauli1) ->
    norm1 p q ‚â° ‚ÇÅ ->
    -------------------------------
    ‚àÉ \ nf -> act ‚ü¶ nf ‚üß p ‚â° pZ √ó
              act ‚ü¶ nf ‚üß q ‚â° pX

  Theorem-NF1 p@((‚ÇÄ , ‚ÇÄ)) q@(q1) eq with 0‚Çö‚â¢1‚Çö (Eq.trans (Eq.sym (norm-pI-q=0 q)) (eq))
  ... | ()


  Theorem-NF1 p@(‚ÇÄ , b@(‚ÇÅ‚Çä b')) q@(c , d) eq = nf , claim1 , claim2
    where
    open ‚â°-Reasoning
    -b = - b

    -bnz : - b ‚â¢ 0‚Çö
    -bnz = (-' (b , Œª ())) .proj‚ÇÇ

    b‚Åª¬π = (b , Œª ()) ‚Åª¬π
    -b‚Åª¬π = -' b‚Åª¬π

    x‚Åª¬π = _‚Åª¬π b‚Åª¬π .proj‚ÇÅ
    x = b‚Åª¬π .proj‚ÇÅ

    -dx = - (d * x)

    nf = ùïä -dx ‚àô M b‚Åª¬π ‚àô Œµ
    claim1 : act ‚ü¶ nf ‚üß p ‚â° pZ
    claim1 = begin
      act ‚ü¶ nf ‚üß p ‚â°‚ü® auto ‚ü©
      act (S^ -dx ‚Ä¢ (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H) ‚Ä¢ Œµ) p ‚â°‚ü® auto ‚ü©
      act (S^ -dx ‚Ä¢ (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H)) p ‚â°‚ü® auto ‚ü©
      act (S^ -dx ‚Ä¢ (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H)) p ‚â°‚ü® auto ‚ü©
      act (S^ -dx) (act (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H) p) ‚â°‚ü® cong (act (S^ -dx)) (lemma-Mz (p .proj‚ÇÅ) (p .proj‚ÇÇ) b‚Åª¬π) ‚ü©
      act (S^ -dx) (‚ÇÄ * x‚Åª¬π , b * x ) ‚â°‚ü® cong (\ xx -> act (S^ -dx) (‚ÇÄ , xx )) (*-comm b x) ‚ü©
      act (S^ -dx) (‚ÇÄ , x * b ) ‚â°‚ü® cong (\ xx -> act (S^ -dx) (‚ÇÄ , xx)) (lemma-‚Åª¬πÀ° b {{nzto‚Ñï {y = b} {neq0 = Œª ()}}}) ‚ü©
      pZ ‚àé

    cb=1 : c * b ‚â° 1‚Çö
    cb=1 = begin
      c * b ‚â°‚ü® *-comm c b ‚ü©
      b * c ‚â°‚ü® sym (norm-0b b c d) ‚ü©
      norm1 p q ‚â°‚ü® eq ‚ü©
      1‚Çö ‚àé
      
    claim2 : act ‚ü¶ nf ‚üß q ‚â° pX
    claim2 = begin
      act ‚ü¶ nf ‚üß q ‚â°‚ü® cong (act (S^ -dx)) (lemma-Mz c d b‚Åª¬π) ‚ü©
      act (S^ -dx) (c * x‚Åª¬π , d * x ) ‚â°‚ü® cong (\ xx -> act (S^ -dx) (c * xx , d * x )) (inv-involutive ((b , Œª ()))) ‚ü©
      act (S^ -dx) (c * b , d * x ) ‚â°‚ü® cong (\ xx -> act (S^ -dx) (xx , d * x )) cb=1 ‚ü©
      act (S^ -dx) (1‚Çö , d * x ) ‚â°‚ü® auto ‚ü©
      (1‚Çö , d * x + 1‚Çö * -dx) ‚â°‚ü® cong (\ xx -> 1‚Çö , d * x + xx) (*-identityÀ° -dx) ‚ü©
      (1‚Çö , d * x + -dx) ‚â°‚ü®  cong (\ xx -> 1‚Çö , xx) (+-inverse ≥ (d * x)) ‚ü©
      pX ‚àé

  Theorem-NF1 p@(a@(‚ÇÅ‚Çä _) , b) q@(c , d) eq = nf , (claim1 , claim2)
    where
    open ‚â°-Reasoning
    
    a‚Åª¬π = (a , Œª ()) ‚Åª¬π
    1/a = a‚Åª¬π .proj‚ÇÅ
    -b/a = - b * 1/a
    x = 1/a
    x‚Åª¬π = (a‚Åª¬π ‚Åª¬π) .proj‚ÇÅ
    -c/a = - c * 1/a

    nf = ùïä -c/a ‚àô M a‚Åª¬π ‚àô HS -b/a
    p' = act (H ‚Ä¢ S^ -b/a) p
    
    claim1 : act ‚ü¶ nf ‚üß p ‚â° pZ
    claim1 = begin
      act ‚ü¶ nf ‚üß p ‚â°‚ü® auto ‚ü©
      act (S^ -c/a ‚Ä¢ (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H) ‚Ä¢ (H ‚Ä¢ S^ -b/a)) p ‚â°‚ü® auto ‚ü©
      act (S^ -c/a ‚Ä¢ (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H)) p' ‚â°‚ü® auto ‚ü©
      act (S^ -c/a ‚Ä¢ (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H)) p' ‚â°‚ü® auto ‚ü©
      act (S^ -c/a) (act (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H) p') ‚â°‚ü® cong (\ xx -> act (S^ -c/a) (act (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H) xx)) (lemma-HS a b (Œª ())) ‚ü©
      act (S^ -c/a) (act (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H) (‚ÇÄ , a)) ‚â°‚ü® cong (act (S^ -c/a)) (lemma-Mz (‚ÇÄ) (a) a‚Åª¬π) ‚ü©
      act (S^ -c/a) (‚ÇÄ * x‚Åª¬π , a * x ) ‚â°‚ü® cong (\ xx -> act (S^ -c/a) (‚ÇÄ , xx )) (lemma-‚Åª¬π ≥ a {{nzto‚Ñï {y = a} {neq0 = Œª ()}}}) ‚ü©
      act (S^ -c/a) (‚ÇÄ , ‚ÇÅ ) ‚â°‚ü® auto ‚ü©
      act (S^ -c/a) (‚ÇÄ , ‚ÇÅ + ‚ÇÄ * -c/a ) ‚â°‚ü® auto ‚ü©
      pZ ‚àé

    q' = act (H ‚Ä¢ S^ -b/a) q

    aux-dca : - (d + c * -b/a) * a ‚â° ‚ÇÅ
    aux-dca = begin
      - (d + c * -b/a) * a ‚â°‚ü® cong (_* a) (sym (-‚Äø+-comm d (c * -b/a))) ‚ü©
      (- d + -(c * -b/a)) * a ‚â°‚ü® cong (\ xx -> (- d + xx) * a ) (-‚ÄødistribÀ°-* c -b/a) ‚ü©
      (- d + - c * -b/a) * a ‚â°‚ü® *-distrib ≥-+ a (- d) (- c * -b/a) ‚ü©
      - d * a + - c * -b/a * a ‚â°‚ü® auto ‚ü©
      - d * a + - c * (- b * 1/a) * a ‚â°‚ü® cong (\ xx -> - d * a + xx) (*-assoc (- c) (- b * 1/a) a) ‚ü©
      - d * a + - c * ((- b * 1/a) * a) ‚â°‚ü®  cong (\ xx -> - d * a + - c * xx) (*-assoc (- b) 1/a a) ‚ü©
      - d * a + - c * (- b * (1/a * a)) ‚â°‚ü® cong (\ xx -> - d * a + - c * (- b * xx)) (lemma-‚Åª¬πÀ° a {{nzto‚Ñï {y = a} {neq0 = Œª ()}}}) ‚ü©
      - d * a + - c * (- b * ‚ÇÅ) ‚â°‚ü® cong (\ xx -> - d * a + - c * (xx)) (*-identity ≥ (- b)) ‚ü©
      - d * a + - c * - b ‚â°‚ü® cong (\ xx -> - d * a + xx) (sym (-‚Äødistrib ≥-* (- c) b)) ‚ü©
      - d * a + - (- c * b) ‚â°‚ü® cong (\ xx -> - d * a + - xx) (sym (-‚ÄødistribÀ°-* (c) b)) ‚ü©
      - d * a + - - (c * b) ‚â°‚ü® cong‚ÇÇ _+_ (*-comm (- d) a) (-‚Äøinvolutive (c * b)) ‚ü©
      a * - d + (c * b) ‚â°‚ü® cong (_+ (c * b)) (trans (sym (-‚Äødistrib ≥-* a d)) ((-‚ÄødistribÀ°-* a d))) ‚ü©
      - a * d + (c * b) ‚â°‚ü® eq ‚ü©
      ‚ÇÅ ‚àé

    aux-dx : c * x + ‚ÇÅ * -c/a ‚â° ‚ÇÄ
    aux-dx = begin
      c * x + ‚ÇÅ * -c/a ‚â°‚ü® auto ‚ü©
      c * 1/a + ‚ÇÅ * -c/a ‚â°‚ü® cong (c * 1/a +_) (*-identityÀ° -c/a) ‚ü©
      c * 1/a + -c/a ‚â°‚ü® sym (*-distrib ≥-+ 1/a c (- c)) ‚ü©
      (c + - c) * 1/a ‚â°‚ü® cong (_* 1/a) (+-inverse ≥ c) ‚ü©
      ‚ÇÄ * 1/a ‚â°‚ü® auto ‚ü©
      ‚ÇÄ ‚àé

    claim2 : act ‚ü¶ nf ‚üß q ‚â° pX
    claim2 = begin
      act ‚ü¶ nf ‚üß q ‚â°‚ü® auto ‚ü©
      act (S^ -c/a ‚Ä¢ (S^ x ‚Ä¢ H ‚Ä¢ S^ x‚Åª¬π ‚Ä¢ H ‚Ä¢ S^ x ‚Ä¢ H)) (- (d + c * -b/a) , c) ‚â°‚ü® cong (act (S^ -c/a)) (lemma-Mz (- (d + c * -b/a)) c a‚Åª¬π) ‚ü©
      act (S^ -c/a) (- (d + c * -b/a) * x‚Åª¬π , c * x ) ‚â°‚ü® cong (\ xx -> act (S^ -c/a) (- (d + c * -b/a) * xx , c * x )) (inv-involutive (a , (Œª ()))) ‚ü©
      act (S^ -c/a) (- (d + c * -b/a) * a , c * x ) ‚â°‚ü® cong (\ xx -> act (S^ -c/a) (xx , c * x )) aux-dca ‚ü©
      act (S^ -c/a) (‚ÇÅ , c * x ) ‚â°‚ü® auto ‚ü©
      (‚ÇÅ , c * x + ‚ÇÅ * -c/a ) ‚â°‚ü® cong (‚ÇÅ ,_) aux-dx ‚ü©
      pX ‚àé


module Completeness (p-2 : ‚Ñï) (p-prime : Prime (‚ÇÇ‚Çä p-2)) where

  open import Zp.ModularArithmetic
  open PrimeModulus p-2 p-prime hiding (p)
  open NF1 p-2 p-prime hiding (p)
  open Sym‚Ñï p-2 p-prime renaming (M to Mz)

  open Rewriting
  open Symplectic-Powers p-2 p-prime
  open Symplectic-Rewriting-HH p-2 p-prime
  open Lemmas p-2 p-prime

  open PB _===_ hiding (_===_)
  open PP _===_
  open SR word-setoid
  open Pattern-Assoc

--  update-nf : ‚àÄ (nf : NF1) (g : Gen) -> NF1

  PrimitiveGen : Gen -> Set
  PrimitiveGen (Sym‚Ñï.H-gen ‚ÇÅ) = ‚ä§
  PrimitiveGen (Sym‚Ñï.S-gen ‚ÇÅ) = ‚ä§
  PrimitiveGen (Sym‚Ñï.H-gen x) = ‚ä•
  PrimitiveGen (Sym‚Ñï.S-gen x) = ‚ä•

  Lemma-single-qupit-completeness :
    
    ‚àÄ (nf : NF1) (g : Gen) (pg : PrimitiveGen g) ->
    -----------------------------------------------
    ‚àÉ \ nf' -> ‚ü¶ nf ‚üß ‚Ä¢ [ g ‚Üë] ‚âà ‚ü¶ nf' ‚üß
    
  Lemma-single-qupit-completeness nf@(s ‚àô m ‚àô Œµ) (Sym‚Ñï.H-gen ‚ÇÅ) pg = (s ‚àô m ‚àô HS ‚ÇÄ) , claim
    where
    claim : (‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò ‚Ä¢ Œµ) ‚Ä¢ [ H-gen ‚ÇÅ ‚Üë] ‚âà ‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò ‚Ä¢ H ‚Ä¢ S^ ‚ÇÄ
    claim = begin
      (‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò ‚Ä¢ Œµ) ‚Ä¢ H ‚âà‚ü® _‚âà_.cong (_‚âà_.cong refl right-unit) refl ‚ü©
      (‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò) ‚Ä¢ H ‚âà‚ü® by-assoc auto ‚ü©
      (‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò) ‚Ä¢ H ‚Ä¢ Œµ ‚âà‚ü® (cright cright _‚âà_.sym (axiom (derived-S ‚ÇÄ))) ‚ü©
      (‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò) ‚Ä¢ H ‚Ä¢ S^ ‚ÇÄ ‚âà‚ü® assoc ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò ‚Ä¢ H ‚Ä¢ S^ ‚ÇÄ ‚àé
  Lemma-single-qupit-completeness nf@(s ‚àô M x ‚àô HS ‚ÇÄ) (Sym‚Ñï.H-gen ‚ÇÅ) pg = nf' , {!!}
    where
    x'  = x *' -'‚ÇÅ
    nf' = s ‚àô M x' ‚àô Œµ
    claim : ‚ü¶ s ‚àô M x ‚àô HS ‚ÇÄ ‚üß ‚Ä¢ [ H-gen ‚ÇÅ ‚Üë] ‚âà ‚ü¶ nf' ‚üß
    claim = begin
      ‚ü¶ s ‚àô M x ‚àô HS ‚ÇÄ ‚üß ‚Ä¢ [ H-gen ‚ÇÅ ‚Üë] ‚âà‚ü® trans assoc (cright {!assoc!}) ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ Mz x ‚Ä¢ (H ‚Ä¢ S ^ 0) ‚Ä¢ H ‚âà‚ü® {!!} ‚ü©
      ‚ü¶ nf' ‚üß ‚àé
    
  Lemma-single-qupit-completeness nf@(s ‚àô m ‚àô HS k@(‚ÇÅ‚Çä k')) (Sym‚Ñï.H-gen ‚ÇÅ) pg = (s ‚àô m ‚àô HS ‚ÇÄ) , {!!}
  Lemma-single-qupit-completeness nf@(s ‚àô m ‚àô c) (Sym‚Ñï.S-gen ‚ÇÅ) pg = {!!}


  Theorem-single-qupit-completeness :
    
    ‚àÄ (nf : NF1) (g : Gen) ->
    ------------------------------------
    ‚àÉ \ nf' -> ‚ü¶ nf ‚üß ‚Ä¢ [ g ‚Üë] ‚âà ‚ü¶ nf' ‚üß
    
  Theorem-single-qupit-completeness nf@(s ‚àô m ‚àô Œµ) (Sym‚Ñï.H-gen ‚ÇÄ) = nf , (_‚âà_.trans (_‚âà_.cong refl (axiom (derived-H ‚ÇÄ))) right-unit)
  Theorem-single-qupit-completeness (s ‚àô m ‚àô Œµ) (Sym‚Ñï.H-gen ‚ÇÅ) = (s ‚àô m ‚àô HS ‚ÇÄ) , claim
    where
    claim : (‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò ‚Ä¢ Œµ) ‚Ä¢ [ H-gen ‚ÇÅ ‚Üë] ‚âà ‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò ‚Ä¢ H ‚Ä¢ S^ ‚ÇÄ
    claim = begin
      (‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò ‚Ä¢ Œµ) ‚Ä¢ H ‚âà‚ü® _‚âà_.cong (_‚âà_.cong refl right-unit) refl ‚ü©
      (‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò) ‚Ä¢ H ‚âà‚ü® by-assoc auto ‚ü©
      (‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò) ‚Ä¢ H ‚Ä¢ Œµ ‚âà‚ü® (cright cright _‚âà_.sym (axiom (derived-S ‚ÇÄ))) ‚ü©
      (‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò) ‚Ä¢ H ‚Ä¢ S^ ‚ÇÄ ‚âà‚ü® assoc ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ m ‚üß‚Çò ‚Ä¢ H ‚Ä¢ S^ ‚ÇÄ ‚àé
    
  Theorem-single-qupit-completeness (s ‚àô M x ‚àô Œµ) (Sym‚Ñï.H-gen ‚ÇÇ) = nf' , claim
    where
--    -'‚ÇÅ = -' ((‚ÇÅ , Œª ()))
    m' = M (x *' -'‚ÇÅ)
    nf' = s ‚àô m' ‚àô Œµ
    claim : ‚ü¶ s ‚àô M x ‚àô Œµ ‚üß ‚Ä¢ [ H-gen ‚ÇÇ ‚Üë] ‚âà ‚ü¶ nf' ‚üß
    claim = begin
      ‚ü¶ s ‚àô M x ‚àô Œµ ‚üß ‚Ä¢ [ H-gen ‚ÇÇ ‚Üë] ‚âà‚ü® cong refl (axiom (derived-H ‚ÇÇ)) ‚ü©
      ‚ü¶ s ‚àô M x ‚àô Œµ ‚üß ‚Ä¢ HH ‚âà‚ü® trans assoc (cong refl assoc) ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ M x ‚üß‚Çò ‚Ä¢ Œµ ‚Ä¢ HH ‚âà‚ü® (cright cright left-unit) ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ M x ‚üß‚Çò ‚Ä¢ HH ‚âà‚ü® (cright cright lemma-HH-M-1) ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ M x ‚üß‚Çò ‚Ä¢ Mz -'‚ÇÅ ‚âà‚ü® (cright axiom (M-mul x -'‚ÇÅ)) ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ Mz (x *' -'‚ÇÅ) ‚âà‚ü® sym (cong refl right-unit) ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ Mz (x *' -'‚ÇÅ) ‚Ä¢ Œµ ‚âà‚ü® refl ‚ü©
      ‚ü¶ nf' ‚üß ‚àé
      
  Theorem-single-qupit-completeness (s ‚àô M x ‚àô Œµ) (Sym‚Ñï.H-gen ‚ÇÉ) = nf' , claim
    where
--    -'‚ÇÅ = -' ((‚ÇÅ , Œª ()))
    m' = M (x *' -'‚ÇÅ)
    nf' = s ‚àô m' ‚àô HS ‚ÇÄ
    claim : ‚ü¶ s ‚àô M x ‚àô Œµ ‚üß ‚Ä¢ [ H-gen ‚ÇÉ ‚Üë] ‚âà ‚ü¶ nf' ‚üß
    claim = begin
      ‚ü¶ s ‚àô M x ‚àô Œµ ‚üß ‚Ä¢ [ H-gen ‚ÇÉ ‚Üë] ‚âà‚ü® cong refl (axiom (derived-H ‚ÇÉ)) ‚ü©
      ‚ü¶ s ‚àô M x ‚àô Œµ ‚üß ‚Ä¢ H ^ 3 ‚âà‚ü® trans assoc (cong refl assoc) ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ M x ‚üß‚Çò ‚Ä¢ Œµ ‚Ä¢ H ^ 3 ‚âà‚ü® (cright cright by-assoc auto) ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ ‚ü¶ M x ‚üß‚Çò ‚Ä¢ HH ‚Ä¢ H ‚âà‚ü® sym (cong refl assoc) ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ (‚ü¶ M x ‚üß‚Çò ‚Ä¢ HH) ‚Ä¢ H ‚âà‚ü® (cright cleft cright lemma-HH-M-1) ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ (‚ü¶ M x ‚üß‚Çò ‚Ä¢ Mz -'‚ÇÅ) ‚Ä¢ H ‚âà‚ü® (cright cleft axiom (M-mul x -'‚ÇÅ)) ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ Mz (x *' -'‚ÇÅ) ‚Ä¢ H  ‚âà‚ü® cright cright sym (trans (cong refl (axiom (derived-S ‚ÇÄ))) right-unit) ‚ü©
      ‚ü¶ s ‚üß‚Çõ ‚Ä¢ Mz (x *' -'‚ÇÅ) ‚Ä¢ H ‚Ä¢ S^ ‚ÇÄ ‚âà‚ü® refl ‚ü©
      ‚ü¶ nf' ‚üß ‚àé
      
  Theorem-single-qupit-completeness (s NF1.‚àô NF1.M x' ‚àô NF1.HS ‚ÇÄ) (Sym‚Ñï.H-gen ‚ÇÄ) = {!!}
  Theorem-single-qupit-completeness (s NF1.‚àô NF1.M x' ‚àô NF1.HS ‚ÇÄ) (Sym‚Ñï.H-gen ‚ÇÅ) = {!!}
  Theorem-single-qupit-completeness (s NF1.‚àô NF1.M x' ‚àô NF1.HS ‚ÇÄ) (Sym‚Ñï.H-gen ‚ÇÇ) = {!!}
  Theorem-single-qupit-completeness (s NF1.‚àô NF1.M x' ‚àô NF1.HS ‚ÇÄ) (Sym‚Ñï.H-gen ‚ÇÉ) = {!!}
    where
    nf'p = Theorem-single-qupit-completeness (s ‚àô M x' ‚àô Œµ) (H-gen ‚ÇÄ)
  Theorem-single-qupit-completeness nf@(s ‚àô m ‚àô HS k@(‚ÇÅ‚Çä _)) (Sym‚Ñï.H-gen ‚ÇÄ) = nf , (trans (cong refl (axiom (derived-H ‚ÇÄ))) right-unit)
  Theorem-single-qupit-completeness (s ‚àô M x' ‚àô HS (‚ÇÅ‚Çä k)) (Sym‚Ñï.H-gen ‚ÇÅ) = {!!}
    -- where
    -- -'‚ÇÅ = -' ((‚ÇÅ , Œª ()))
    -- x‚Åª¬π = (x' ‚Åª¬π) .proj‚ÇÅ
    -- x‚Åª¬π‚Åª¬π = ((x' ‚Åª¬π) ‚Åª¬π) .proj‚ÇÅ
    -- -x‚Åª¬π = - x‚Åª¬π
    -- y = k
    -- -y/x' = (((y , nzy) *' ((x , nz) ‚Åª¬π)) *' -'‚ÇÅ)
    -- -y/x = -y/x' .proj‚ÇÅ
  
  Theorem-single-qupit-completeness (s ‚àô m ‚àô HS k) (Sym‚Ñï.H-gen ‚ÇÇ) = {!!}
  Theorem-single-qupit-completeness (s ‚àô m ‚àô HS k) (Sym‚Ñï.H-gen ‚ÇÉ) = {!!}
  Theorem-single-qupit-completeness (s ‚àô m ‚àô HS k) (Sym‚Ñï.S-gen x) = {!!}
  Theorem-single-qupit-completeness (s ‚àô m ‚àô Œµ) (Sym‚Ñï.S-gen x) = {!!}


{-
module Symplectic-Lemmas where

  open Symplectic
  open PP _===_
  open PB _===_ hiding (_===_)
  open SR word-setoid
  open Symplectic-Powers
  
  lemma-comm-HHSHHS : H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚âà S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H
  lemma-comm-HHSHHS = begin
    H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚âà‚ü® by-assoc auto ‚ü©
    (H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S) ‚âà‚ü® cong (axiom comm-HHS) (axiom comm-HHS) ‚ü©
    (S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H) ‚âà‚ü® by-assoc auto ‚ü©
    S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚àé
    
  lemma-order-Z : Z ^ 2 ‚Ä¢ Z ‚âà Œµ
  lemma-order-Z = begin
    Z ^ 2 ‚Ä¢ Z ‚âà‚ü® by-assoc auto ‚ü©
    (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ S ^ 2 ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ S ‚âà‚ü® cong (lemma-comm-HHSHHS) (_‚âà_.cong (_‚âà_.sym (lemma-comm-HHSHHS)) _‚âà_.refl) ‚ü©
    (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ S ^ 2 ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ S ‚âà‚ü® by-assoc auto ‚ü©
    (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ H ^ 4 ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ S ^ 3 ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ S ‚âà‚ü® cong _‚âà_.refl (cong (_‚âà_.axiom order-H) (_‚âà_.cong _‚âà_.refl (_‚âà_.cong (_‚âà_.axiom order-S) _‚âà_.refl))) ‚ü©
    (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ Œµ ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ Œµ ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ S ‚âà‚ü® by-assoc auto ‚ü©
    (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S) ‚Ä¢ H ^ 4 ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚âà‚ü® _‚âà_.cong _‚âà_.refl (_‚âà_.cong (_‚âà_.axiom order-H) _‚âà_.refl) ‚ü©
    (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S) ‚Ä¢ Œµ ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚âà‚ü® by-assoc auto ‚ü©
    (S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ S ^ 3 ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚âà‚ü® _‚âà_.cong _‚âà_.refl (_‚âà_.cong (_‚âà_.axiom order-S) _‚âà_.refl) ‚ü©
    (S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ Œµ ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚âà‚ü® by-assoc auto ‚ü©
    S ‚Ä¢ H ^ 4 ‚Ä¢ S ‚Ä¢ S ‚âà‚ü® _‚âà_.cong _‚âà_.refl (_‚âà_.cong (_‚âà_.axiom order-H) _‚âà_.refl) ‚ü©
    S ‚Ä¢ Œµ ‚Ä¢ S ‚Ä¢ S ‚âà‚ü® _‚âà_.trans (_‚âà_.cong _‚âà_.refl _‚âà_.left-unit) (_‚âà_.axiom order-S) ‚ü©
    Œµ ‚àé

  lemma-order-X : X ^ 2 ‚Ä¢ X ‚âà Œµ
  lemma-order-X = begin
    X ^ 2 ‚Ä¢ X ‚âà‚ü® by-assoc auto ‚ü©
    (H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ S) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ S ^ 2 ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® cong refl (_‚âà_.cong (_‚âà_.sym (lemma-comm-HHSHHS)) _‚âà_.refl) ‚ü©
    (H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ S) ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ S ^ 2 ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® by-assoc auto ‚ü©
    (H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ S ^ 3 ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® _‚âà_.cong _‚âà_.refl (_‚âà_.cong (_‚âà_.axiom order-S) _‚âà_.refl) ‚ü©
    (H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ Œµ ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® by-assoc auto ‚ü©
    (H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ H ^ 4 ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® _‚âà_.cong _‚âà_.refl (_‚âà_.cong (_‚âà_.axiom order-H) _‚âà_.refl) ‚ü©
    (H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ Œµ ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® by-assoc auto ‚ü©
    H ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ S ^ 2 ‚Ä¢ H ‚Ä¢ H ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® cong refl (_‚âà_.cong (_‚âà_.sym (lemma-comm-HHSHHS)) _‚âà_.refl) ‚ü©
    H ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ S ^ 2 ‚Ä¢ H ‚Ä¢ H ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® by-assoc auto ‚ü©
    (H ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ S ^ 3 ‚Ä¢ H ‚Ä¢ H ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® _‚âà_.cong _‚âà_.refl (_‚âà_.cong (_‚âà_.axiom order-S) _‚âà_.refl) ‚ü©
    (H ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ Œµ ‚Ä¢ H ‚Ä¢ H ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® by-assoc auto ‚ü©
    (H ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ H ^ 4 ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® _‚âà_.cong _‚âà_.refl (_‚âà_.cong (_‚âà_.axiom order-H) _‚âà_.refl) ‚ü©
    (H ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ Œµ ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® by-assoc auto ‚ü©
    (H ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ S ^ 3 ‚Ä¢ H ‚âà‚ü® _‚âà_.cong _‚âà_.refl (_‚âà_.cong (_‚âà_.axiom order-S) _‚âà_.refl) ‚ü©
    (H ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ Œµ ‚Ä¢ H ‚âà‚ü® by-assoc auto ‚ü©
    H ‚Ä¢ H ‚Ä¢ H ‚Ä¢ H ‚âà‚ü® _‚âà_.axiom order-H ‚ü©
    Œµ ‚àé

  lemma-comm-Z-S : Z ‚Ä¢ S ‚âà S ‚Ä¢ Z
  lemma-comm-Z-S = begin
    Z ‚Ä¢ S ‚âà‚ü® by-assoc auto ‚ü©
    (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ S ‚Ä¢ S ‚âà‚ü® _‚âà_.cong (lemma-comm-HHSHHS) _‚âà_.refl ‚ü©
    (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ S ‚Ä¢ S ‚âà‚ü® by-assoc auto ‚ü©
    S ‚Ä¢ Z ‚àé

  lemma-SH^2 : (S ‚Ä¢ H) ^ 2 ‚âà H ^ 3 ‚Ä¢ S ^ 2
  lemma-SH^2 = begin
    (S ‚Ä¢ H) ^ 2 ‚âà‚ü® by-assoc auto ‚ü©
    (S ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H) ‚Ä¢ Œµ ‚âà‚ü® _‚âà_.sym (_‚âà_.cong _‚âà_.refl (_‚âà_.axiom order-S)) ‚ü©
    (S ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H) ‚Ä¢ S ^ 3 ‚âà‚ü® by-assoc auto ‚ü©
    (S ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ Œµ ‚Ä¢ S ^ 2 ‚âà‚ü® cong refl (_‚âà_.sym (_‚âà_.cong (_‚âà_.axiom order-H) _‚âà_.refl)) ‚ü©
    (S ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ H ^ 4 ‚Ä¢ S ^ 2 ‚âà‚ü® by-assoc auto ‚ü©
    (S ‚Ä¢ H) ^ 3 ‚Ä¢ H ^ 3 ‚Ä¢ S ^ 2 ‚âà‚ü® cong (_‚âà_.axiom order-SH) refl ‚ü©
    Œµ ‚Ä¢ H ^ 3 ‚Ä¢ S ^ 2 ‚âà‚ü® left-unit ‚ü©
    H ^ 3 ‚Ä¢ S ^ 2 ‚àé

  lemma-comm-HHSSHHS : H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚âà S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H
  lemma-comm-HHSSHHS = begin
    H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚âà‚ü® by-assoc Eq.refl ‚ü©
    (H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚âà‚ü® cong refl (trans (sym left-unit) (sym (cong (axiom order-H) refl))) ‚ü©
    (H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ H ^ 4 ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚âà‚ü® by-assoc Eq.refl ‚ü©
    (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H  ‚Ä¢ H) ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚âà‚ü® cong refl (lemma-comm-HHSHHS) ‚ü©
    (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H  ‚Ä¢ H) ‚Ä¢ S ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚âà‚ü® by-assoc Eq.refl ‚ü©
    (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H  ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚âà‚ü® cong (lemma-comm-HHSHHS) refl ‚ü©
    (S ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H)) ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚âà‚ü® by-assoc Eq.refl ‚ü©
    (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ H ^ 4 ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚âà‚ü® cong refl (cong (axiom order-H) refl) ‚ü©
    (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ Œµ ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚âà‚ü® by-assoc Eq.refl ‚ü©
    S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚àé

  lemma-comm-HHSSHHSS : H ^ 2 ‚Ä¢ S ^ 2 ‚Ä¢ H ^ 2 ‚Ä¢ S ^ 2 ‚âà S ^ 2 ‚Ä¢ H ^ 2 ‚Ä¢ S ^ 2 ‚Ä¢ H ^ 2
  lemma-comm-HHSSHHSS = begin
    H ^ 2 ‚Ä¢ S ^ 2 ‚Ä¢ H ^ 2 ‚Ä¢ S ^ 2 ‚âà‚ü® by-assoc auto ‚ü©
    (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ S ‚âà‚ü® cong lemma-comm-HHSSHHS refl ‚ü©
    (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ S ‚âà‚ü® by-assoc auto ‚ü©
    S ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚âà‚ü® cong refl lemma-comm-HHSSHHS ‚ü©
    S ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚âà‚ü® by-assoc auto ‚ü©
    S ^ 2 ‚Ä¢ H ^ 2 ‚Ä¢ S ^ 2 ‚Ä¢ H ^ 2 ‚àé


  lemma-conj-HH-Z : HH ‚Ä¢ Z ‚âà (Z ‚Ä¢ Z) ‚Ä¢ HH
  lemma-conj-HH-Z = begin
    HH ‚Ä¢ HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚âà‚ü® by-assoc auto ‚ü©
    H ^ 4 ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚âà‚ü® _‚âà_.trans (_‚âà_.cong (_‚âà_.axiom order-H) _‚âà_.refl) _‚âà_.left-unit ‚ü©
    S ‚Ä¢ HH ‚Ä¢ SS ‚âà‚ü® by-assoc auto ‚ü©
    (Œµ ‚Ä¢ Œµ) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S) ‚Ä¢ Œµ ‚âà‚ü® cong (_‚âà_.sym (_‚âà_.cong (_‚âà_.axiom order-H) (_‚âà_.axiom order-S))) (_‚âà_.sym (_‚âà_.cong _‚âà_.refl (_‚âà_.axiom order-H))) ‚ü©
    (H ^ 4 ‚Ä¢ S ^ 3) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S) ‚Ä¢ H ^ 4 ‚âà‚ü® by-assoc auto ‚ü©
    (H ^ 4 ‚Ä¢ S ^ 3) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ HH ‚âà‚ü® cong refl (cong (_‚âà_.sym lemma-comm-HHSSHHS) refl) ‚ü©
    (H ^ 4 ‚Ä¢ S ^ 3) ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ HH ‚âà‚ü® by-assoc auto ‚ü©
    (H ^ 4 ‚Ä¢ S ‚Ä¢ S) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ S ‚Ä¢ HH ‚âà‚ü® cong refl (cong (_‚âà_.sym lemma-comm-HHSSHHS) refl) ‚ü©
    (H ^ 4 ‚Ä¢ S ‚Ä¢ S) ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ S ‚Ä¢ HH ‚âà‚ü® by-assoc auto ‚ü©
    HH ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ HH ‚âà‚ü® cong refl (cong lemma-comm-HHSSHHS refl) ‚ü©
    HH ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ HH ‚âà‚ü® by-assoc auto ‚ü©
    (Z ‚Ä¢ Z) ‚Ä¢ HH ‚àé


  lemma-def-XX : X ‚Ä¢ X ‚âà (H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H) ‚Ä¢ (H ‚Ä¢ S ‚Ä¢ H)
  lemma-def-XX = begin
    X ‚Ä¢ X ‚âà‚ü® by-assoc auto ‚ü©
    (H ‚Ä¢ S) ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚âà‚ü® cong refl (cong lemma-comm-HHSSHHS refl) ‚ü©
    (H ‚Ä¢ S) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚âà‚ü® by-assoc Eq.refl ‚ü©
    (H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S) ‚Ä¢ H ^ 4 ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚âà‚ü® general-powers 100 auto ‚ü©
    (H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H) ‚Ä¢ (H ‚Ä¢ S ‚Ä¢ H) ‚àé

  lemma-def-ZZ : Z ‚Ä¢ Z ‚âà (HH ‚Ä¢ S ‚Ä¢ S ‚Ä¢ HH) ‚Ä¢ S
  lemma-def-ZZ = begin
    (HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS) ‚Ä¢ (HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS) ‚âà‚ü® by-assoc auto ‚ü©
    (HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ S) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ SS ‚âà‚ü® cong refl (sym (cong (lemma-comm-HHSHHS) refl)) ‚ü©
    (HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ S) ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ SS ‚âà‚ü® by-assoc auto ‚ü©
    (HH ‚Ä¢ S ‚Ä¢ HH) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ S ^ 3 ‚âà‚ü® cong refl (cong (sym (lemma-comm-HHSHHS)) (axiom order-S)) ‚ü©
    (HH ‚Ä¢ S ‚Ä¢ HH) ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ Œµ ‚âà‚ü® general-powers 100 auto ‚ü©
    (HH ‚Ä¢ S ‚Ä¢ S ‚Ä¢ HH) ‚Ä¢ S ‚àé

  lemma-conj-HH-X : HH ‚Ä¢ X ‚âà (X ‚Ä¢ X) ‚Ä¢ HH
  lemma-conj-HH-X = begin
    HH ‚Ä¢ X ‚âà‚ü® general-powers 100 auto ‚ü©
    H ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ S ‚Ä¢ H ‚âà‚ü® cong refl (cong (lemma-comm-HHSHHS) refl) ‚ü©
    H ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ S ‚Ä¢ H ‚âà‚ü® by-assoc auto ‚ü©
    (H ‚Ä¢ S) ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ H ‚âà‚ü® cong refl (cong (lemma-comm-HHSHHS) refl) ‚ü©
    (H ‚Ä¢ S) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ H ‚âà‚ü® by-assoc auto ‚ü©
    ((H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H) ‚Ä¢ (H ‚Ä¢ S ‚Ä¢ H)) ‚Ä¢ HH ‚âà‚ü® cong (sym lemma-def-XX) refl ‚ü©
    (X ‚Ä¢ X) ‚Ä¢ HH ‚àé

  lemma-conj-HH-S : HH ‚Ä¢ S ‚âà (S ‚Ä¢ Z) ‚Ä¢ HH
  lemma-conj-HH-S = begin
    HH ‚Ä¢ S ‚âà‚ü® general-powers 100 auto ‚ü©
    (S ‚Ä¢ HH) ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚âà‚ü® cong refl lemma-comm-HHSSHHS ‚ü©
    (S ‚Ä¢ HH) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚âà‚ü® by-assoc auto ‚ü©
    (S ‚Ä¢ HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS) ‚Ä¢ HH ‚àé

  lemma-SHS : S ‚Ä¢ H ‚Ä¢ S ‚âà H ^ 3 ‚Ä¢ S ^ 2 ‚Ä¢ H ^ 3
  lemma-SHS = begin
    S ‚Ä¢ H ‚Ä¢ S ‚âà‚ü® general-powers 100 auto ‚ü©
    (S ‚Ä¢ H) ^ 3 ‚Ä¢ H ^ 3 ‚Ä¢ S ^ 2 ‚Ä¢ H ^ 3 ‚âà‚ü® cong (axiom order-SH) refl ‚ü©
    Œµ ‚Ä¢ H ^ 3 ‚Ä¢ S ^ 2 ‚Ä¢ H ^ 3 ‚âà‚ü® left-unit ‚ü©
    H ^ 3 ‚Ä¢ S ^ 2 ‚Ä¢ H ^ 3 ‚àé

  lemma-SHSH : S ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚âà H ^ 3 ‚Ä¢ S ^ 2
  lemma-SHSH = begin
    S ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚âà‚ü® general-powers 100 auto ‚ü©
    (S ‚Ä¢ H) ^ 3 ‚Ä¢ H ^ 3 ‚Ä¢ S ^ 2 ‚âà‚ü® trans (cong (axiom order-SH) refl) left-unit ‚ü©
    H ^ 3 ‚Ä¢ S ^ 2 ‚àé

  lemma-HSH : H ‚Ä¢ S ‚Ä¢ H ‚âà S ^ 2 ‚Ä¢ H ^ 3 ‚Ä¢ S ^ 2
  lemma-HSH = begin
    H ‚Ä¢ S ‚Ä¢ H ‚âà‚ü® general-powers 100 auto ‚ü©
    S ^ 2 ‚Ä¢ (S ‚Ä¢ H) ^ 3 ‚Ä¢ H ^ 3 ‚Ä¢ S ^ 2 ‚âà‚ü® cong refl (cong (axiom order-SH) refl) ‚ü©
    S ^ 2 ‚Ä¢ Œµ ‚Ä¢ H ^ 3 ‚Ä¢ S ^ 2 ‚âà‚ü® general-powers 100 auto ‚ü©
    S ^ 2 ‚Ä¢ H ^ 3 ‚Ä¢ S ^ 2 ‚àé

  lemma-HSHS : H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ S ‚âà S ^ 2 ‚Ä¢ H ^ 3
  lemma-HSHS = begin
    H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ S ‚âà‚ü® general-powers 100 auto ‚ü©
    S ^ 2 ‚Ä¢ (S ‚Ä¢ H) ^ 3 ‚Ä¢ H ^ 3 ‚âà‚ü® cong refl (cong (axiom order-SH) refl) ‚ü©
    S ^ 2 ‚Ä¢ Œµ ‚Ä¢ H ^ 3 ‚âà‚ü® general-powers 100 auto ‚ü©
    S ^ 2 ‚Ä¢ H ^ 3 ‚àé

  lemma-SHSHS : S ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ S ‚âà H ^ 3
  lemma-SHSHS = begin
    S ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ S ‚âà‚ü® general-powers 100 auto ‚ü©
    (S ‚Ä¢ H) ^ 3 ‚Ä¢ H ^ 3 ‚âà‚ü® trans (cong (axiom order-SH) refl) left-unit ‚ü©
    H ^ 3 ‚àé

  lemma-HSHSH : H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚âà S ^ 2
  lemma-HSHSH = begin
    H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚âà‚ü® general-powers 100 auto ‚ü©
    S ^ 2 ‚Ä¢ (S ‚Ä¢ H) ^ 3 ‚âà‚ü® cong refl (axiom order-SH) ‚ü©
    S ^ 2 ‚Ä¢ Œµ  ‚âà‚ü® general-powers 100 auto ‚ü©
    S ^ 2 ‚àé

  lemma-SSH^6 : (S ‚Ä¢ S ‚Ä¢ H) ^ 6 ‚âà Œµ
  lemma-SSH^6 = begin
    (S ‚Ä¢ S ‚Ä¢ H) ^ 6 ‚âà‚ü® by-assoc auto ‚ü©
    S ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ S ‚Ä¢ H ‚âà‚ü® cong refl (cong lemma-SHS (cong lemma-SHS (cong lemma-SHS (cong lemma-SHS (cong lemma-SHS refl))))) ‚ü©
    S ‚Ä¢ (H ^ 3 ‚Ä¢ S ^ 2 ‚Ä¢ H ^ 3) ‚Ä¢ (H ^ 3 ‚Ä¢ S ^ 2 ‚Ä¢ H ^ 3) ‚Ä¢ (H ^ 3 ‚Ä¢ S ^ 2 ‚Ä¢ H ^ 3) ‚Ä¢ (H ^ 3 ‚Ä¢ S ^ 2 ‚Ä¢ H ^ 3) ‚Ä¢ (H ^ 3 ‚Ä¢ S ^ 2 ‚Ä¢ H ^ 3) ‚Ä¢ S ‚Ä¢ H ‚âà‚ü® general-powers 100 auto ‚ü©
    S ‚Ä¢ H ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ^ 3 ‚Ä¢ S ‚Ä¢ H ‚âà‚ü® cong refl (cong refl (cong lemma-comm-HHSSHHS (cong (sym lemma-comm-HHSSHHS) refl))) ‚ü©
    S ‚Ä¢ H ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ^ 3 ‚Ä¢ S ‚Ä¢ H ‚âà‚ü® general-powers 1000 auto ‚ü©
    (S ‚Ä¢ H) ^ 3 ‚âà‚ü® axiom order-SH ‚ü©
    Œµ ‚àé

  lemma-SSH^3 : (S ‚Ä¢ S ‚Ä¢ H) ^ 3 ‚âà (H ^ 3 ‚Ä¢ S) ^ 3
  lemma-SSH^3 = begin
    (S ‚Ä¢ S ‚Ä¢ H) ^ 3 ‚âà‚ü® general-powers 100 auto ‚ü©
    (S ‚Ä¢ S ‚Ä¢ H) ^ 6 ‚Ä¢ (H ^ 3 ‚Ä¢ S) ^ 3 ‚âà‚ü® cong lemma-SSH^6 refl ‚ü©
    Œµ ‚Ä¢ (H ^ 3 ‚Ä¢ S) ^ 3 ‚âà‚ü® left-unit ‚ü©
    (H ^ 3 ‚Ä¢ S) ^ 3 ‚àé

  lemma-conj-XZXXZZ : X ‚Ä¢ Z ‚Ä¢ X ^ 2 ‚Ä¢ Z ^ 2 ‚âà Œµ
  lemma-conj-XZXXZZ = begin
    X ‚Ä¢ Z ‚Ä¢ X ^ 2 ‚Ä¢ Z ^ 2 ‚âà‚ü® cong refl (cong refl (cong lemma-def-XX lemma-def-ZZ)) ‚ü©
    (H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H) ‚Ä¢ (HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS) ‚Ä¢ ((H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H) ‚Ä¢ (H ‚Ä¢ S ‚Ä¢ H)) ‚Ä¢ (HH ‚Ä¢ S ‚Ä¢ S ‚Ä¢ HH) ‚Ä¢ S ‚âà‚ü® by-assoc auto ‚ü©
    (H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚Ä¢ HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H) ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚âà‚ü® cong refl lemma-comm-HHSSHHS ‚ü©
    (H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚Ä¢ HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚âà‚ü® by-assoc auto ‚ü©
    (H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚Ä¢ HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H) ‚Ä¢ (H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H) ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚âà‚ü® cong refl (cong lemma-HSHSH refl) ‚ü©
    (H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚Ä¢ HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H) ‚Ä¢ (S ‚Ä¢ S) ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚âà‚ü® general-powers 100 auto ‚ü©
    (H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚Ä¢ HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H) ‚Ä¢ (S ‚Ä¢ S ‚Ä¢ H) ^ 3 ‚Ä¢ H ‚âà‚ü® cong refl (cong lemma-SSH^3 refl) ‚ü©
    (H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚Ä¢ HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H) ‚Ä¢ (H ^ 3 ‚Ä¢ S) ^ 3 ‚Ä¢ H ‚âà‚ü® general-powers 100 auto ‚ü©
    (H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚Ä¢ HH ‚Ä¢ S ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ (H ^ 3 ‚Ä¢ S) ‚Ä¢ H ‚âà‚ü® by-assoc auto ‚ü©
    (H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚Ä¢ HH) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H) ‚Ä¢ H ^ 2 ‚Ä¢ S ‚Ä¢ H ‚âà‚ü® cong refl (cong lemma-SHSH refl) ‚ü©
    (H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚Ä¢ HH) ‚Ä¢ (H ^ 3 ‚Ä¢ S ^ 2) ‚Ä¢ H ^ 2 ‚Ä¢ S ‚Ä¢ H ‚âà‚ü® general-powers 100 auto ‚ü©
    H ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ S ^ 2 ‚Ä¢ H ^ 2 ‚Ä¢ S ‚Ä¢ H ‚âà‚ü® cong refl (sym (cong lemma-comm-HHSSHHS refl)) ‚ü©
    H ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ S ^ 2 ‚Ä¢ H ^ 2 ‚Ä¢ S ‚Ä¢ H ‚âà‚ü®  general-powers 100 auto ‚ü©
    Œµ ‚àé

  lemma-conj-X-S : X ‚Ä¢ S ‚âà (S ‚Ä¢ Z ‚Ä¢ Z) ‚Ä¢ X
  lemma-conj-X-S = begin
    X ‚Ä¢ S ‚âà‚ü® by-assoc auto ‚ü©
    H ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ S) ‚âà‚ü® general-powers 100 auto ‚ü©
    H ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ (H ^ 3 ‚Ä¢ S) ‚âà‚ü® cong refl (sym (cong lemma-comm-HHSSHHS refl)) ‚ü©
    H ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ (H ^ 3 ‚Ä¢ S) ‚âà‚ü® general-powers 100 auto ‚ü©
    (H ^ 3 ‚Ä¢ S ^ 2) ‚Ä¢ H ^ 2 ‚Ä¢ S ‚Ä¢ (H ^ 3 ‚Ä¢ S) ‚âà‚ü® (sym (cong lemma-SHSH refl)) ‚ü©
    (S ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H) ‚Ä¢ H ^ 2 ‚Ä¢ S ‚Ä¢ (H ^ 3 ‚Ä¢ S) ‚âà‚ü® general-powers 100 auto ‚ü©
    (S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ (H ^ 3 ‚Ä¢ S) ^ 3 ‚âà‚ü® cong refl (sym lemma-SSH^3) ‚ü©
    (S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ (S ‚Ä¢ S ‚Ä¢ H) ^ 3 ‚âà‚ü® by-assoc auto ‚ü©
    S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚âà‚ü® by-assoc auto ‚ü©
    Œµ ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ S ^ 2 ‚Ä¢ H ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® (sym (cong (axiom order-H) refl)) ‚ü©
    H ^ 4 ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ S ^ 2 ‚Ä¢ H ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® by-assoc auto ‚ü©
    (H ‚Ä¢ H) ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ S ‚Ä¢ H ‚Ä¢ S ^ 2 ‚Ä¢ H ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® cong refl (_‚âà_.cong (lemma-comm-HHSHHS) _‚âà_.refl) ‚ü©
    (H ‚Ä¢ H) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ S ‚Ä¢ H ‚Ä¢ S ^ 2 ‚Ä¢ H ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® by-assoc auto ‚ü©
    (H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ H ‚Ä¢ S ^ 2 ‚Ä¢ H ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® cong refl (_‚âà_.cong (lemma-comm-HHSHHS) _‚âà_.refl) ‚ü©
    (H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ H ‚Ä¢ S ^ 2 ‚Ä¢ H ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® by-assoc auto ‚ü©
    (H ‚Ä¢ H ‚Ä¢ SS ‚Ä¢ HH ‚Ä¢ S) ‚Ä¢ (H ^ 3 ‚Ä¢ S ^ 2) ‚Ä¢ H ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® general-powers 100 auto ‚ü©
    (H ‚Ä¢ H ‚Ä¢ SS ‚Ä¢ HH ‚Ä¢ S) ‚Ä¢ (H ^ 3 ‚Ä¢ S ^ 2) ‚Ä¢ H ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® cong refl (sym (cong lemma-SH^2 refl)) ‚ü©
    (H ‚Ä¢ H ‚Ä¢ SS ‚Ä¢ HH ‚Ä¢ S) ‚Ä¢ ((S ‚Ä¢ H) ^ 2) ‚Ä¢ H ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® by-assoc auto ‚ü©
    (H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ Œµ ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® cong refl (_‚âà_.sym (_‚âà_.cong (_‚âà_.axiom order-H) _‚âà_.refl)) ‚ü©
    (H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ H ^ 4 ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® by-assoc auto ‚ü©
    (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ Œµ ‚Ä¢ HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® cong refl (_‚âà_.sym (_‚âà_.cong (_‚âà_.axiom order-S) _‚âà_.refl)) ‚ü©
    (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ S ^ 3 ‚Ä¢ HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® by-assoc auto ‚ü©
    (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ SS ‚Ä¢ HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® (_‚âà_.cong (lemma-comm-HHSHHS) _‚âà_.refl) ‚ü©
    (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ SS ‚Ä¢ HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® by-assoc auto ‚ü©
    S ‚Ä¢ HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ HH ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚Ä¢ S ‚Ä¢ HH ‚Ä¢ SS ‚Ä¢ H ‚âà‚ü® by-assoc auto ‚ü©
    (S ‚Ä¢ Z ‚Ä¢ Z) ‚Ä¢ X ‚àé

  lemma-conj-X-Z : X ‚Ä¢ Z ‚âà (Z) ‚Ä¢ X
  lemma-conj-X-Z = begin
    X ‚Ä¢ Z ‚âà‚ü® by-assoc auto ‚ü©
    X ‚Ä¢ Z ‚Ä¢ Œµ ‚âà‚ü® cong refl (sym (cong refl lemma-order-X)) ‚ü©
    X ‚Ä¢ Z ‚Ä¢ X ^ 2 ‚Ä¢ X ‚âà‚ü® by-assoc auto ‚ü©
    (X ‚Ä¢ Z ‚Ä¢ X ^ 2) ‚Ä¢ Œµ ‚Ä¢ X ‚âà‚ü® cong refl (cong (sym lemma-order-Z) refl) ‚ü©
    (X ‚Ä¢ Z ‚Ä¢ X ^ 2) ‚Ä¢ (Z ^ 2 ‚Ä¢ Z) ‚Ä¢ X ‚âà‚ü® by-assoc auto ‚ü©
    ((X ‚Ä¢ Z ‚Ä¢ X ^ 2 ‚Ä¢ Z ^ 2) ‚Ä¢ Z) ‚Ä¢ X ‚âà‚ü® cong (cong lemma-conj-XZXXZZ refl) refl ‚ü©
    (Œµ ‚Ä¢ Z) ‚Ä¢ X ‚âà‚ü® trans assoc left-unit ‚ü©
    (Z) ‚Ä¢ X ‚àé

  lemma-X^3 : X ^ 3 ‚âà Œµ
  lemma-X^3 = begin
    X ^ 3 ‚âà‚ü® sym assoc ‚ü©
    X ^ 2 ‚Ä¢ X ‚âà‚ü® lemma-order-X ‚ü©
    Œµ ‚àé

  lemma-HX : H ‚Ä¢ X ‚âà Z ‚Ä¢ H
  lemma-HX = begin
    H ‚Ä¢ X ‚âà‚ü® by-assoc auto ‚ü©
    Z ‚Ä¢ H ‚àé

  lemma-HSSH : (H ‚Ä¢ S ‚Ä¢ S) ‚Ä¢ H ‚âà (S ‚Ä¢ Z ‚Ä¢ X ‚Ä¢ X) ‚Ä¢ H ‚Ä¢ S
  lemma-HSSH = begin
    (H ‚Ä¢ S ‚Ä¢ S) ‚Ä¢ H ‚âà‚ü® general-powers 100 auto ‚ü©
    (H) ‚Ä¢ (S ^ 2) ‚Ä¢ H ‚âà‚ü® cong refl (sym (cong lemma-HSHSH refl)) ‚ü©
    (H) ‚Ä¢ (H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H) ‚Ä¢ H ‚âà‚ü® general-powers 100 auto ‚ü©
    (S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚âà‚ü® cong refl (cong lemma-comm-HHSSHHS refl ) ‚ü©
    (S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚âà‚ü® general-powers 100 auto ‚ü©
    (S) ‚Ä¢ (H ‚Ä¢ X) ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚âà‚ü® cong refl (cong lemma-HX refl) ‚ü©
    (S) ‚Ä¢ (Z ‚Ä¢ H) ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚âà‚ü® general-powers 100 auto ‚ü©
    (S ‚Ä¢ Z ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S) ‚Ä¢ (S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H) ‚âà‚ü® cong refl (sym (lemma-comm-HHSHHS)) ‚ü©
    (S ‚Ä¢ Z ‚Ä¢ H ‚Ä¢ S ‚Ä¢ S) ‚Ä¢ (H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S) ‚âà‚ü® general-powers 100 auto ‚ü©
    (S ‚Ä¢ Z) ‚Ä¢ ((H ‚Ä¢ S ‚Ä¢ S ‚Ä¢ H) ‚Ä¢ (H ‚Ä¢ S ‚Ä¢ H)) ‚Ä¢ H ‚Ä¢ S ‚âà‚ü® cong refl (cong (sym lemma-def-XX) refl) ‚ü©
    (S ‚Ä¢ Z) ‚Ä¢ (X ‚Ä¢ X) ‚Ä¢ H ‚Ä¢ S ‚âà‚ü® by-assoc auto ‚ü©
    (S ‚Ä¢ Z ‚Ä¢ X ‚Ä¢ X) ‚Ä¢ H ‚Ä¢ S ‚àé


module PhaseX where

  Gen = Cyclic.X ‚äé Cyclic.X

  infix 4 _===_
  _===_ : WRel Gen
  _===_ = (Cyclic.pres 3 ‚∏≤ Cyclic.pres 3 ‚∏≤ Œì‚Çì)

  pattern œâ-gen = inj‚ÇÅ tt
  pattern X-gen = inj‚ÇÇ tt

  pattern order-œâ = left Cyclic.order
  pattern order-X = right Cyclic.order
  pattern comm-X-œâ = mid (comm tt tt)

  œâ : Word Gen
  œâ = [ œâ-gen ‚Üë]

  X : Word Gen
  X = [ X-gen ‚Üë]

  nfp' : NFProperty' _===_
  nfp' = DP.NFP'.nfp' (Cyclic.pres 3) (Cyclic.pres 3) (Cyclic.nfp' 3) (Cyclic.nfp' 3)
  
module Z where

  Gen = Cyclic.X

  infix 4 _===_
  _===_ : WRel Gen
  _===_ = Cyclic.pres 3

  pattern Z-gen = tt
  pattern order-Z = Cyclic.order

  Z : Word Gen
  Z = [ Z-gen ‚Üë]

  nfp' : NFProperty' _===_
  nfp' = Cyclic.nfp' 3

module PhaseXZ where

  Gen = PhaseX.Gen ‚äé Z.Gen
  
  pattern œâ-gen = inj‚ÇÅ PhaseX.œâ-gen
  pattern X-gen = inj‚ÇÅ PhaseX.X-gen
  pattern Z-gen = inj‚ÇÇ tt
  
  œâ : Word Gen
  œâ = [ œâ-gen ‚Üë]
  Z : Word Gen
  Z = [ Z-gen ‚Üë]
  X : Word Gen
  X = [ X-gen ‚Üë]

  conj : Z.Gen -> PhaseX.Gen -> Word PhaseX.Gen
  conj Z.Z-gen PhaseX.X-gen = PhaseX.œâ ‚Ä¢ PhaseX.X
  conj Z.Z-gen PhaseX.œâ-gen = PhaseX.œâ

  pattern order-œâ = left PhaseX.order-œâ
  pattern order-X = left PhaseX.order-X
  pattern comm-X-œâ = left PhaseX.comm-X-œâ
  pattern order-Z = right Z.order-Z
  pattern conj-Z-X = mid (comm PhaseX.X-gen tt)
  pattern comm-Z-œâ = mid (comm PhaseX.œâ-gen tt)

  infix 4 _===_
  _===_ : WRel Gen
  _===_ = (PhaseX._===_ ‚∏≤ Z._===_ ‚∏≤ Œì‚±º' conj)
  
  open PB Z._===_ renaming (_===_ to _===‚ÇÇ_ ; _‚âà_ to _‚âà‚ÇÇ_) using ()
  open PP Z._===_ renaming (‚Ä¢-Œµ-monoid to m‚ÇÇ ; word-setoid to ws‚ÇÇ) using ()
  
  open PB PhaseX._===_ renaming (_===_ to _===‚ÇÅ_ ; _‚âà_ to _‚âà‚ÇÅ_) using ()
  open PP PhaseX._===_ renaming (‚Ä¢-Œµ-monoid to m‚ÇÅ ; word-setoid to ws‚ÇÅ ; by-assoc-and to by-assoc-and‚ÇÅ ; by-assoc to by-assoc‚ÇÅ) using ()

  open PB hiding (_===_)
  
  module SDP2A = SDP2 PhaseX._===_ Z._===_ conj

  pattern auto = Eq.refl
  open NFProperty' (PhaseX.nfp') renaming (by-equal-nf to by-equal-nf‚ÇÅ)

  hyph : ‚àÄ {c d} n -> c ===‚ÇÇ d -> (conj  ∞') c n ‚âà‚ÇÅ (conj  ∞') d n
  hyph {c} {d} [ PhaseX.œâ-gen ‚Üë] Z.order-Z = refl
  hyph {c} {d} [ PhaseX.X-gen ‚Üë] Z.order-Z = by-equal-nf‚ÇÅ auto
  hyph {c} {d} Œµ Z.order-Z = refl
  hyph {c} {d} (n ‚Ä¢ n‚ÇÅ) eq@Z.order-Z = cong (hyph n eq) (hyph n‚ÇÅ eq)

  hypn : ‚àÄ c {w v} -> w ===‚ÇÅ v -> (conj ‚Åø') c w ‚âà‚ÇÅ (conj ‚Åø') c v
  hypn c {w} {v} (left Cyclic.order) = by-equal-nf‚ÇÅ auto
  hypn c {w} {v} (right Cyclic.order) = by-equal-nf‚ÇÅ auto
  hypn c {w} {v} (mid (comm tt tt)) = by-equal-nf‚ÇÅ auto
  
  nfp' : NFProperty' _===_
  nfp' = SDP2A.NFP'.nfp' hyph hypn PhaseX.nfp' Z.nfp'


module S where

  Gen = Cyclic.X

  infix 4 _===_
  _===_ : WRel Gen
  _===_ = Cyclic.pres 3

  pattern S-gen = tt
  pattern order-S = Cyclic.order

  S : Word Gen
  S = [ S-gen ‚Üë]

  nfp' : NFProperty' _===_
  nfp' = Cyclic.nfp' 3


module HH where

  Gen = Cyclic.X

  infix 4 _===_
  _===_ : WRel Gen
  _===_ = Cyclic.pres 2

  pattern HH-gen = tt
  pattern order-HH = Cyclic.order

  HH : Word Gen
  HH = [ HH-gen ‚Üë]

  nfp' : NFProperty' _===_
  nfp' = Cyclic.nfp' 2


module SHH where

  Gen = S.Gen ‚äé HH.Gen
  
  pattern S-gen = inj‚ÇÅ S.S-gen
  pattern HH-gen = inj‚ÇÇ tt

  pattern order-S = left S.order-S
  pattern order-HH = right HH.order-HH
  
  S : Word Gen
  S = [ S-gen ‚Üë]

  HH : Word Gen
  HH = [ HH-gen ‚Üë]

  conj : HH.Gen -> S.Gen -> Word S.Gen
  conj HH.HH-gen S.S-gen = S.S -- HHS = SZHH

  pattern conj-HH-S = mid (comm S.S-gen HH.HH-gen)

  infix 4 _===_
  _===_ : WRel Gen
  _===_ = (S._===_ ‚∏≤ HH._===_ ‚∏≤ Œì‚±º' conj)
  

  open PB HH._===_ renaming (_===_ to _===‚ÇÇ_ ; _‚âà_ to _‚âà‚ÇÇ_) using ()
  open PP HH._===_ renaming (‚Ä¢-Œµ-monoid to m‚ÇÇ ; word-setoid to ws‚ÇÇ) using ()
  
  open PB S._===_ renaming (_===_ to _===‚ÇÅ_ ; _‚âà_ to _‚âà‚ÇÅ_) using ()
  open PP S._===_ renaming (‚Ä¢-Œµ-monoid to m‚ÇÅ ; word-setoid to ws‚ÇÅ ; by-assoc-and to by-assoc-and‚ÇÅ ; by-assoc to by-assoc‚ÇÅ) using ()

  open PB hiding (_===_)
  
  pattern auto = Eq.refl
  open NFProperty' (S.nfp') renaming (by-equal-nf to by-equal-nf‚ÇÅ)

  hyph : ‚àÄ {c d} n -> c ===‚ÇÇ d -> (conj  ∞') c n ‚âà‚ÇÅ (conj  ∞') d n
  hyph {c} {d} [ S.S-gen ‚Üë] HH.order-HH = by-equal-nf‚ÇÅ auto
  hyph {c} {d} Œµ Cyclic.order = by-equal-nf‚ÇÅ auto
  hyph {c} {d} (n ‚Ä¢ n‚ÇÅ) eq@Cyclic.order = cong (hyph n eq) (hyph n‚ÇÅ eq)

  hypn : ‚àÄ c {w v} -> w ===‚ÇÅ v -> (conj ‚Åø') c w ‚âà‚ÇÅ (conj ‚Åø') c v
  hypn HH.HH-gen {w} {v} S.order-S = by-equal-nf‚ÇÅ auto

  nfp' : NFProperty' _===_
  nfp' = SDP2.NFP'.nfp' S._===_ HH._===_ conj hyph hypn S.nfp' HH.nfp'


module Symplectic-NFP' where

  open Symplectic
  open Symplectic-Lemmas
  
  f : SHH.Gen -> Word Gen
  f SHH.HH-gen = HH
  f SHH.S-gen = S

  
  open PB (SHH._===_) renaming (Alphabet to M ; _===_ to _===‚ÇÄ_ ; _‚âà_ to _‚âà‚ÇÄ_) using ()
  open NFProperty' SHH.nfp' using (by-equal-nf)
  
  open PB _===_ renaming (Alphabet to MB) using (_‚âà_)
  open SHH renaming (S to S‚Çò ; HH to HH‚Çò) using ()

  open PB hiding (_===_ ; _‚âà_)
  
  data C : Set where
    cHSS : C
    cHS : C
    cH : C

  CT = C ‚äé ‚ä§

  pattern ‚Ä¢Œµ = inj‚ÇÇ tt
  pattern ‚Ä¢H = inj‚ÇÅ cH
  pattern ‚Ä¢HS = inj‚ÇÅ cHS
  pattern ‚Ä¢HSS = inj‚ÇÅ cHSS

  h : CT -> MB -> Word M √ó CT

  h ‚Ä¢Œµ S-gen = S‚Çò , ‚Ä¢Œµ
  h ‚Ä¢H S-gen = Œµ , ‚Ä¢HS
  h ‚Ä¢HS S-gen = Œµ , ‚Ä¢HSS
  h ‚Ä¢HSS S-gen = Œµ , ‚Ä¢H
  h ‚Ä¢Œµ H-gen = Œµ , ‚Ä¢H
  h ‚Ä¢H H-gen = HH‚Çò , ‚Ä¢Œµ
  h ‚Ä¢HS H-gen = S‚Çò ‚Ä¢ S‚Çò ‚Ä¢ HH‚Çò , ‚Ä¢HSS
  h ‚Ä¢HSS H-gen = S‚Çò , ‚Ä¢HS

  infix 4 _~_
  _~_ = Pointwise _‚âà‚ÇÄ_ (_‚â°_ {A = CT})

  h=‚Åª¬πf-gen : ‚àÄ x -> ([ x ‚Üë] , ‚Ä¢Œµ) ~ ((h **) ‚Ä¢Œµ (f x)) 
  h=‚Åª¬πf-gen SHH.S-gen = refl , auto
  h=‚Åª¬πf-gen SHH.HH-gen = sym left-unit , auto

  h-wd-ax : ‚àÄ c {u t} -> u === t -> (h **) c u ~ (h **) c t
  h-wd-ax ‚Ä¢Œµ order-S = by-equal-nf Eq.refl , Eq.refl
  h-wd-ax ‚Ä¢H order-S = by-equal-nf Eq.refl , Eq.refl
  h-wd-ax ‚Ä¢HS order-S = by-equal-nf Eq.refl , Eq.refl
  h-wd-ax ‚Ä¢HSS order-S = by-equal-nf Eq.refl , Eq.refl
  h-wd-ax ‚Ä¢Œµ order-H = by-equal-nf Eq.refl , Eq.refl
  h-wd-ax ‚Ä¢H order-H = by-equal-nf Eq.refl , Eq.refl
  h-wd-ax ‚Ä¢HS order-H = by-equal-nf Eq.refl , Eq.refl
  h-wd-ax ‚Ä¢HSS order-H = by-equal-nf Eq.refl , Eq.refl
  h-wd-ax ‚Ä¢Œµ order-SH = by-equal-nf Eq.refl , Eq.refl
  h-wd-ax ‚Ä¢H order-SH = by-equal-nf Eq.refl , Eq.refl
  h-wd-ax ‚Ä¢HS order-SH = by-equal-nf Eq.refl , Eq.refl
  h-wd-ax ‚Ä¢HSS order-SH = by-equal-nf Eq.refl , Eq.refl
  h-wd-ax ‚Ä¢Œµ comm-HHS = by-equal-nf Eq.refl , Eq.refl
  h-wd-ax ‚Ä¢H comm-HHS = by-equal-nf Eq.refl , Eq.refl
  h-wd-ax ‚Ä¢HS comm-HHS = by-equal-nf Eq.refl , Eq.refl
  h-wd-ax ‚Ä¢HSS comm-HHS = by-equal-nf Eq.refl , Eq.refl

  open PP _===_
  open SR word-setoid

{-
  f-wd-ax : ‚àÄ {w v} -> w ===‚ÇÄ v -> (f *) w ‚âà (f *) v
  f-wd-ax SHH.order-S = _‚âà_.trans _‚âà_.assoc (_‚âà_.axiom order-S)
  f-wd-ax SHH.order-HH = _‚âà_.trans _‚âà_.assoc (_‚âà_.axiom order-H)
  f-wd-ax SHH.conj-HH-S = _‚âà_.trans _‚âà_.assoc (_‚âà_.axiom comm-HHS)

  by-sub-nf : ‚àÄ {w v} -> w ‚âà‚ÇÄ v -> (f *) w ‚âà (f *) v
  by-sub-nf {w} {v} eq = RS.Star-Congruence.lemma-f*-cong SHH._===_ _===_ f f-wd-ax eq 

  [_]‚Çí : C -> Word MB
  [ cHSS ]‚Çí = H ‚Ä¢ S ‚Ä¢ S
  [ cHS ]‚Çí = H ‚Ä¢ S
  [ cH ]‚Çí = H

  [_] : C ‚äé ‚ä§ -> Word MB
  [_] = [_,_] [_]‚Çí (Œª v ‚Üí Œµ)

  open PP.NFProperty' SHH.nfp' renaming (by-equal-nf to by-equal-nf‚Çò)
  open Symplectic-Powers
  open CommData

  lemma-SSHH : S ^ 2 ‚Ä¢ H ^ 2 ‚âà H ^ 2 ‚Ä¢ S ^ 2
  lemma-SSHH = begin
    S ^ 2 ‚Ä¢ H ^ 2 ‚âà‚ü® _‚âà_.assoc ‚ü©
    S ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚âà‚ü® _‚âà_.cong _‚âà_.refl (_‚âà_.sym (_‚âà_.axiom comm-HHS)) ‚ü©
    S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚âà‚ü® _‚âà_.sym (_‚âà_.trans _‚âà_.assoc (_‚âà_.cong _‚âà_.refl _‚âà_.assoc)) ‚ü©
    (S ‚Ä¢ H ‚Ä¢ H) ‚Ä¢ S ‚âà‚ü® _‚âà_.sym (_‚âà_.cong (_‚âà_.axiom comm-HHS) _‚âà_.refl) ‚ü©
    (H ‚Ä¢ H ‚Ä¢ S) ‚Ä¢ S ‚âà‚ü® _‚âà_.trans (_‚âà_.cong (_‚âà_.sym _‚âà_.assoc) _‚âà_.refl) _‚âà_.assoc ‚ü©
    H ^ 2 ‚Ä¢ S ^ 2 ‚àé
    
  h-hyp : ‚àÄ c b -> [ c ] ‚Ä¢ [ b ‚Üë] ‚âà (f *) (h c b .proj‚ÇÅ) ‚Ä¢ [ h c b .proj‚ÇÇ ]
  h-hyp ‚Ä¢HSS H-gen = begin
    (H ‚Ä¢ S ‚Ä¢ S) ‚Ä¢ H ‚âà‚ü® general-powers 100 auto ‚ü©
    H ‚Ä¢ (S ^ 2 ‚Ä¢ H ^ 2) ‚Ä¢ H ^ 3 ‚âà‚ü® cong refl (cong lemma-SSHH refl) ‚ü©
    H ‚Ä¢ (H ^ 2 ‚Ä¢ S ^ 2) ‚Ä¢ H ^ 3 ‚âà‚ü® by-assoc auto ‚ü©
    H ^ 3 ‚Ä¢ S ^ 2 ‚Ä¢ H ^ 3 ‚âà‚ü® _‚âà_.sym lemma-SHS ‚ü©
    S ‚Ä¢ H ‚Ä¢ S ‚àé
  h-hyp ‚Ä¢HS H-gen = by-assoc-and lemma-HSH auto auto
  h-hyp ‚Ä¢H H-gen = general-powers 100 auto
  h-hyp ‚Ä¢HSS S-gen = general-powers 100 auto
  h-hyp ‚Ä¢HS S-gen = general-powers 100 auto
  h-hyp ‚Ä¢H S-gen = general-powers 100 auto
  h-hyp ‚Ä¢Œµ H-gen = general-powers 100 auto
  h-hyp ‚Ä¢Œµ S-gen = general-powers 100 auto
  
  module ca = CA.Data (SHH._===_) _===_ CT (inj‚ÇÇ tt) f h [_]
  module aat = ca.Assumptions-And-Theorems h=‚Åª¬πf-gen h-wd-ax f-wd-ax _‚âà_.refl h-hyp

  nfp' = aat.nfp' SHH.nfp'

module XZ where

  Gen = Cyclic.X ‚äé Cyclic.X

  infix 4 _===_
  _===_ : WRel Gen
  _===_ = (Cyclic.pres 3 ‚∏≤ Cyclic.pres 3 ‚∏≤ Œì‚Çì)

  pattern X-gen = inj‚ÇÅ tt
  pattern Z-gen = inj‚ÇÇ tt

  pattern order-X = left Cyclic.order
  pattern order-Z = right Cyclic.order
  pattern comm-Z-X = mid (comm tt tt)

  X : Word Gen
  X = [ X-gen ‚Üë]

  Z : Word Gen
  Z = [ Z-gen ‚Üë]

  nfp' : NFProperty' _===_
  nfp' = DP.NFP'.nfp' (Cyclic.pres 3) (Cyclic.pres 3) (Cyclic.nfp' 3) (Cyclic.nfp' 3)


module Semidirect where

  open import Presentation.Construct.Base

  Gen = XZ.Gen ‚äé Symplectic.Gen

  pattern X-gen = inj‚ÇÅ XZ.X-gen
  pattern Z-gen = inj‚ÇÅ XZ.Z-gen
  pattern H-gen = inj‚ÇÇ Symplectic.H-gen
  pattern S-gen = inj‚ÇÇ Symplectic.S-gen

  S : Word Gen
  S = [ S-gen ‚Üë]
  Z : Word Gen
  Z = [ Z-gen ‚Üë]
  X : Word Gen
  X = [ X-gen ‚Üë]
  H : Word Gen
  H = [ H-gen ‚Üë]

  conj : Symplectic.Gen -> XZ.Gen -> Word XZ.Gen
  conj Symplectic.H-gen XZ.X-gen = XZ.Z
  conj Symplectic.H-gen XZ.Z-gen = XZ.X ^ 2
  conj Symplectic.S-gen XZ.X-gen = XZ.X ‚Ä¢ XZ.Z
  conj s w = [ w ‚Üë]

  pattern order-X = left XZ.order-X
  pattern order-Z = left XZ.order-Z
  pattern comm-Z-X = left XZ.comm-Z-X
  pattern order-H = right Symplectic.order-H
  pattern order-S = right Symplectic.order-S
  pattern order-SH = right Symplectic.order-SH
  pattern comm-HHS = right Symplectic.comm-HHS
  pattern conj-H-X = mid (comm XZ.X-gen Symplectic.H-gen)
  pattern conj-H-Z = mid (comm XZ.Z-gen Symplectic.H-gen)
  pattern conj-S-X = mid (comm XZ.X-gen Symplectic.S-gen)
  pattern conj-S-Z = mid (comm XZ.Z-gen Symplectic.S-gen)

  infix 4 _===_
  _===_ = (XZ._===_ ‚∏≤ Symplectic._===_ ‚∏≤ Œì‚±º' conj)

  open PB Symplectic._===_ renaming (_===_ to _===‚ÇÇ_ ; _‚âà_ to _‚âà‚ÇÇ_) using ()
  open PP Symplectic._===_ renaming (‚Ä¢-Œµ-monoid to m‚ÇÇ ; word-setoid to ws‚ÇÇ) using ()
  
  open PB XZ._===_ renaming (_===_ to _===‚ÇÅ_ ; _‚âà_ to _‚âà‚ÇÅ_) using ()
  open PP XZ._===_ renaming (‚Ä¢-Œµ-monoid to m‚ÇÅ ; word-setoid to ws‚ÇÅ ; by-assoc-and to by-assoc-and‚ÇÅ ; by-assoc to by-assoc‚ÇÅ) using ()

  open PB hiding (_===_)
  
  open NFProperty' (XZ.nfp') renaming (by-equal-nf to by-equal-nf‚ÇÅ)

  hyph : ‚àÄ {c d} n -> c ===‚ÇÇ d -> (conj  ∞') c n ‚âà‚ÇÅ (conj  ∞') d n
  hyph {c} {d} [ XZ.X-gen ‚Üë] Symplectic.order-H = by-equal-nf‚ÇÅ auto
  hyph {c} {d} [ XZ.X-gen ‚Üë] Symplectic.order-S = by-equal-nf‚ÇÅ auto
  hyph {c} {d} [ XZ.X-gen ‚Üë] Symplectic.order-SH = by-equal-nf‚ÇÅ auto
  hyph {c} {d} [ XZ.X-gen ‚Üë] Symplectic.comm-HHS = by-equal-nf‚ÇÅ auto
  hyph {c} {d} [ XZ.Z-gen ‚Üë] Symplectic.order-H = by-equal-nf‚ÇÅ auto
  hyph {c} {d} [ XZ.Z-gen ‚Üë] Symplectic.order-S = by-equal-nf‚ÇÅ auto
  hyph {c} {d} [ XZ.Z-gen ‚Üë] Symplectic.order-SH = by-equal-nf‚ÇÅ auto
  hyph {c} {d} [ XZ.Z-gen ‚Üë] Symplectic.comm-HHS = by-equal-nf‚ÇÅ auto
  hyph {c} {d} Œµ Symplectic.order-H = by-equal-nf‚ÇÅ auto
  hyph {c} {d} Œµ Symplectic.order-S = by-equal-nf‚ÇÅ auto
  hyph {c} {d} Œµ Symplectic.order-SH = by-equal-nf‚ÇÅ auto
  hyph {c} {d} Œµ Symplectic.comm-HHS = by-equal-nf‚ÇÅ auto
  hyph {c} {d} (n ‚Ä¢ n‚ÇÅ) eq@Symplectic.order-H = cong (hyph n eq) (hyph n‚ÇÅ eq)
  hyph {c} {d} (n ‚Ä¢ n‚ÇÅ) eq@Symplectic.order-S = cong (hyph n eq) (hyph n‚ÇÅ eq)
  hyph {c} {d} (n ‚Ä¢ n‚ÇÅ) eq@Symplectic.order-SH = cong (hyph n eq) (hyph n‚ÇÅ eq)
  hyph {c} {d} (n ‚Ä¢ n‚ÇÅ) eq@Symplectic.comm-HHS = cong (hyph n eq) (hyph n‚ÇÅ eq)

  hypn : ‚àÄ c {w v} -> w ===‚ÇÅ v -> (conj ‚Åø') c w ‚âà‚ÇÅ (conj ‚Åø') c v
  hypn Symplectic.H-gen XZ.order-X = by-equal-nf‚ÇÅ auto
  hypn Symplectic.H-gen XZ.order-Z = by-equal-nf‚ÇÅ auto
  hypn Symplectic.H-gen XZ.comm-Z-X = by-equal-nf‚ÇÅ auto
  hypn Symplectic.S-gen XZ.order-X = by-equal-nf‚ÇÅ auto
  hypn Symplectic.S-gen XZ.order-Z = by-equal-nf‚ÇÅ auto
  hypn Symplectic.S-gen XZ.comm-Z-X = by-equal-nf‚ÇÅ auto

  nfp' : NFProperty' _===_
  nfp' = SDP2.NFP'.nfp' XZ._===_ Symplectic._===_ conj hyph hypn XZ.nfp' Symplectic-NFP'.nfp'

  open NFProperty' nfp'

  grouplike : Grouplike _===_
  grouplike H-gen = H ^ 3 , by-equal-nf auto
  grouplike S-gen = S ^ 2 , by-equal-nf auto
  grouplike X-gen = X ^ 2 , by-equal-nf auto
  grouplike Z-gen = Z ^ 2 , by-equal-nf auto


{-
module Iso where

  open import One.Clifford-Mod-Scalar
  open Clifford-Lemmas

  open import Presentation.Morphism Semidirect._===_ Clifford._===_
  open GroupMorphs Semidirect.grouplike Clifford-GroupLike.grouplike

  f : Semidirect.Gen -> Word Clifford.Gen
  f Semidirect.X-gen = Clifford.X
  f Semidirect.Z-gen = Clifford.Z
  f Semidirect.H-gen = Clifford.H
  f Semidirect.S-gen = Clifford.ùë† -- Clifford.Z ^ 2 ‚Ä¢ Clifford.S

  g : Clifford.Gen -> Word Semidirect.Gen
  g Clifford.H-gen = Semidirect.H
  g Clifford.S-gen = Semidirect.Z ‚Ä¢ Semidirect.S
  

  open PB Semidirect._===_ renaming (_===_ to _===‚ÇÅ_ ; _‚âà_ to _‚âà‚ÇÅ_) using ()
  open NFProperty' Semidirect.nfp' renaming (by-equal-nf to by-equal-nf‚ÇÅ) using ()
  
  open PB Clifford._===_ renaming (_===_ to _===‚ÇÇ_ ; _‚âà_ to _‚âà‚ÇÇ_) using ()
  open Clifford-Powers renaming (general-powers to general-powers‚ÇÇ)

  open PP Semidirect._===_ renaming (by-assoc-and to by-assoc-and‚ÇÅ)
  open PP Clifford._===_ renaming (by-assoc-and to by-assoc-and‚ÇÇ ; word-setoid to ws‚ÇÇ ; by-assoc to by-assoc‚ÇÇ)

  open PB hiding (_===_)
  open Clifford
  open PP.NFProperty' Clifford-NFP'.nfp' renaming (by-equal-nf to by-equal-nf‚ÇÇ)

    
  f-well-defined : ‚àÄ {w v} -> w ===‚ÇÅ v -> (f *) w ‚âà‚ÇÇ (f *) v
  f-well-defined Semidirect.order-X = _‚âà‚ÇÇ_.trans _‚âà‚ÇÇ_.assoc lemma-X^3
  f-well-defined Semidirect.order-Z = lemma-order-Z
  f-well-defined Semidirect.comm-Z-X = lemma-conj-X-Z
  f-well-defined Semidirect.order-H = by-equal-nf‚ÇÇ auto
  f-well-defined Semidirect.order-S = by-equal-nf‚ÇÇ auto
  f-well-defined Semidirect.order-SH = by-equal-nf‚ÇÇ auto
  f-well-defined Semidirect.comm-HHS = by-equal-nf‚ÇÇ auto
  f-well-defined Semidirect.conj-H-X = general-powers‚ÇÇ 100 auto
  f-well-defined Semidirect.conj-H-Z = by-equal-nf‚ÇÇ auto
  f-well-defined Semidirect.conj-S-X = by-equal-nf‚ÇÇ auto
  f-well-defined Semidirect.conj-S-Z = by-equal-nf‚ÇÇ auto


  g-well-defined : ‚àÄ {w v} -> w ===‚ÇÇ v -> (g *) w ‚âà‚ÇÅ (g *) v
  g-well-defined {w} {v} Clifford.order-S = by-equal-nf‚ÇÅ auto
  g-well-defined {w} {v} Clifford.order-H = by-equal-nf‚ÇÅ auto
  g-well-defined {w} {v} Clifford.order-SH = by-equal-nf‚ÇÅ auto
  g-well-defined comm-HHSHHS = by-equal-nf‚ÇÅ auto

  f-left-inv-gen : ‚àÄ x -> [ x ‚Üë] ‚âà‚ÇÇ (f *) (g x)
  f-left-inv-gen Clifford.H-gen = by-equal-nf‚ÇÇ auto
  f-left-inv-gen Clifford.S-gen = by-equal-nf‚ÇÇ auto

  g-left-inv-gen : ‚àÄ x -> [ x ‚Üë] ‚âà‚ÇÅ (g *) (f x)
  g-left-inv-gen Semidirect.S-gen = by-equal-nf‚ÇÅ auto
  g-left-inv-gen Semidirect.H-gen = by-equal-nf‚ÇÅ auto
  g-left-inv-gen Semidirect.X-gen = by-equal-nf‚ÇÅ auto
  g-left-inv-gen Semidirect.Z-gen = by-equal-nf‚ÇÅ auto


  open import Algebra.Bundles using (Group)
  open import Algebra.Morphism.Structures using (module GroupMorphisms)

  open import Presentation.Morphism
  open GroupMorphisms
  module G1 = Group-Lemmas Semidirect.Gen Semidirect._===_ Semidirect.grouplike
  module G2 = Group-Lemmas Clifford.Gen Clifford._===_ Clifford-GroupLike.grouplike

  Theorem-Semidirect-iso-Clifford : IsGroupIsomorphism (Group.rawGroup G1.‚Ä¢-Œµ-group) (Group.rawGroup G2.‚Ä¢-Œµ-group) (f *)
  Theorem-Semidirect-iso-Clifford = StarGroupIsomorphism.isGroupIsomorphism f g f-well-defined  f-left-inv-gen g-well-defined  g-left-inv-gen

  -- This theorem says 1 qutrit Clifford mod scalars is isomorphic to
  -- ‚Ñ§‚ÇÉ¬≤ ‚ãä Sp(2,3). The presentations are:
  
  -- Clifford:
  --   order-S : S ^ 3 === Œµ
  --   order-H : H ^ 4 === Œµ
  --   order-SH : (S ‚Ä¢ H) ^ 3 === Œµ
  --   comm-HHSHHS : H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S === S ‚Ä¢ H ‚Ä¢ H ‚Ä¢ S ‚Ä¢ H ‚Ä¢ H

  -- Semidirct product:
  --   ‚Ñ§‚ÇÉ¬≤:
  --     order-X 
  --     order-Z 
  --     comm-Z-X
      
  --   Sp(2,3): 
  --     order-S : S ^ 3 === Œµ
  --     order-H : H ^ 4 === Œµ
  --     order-SH : (S ‚Ä¢ H) ^ 3 === Œµ
  --     comm-HHS : H ‚Ä¢ H ‚Ä¢ S === S ‚Ä¢ H ‚Ä¢ H
      
  --   conjugation:
  --     conj-H-X 
  --     conj-H-Z 
  --     conj-S-X 
  --     conj-S-Z 

  -- NOTE: S in Sp(2,3) is ZZS in Clifford.
-}
-}
-}


