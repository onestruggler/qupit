{-# OPTIONS --safe #-}
open import Level using (0ℓ)

open import Relation.Binary using (Rel)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Binary.Morphism.Definitions using (Homomorphic₂)
open import Relation.Binary.PropositionalEquality using (_≡_ ; inspect ; setoid ; module ≡-Reasoning ; _≢_) renaming ([_] to [_]')
import Relation.Binary.Reasoning.Setoid as SR
import Relation.Binary.PropositionalEquality as Eq
open import Relation.Nullary.Decidable using (yes ; no)


open import Function using (_∘_ ; id)
open import Function.Definitions using (Injective)

open import Data.Product using (_×_ ; _,_ ; proj₁ ; proj₂ ; map₁ ; ∃)
open import Data.Product.Relation.Binary.Pointwise.NonDependent as PW using (≡×≡⇒≡ ; Pointwise ; ≡⇒≡×≡)
open import Data.Nat hiding (_^_ ; _+_ ; _*_ ; _%_ ; _/_)
open import Agda.Builtin.Nat using ()
import Data.Nat as Nat
open import Data.Fin hiding (_+_ ; _-_)
open import Data.Bool
open import Data.List hiding ([_])

open import Data.Maybe
open import Data.Sum using (_⊎_ ; inj₁ ; inj₂ ; [_,_])
open import Data.Unit using (⊤ ; tt)
open import Data.Empty using (⊥ ; ⊥-elim)

open import Word.Base as WB hiding (wfoldl ; _*)
open import Word.Properties
import Presentation.Base as PB
import Presentation.Properties as PP
open PP using (NFProperty ; NFProperty')
import Presentation.CosetNF as CA
import Presentation.Reidemeister-Schreier as RS
module RSF = RS.Star-Injective-Full.Reidemeister-Schreier-Full

open import Presentation.Construct.Base hiding (_*_)
import Presentation.Construct.Properties.SemiDirectProduct2 as SDP2
import Presentation.Construct.Properties.DirectProduct as DP
import Presentation.Groups.Cyclic as Cyclic


open import Data.Fin.Properties using (suc-injective ; toℕ-inject₁ ; toℕ-fromℕ)
import Data.Nat.Properties as NP
open import Presentation.GroupLike
open import Data.Nat.Primality
open import Data.Nat.Coprimality hiding (sym)
open import Data.Nat.GCD
open Bézout
open import Data.Empty
open import Algebra.Properties.Group

module One.SymplecticZp-Simplified (p-3 : ℕ) (p-prime : Prime (suc (suc (suc p-3)))) where

p-2 : ℕ
p-2 = suc p-3


pattern auto = Eq.refl
pattern ₀ = zero
pattern ₁ = suc ₀
pattern ₂ = suc ₁
pattern ₃ = suc ₂
pattern ₄ = suc ₃

pattern ₁₊ n = suc n
pattern ₂₊ n = suc (suc n)
pattern ₃₊ n = suc (₂₊ n)
pattern ₄₊ n = suc (₃₊ n)

open import Zp.ModularArithmetic
open PrimeModulus p-2 p-prime hiding (p ; 1ₚ ; 0ₚ≢1ₚ)

module Symplectic-Simplified
  (g : ℤ ₚ)
  (g-gen : ∀ ((x , p) : ℤ* ₚ) -> ∃ \ k -> x ≡ g ^′ k )
  where

  g-gen1 = g-gen (₁ , λ ())
  g-gen2 = g-gen (₂ , λ ())
  g≠0 : g ≢ ₀
  g≠0 eq0 with g-gen2
  g≠0 eq0 | (suc k , eq) rewrite eq0 | lemma-0^′k {p-2} k with eq
  g≠0 eq0 | (suc k , eq) | ()
  g≠0 eq0 | (0 , eq) with eq
  g≠0 eq0 | (0 , eq) | ()

  p : ℕ
  p = ₂₊ p-2

  lemma-g^′k≠0 : ∀ k -> g ^′ k ≢ 0ₚ
  lemma-g^′k≠0 ₀ = λ ()
  lemma-g^′k≠0 (₁₊ k) = gg .proj₂
    where
    gg = (g , g≠0) *' (g ^′ k , lemma-g^′k≠0 k)

  data Gen : Set where
    H-gen : Gen
    S-gen : Gen

  H : Word Gen
  H = [ H-gen ↑]

  H⁻¹ : Word Gen
  H⁻¹ = H ^ 3

  HH : Word Gen
  HH = H • H

  S : Word Gen
  S = [ S-gen ↑]

  S' : Word Gen
  S' = HH • S • HH

  SS : Word Gen
  SS = S • S

  X : Word Gen
  X = H • S • HH • SS • H

  Z : Word Gen
  Z = HH • S • HH • SS

  H^ : ℤ ₄ -> Word Gen
  H^ k = H ^ toℕ k

  S^ : ℤ ₚ -> Word Gen
  S^ k = S ^ toℕ k

  M : ℤ* ₚ -> Word Gen
  M x' = S^ x • H • S^ x⁻¹ • H • S^ x • H
    where
    x = x' .proj₁
    x⁻¹ = ((x' ⁻¹) .proj₁ )

  Mg : Word Gen
  Mg = M (g , g≠0)
    

  infix 4 _===_
  data _===_ : WRel Gen where
    order-S : S ^ p === ε
    order-H : H ^ 4 === ε
    order-SH : (S • H) ^ 3 === ε
    comm-HHS : H • H • S === S • H • H
    semi-MS : Mg • S === S^ (g * g) • Mg

  open PP _===_
  open PB _===_ hiding (_===_)
  grouplike : Grouplike _===_
  grouplike (H-gen) = H ^ 3 , by-assoc-and (axiom order-H) auto auto
  grouplike (S-gen) = S ^ p-1 , claim
    where
    open SR word-setoid
    claim : S ^ p-1 • S ≈ ε
    claim = begin
      S ^ p-1 • S ≈⟨ sym (lemma-^-+ S p-1 1) ⟩
      S ^ (p-1 Nat.+ 1) ≡⟨ Eq.cong (S ^_) (NP.+-comm p-1 1) ⟩
      (S ^ p) ≈⟨ axiom order-S ⟩
      ε ∎

module Iso
  (g : ℤ ₚ)
  (g-gen : ∀ ((x , p) : ℤ* ₚ) -> ∃ \ k -> x ≡ g ^′ k )
  where


  open import One.SymplecticZp
  module Sym  = Symplectic p-2 p-prime
  module Sim  = Symplectic-Simplified g g-gen
  open Sym renaming (grouplike to grouplike₁ ; Gen to Gen₁) using ()
  open Sim renaming (grouplike to grouplike₂ ; Gen to Gen₂) using ()

  p : ℕ
  p = ₂₊ p-2

  f : Sym.Gen -> Sim.Gen
  f Symplectic.H-gen = Sim.H-gen
  f Symplectic.S-gen = Sim.S-gen


  h : Sim.Gen -> Word Sym.Gen
  h (Sim.H-gen) = Sym.H
  h (Sim.S-gen) = Sym.S
  

  open PB Sym._===_ renaming (_===_ to _===₁_ ; _≈_ to _≈₁_) using ()
  open PB Sim._===_ renaming (_===_ to _===₂_ ; _≈_ to _≈₂_) using ()

  open import Presentation.Morphism _===₁_ _===₂_
  open GroupMorphs grouplike₁ grouplike₂

  open PP Sym._===_ renaming (by-assoc-and to by-assoc-and₁ ; word-setoid to ws₁)
  open PP Sim._===_ renaming (by-assoc-and to by-assoc-and₂ ; word-setoid to ws₂ ; by-assoc to by-assoc₂) using ()

  open PB hiding (_===_)
  open Sim hiding (p)

  f* = wmap f
  f' = [_↑] ∘ f
  f'* = f' WB.*
  
  lemma-f* : ∀ k -> f* (Sym.S ^ k) ≈₂ Sim.S ^ k
  lemma-f* ₀ = _≈₂_.refl
  lemma-f* ₁ = _≈₂_.refl
  lemma-f* (₂₊ k) = cong _≈₂_.refl (lemma-f* (₁₊ k))

  lemma-f'* : ∀ k -> f'* (Sym.S ^ k) ≈₂ Sim.S ^ k
  lemma-f'* ₀ = _≈₂_.refl
  lemma-f'* ₁ = _≈₂_.refl
  lemma-f'* (₂₊ k) = cong _≈₂_.refl (lemma-f'* (₁₊ k))

  lemma-f'*-H : ∀ k -> f'* (Sym.H ^ k) ≈₂ Sim.H ^ k
  lemma-f'*-H ₀ = _≈₂_.refl
  lemma-f'*-H ₁ = _≈₂_.refl
  lemma-f'*-H (₂₊ k) = cong _≈₂_.refl (lemma-f'*-H (₁₊ k))

  lemma-f'*-M : ∀ x -> f'* (Sym.M x) ≈₂ Sim.M x
  lemma-f'*-M x' = begin
    f'* (Sym.M x') ≈⟨ {!!} ⟩
    Sim.M x' ∎
    where
    open SR ws₂
    x = x' .proj₁
    x⁻¹ = ((x' ⁻¹) .proj₁ )

  aux-Mx=Mx' : ∀ y y' -> y .proj₁ ≡ y' .proj₁ -> M y ≡ M y'
  aux-Mx=Mx' y y' eq = begin
    M y ≡⟨ auto ⟩
    S^ x • H • S^ x⁻¹ • H • S^ x • H ≡⟨ {!!} ⟩
    S^ x' • H • S^ x'⁻¹ • H • S^ x' • H ≡⟨ auto ⟩
    M y' ∎
    where
    open ≡-Reasoning
    x = y .proj₁
    x⁻¹ = ((y ⁻¹) .proj₁ )
    x' = y' .proj₁
    x'⁻¹ = ((y' ⁻¹) .proj₁ )
    aux-eq : x⁻¹ ≡ x'⁻¹
    aux-eq  = begin
      x⁻¹ ≡⟨  Eq.sym  (*-identityʳ x⁻¹) ⟩
      x⁻¹ * ₁ ≡⟨ Eq.cong (x⁻¹ *_) (Eq.sym (lemma-⁻¹ʳ x' {{nztoℕ {y = x'} {neq0 = y' .proj₂} }})) ⟩
      x⁻¹ * (x' * x'⁻¹) ≡⟨ Eq.sym (*-assoc x⁻¹ x' x'⁻¹) ⟩
      (x⁻¹ * x') * x'⁻¹ ≡⟨ Eq.cong (\ xx -> (x⁻¹ * xx) * x'⁻¹) (Eq.sym eq) ⟩
      (x⁻¹ * x) * x'⁻¹ ≡⟨ {!lemma-⁻¹ʳ x' {{nztoℕ {y = x'} {neq0 = y' .proj₂} }}!} ⟩
      ₁ * x'⁻¹ ≡⟨ {!!} ⟩
      x'⁻¹ ∎
    
  lemma-f'*-Mg : ∀ x -> let (k , eq) = g-gen x in f'* (Sym.M x) ≈₂ Sim.Mg ^ k
  lemma-f'*-Mg x = let (k , eq) = g-gen x in begin
    f'* (Sym.M x) ≡⟨ Eq.cong f'* {!!} ⟩
    f'* (Sym.M (g ^′ k , lemma-g^′k≠0 k)) ≈⟨ {!!} ⟩
    Sim.Mg ^ k ∎
    where
    open SR ws₂


  f-well-defined : ∀ {w v} -> w ===₁ v -> f'* w ≈₂ f'* v
  f-well-defined Symplectic.order-S = begin
    f'* (Sym.S • Sym.S ^ ₁₊ p-2) ≡⟨ lemma-* ([ Sym.S-gen ↑] • Sym.S ^ ₁₊ p-2) ⟩
    (wmap f) (Sym.S • Sym.S ^ ₁₊ p-2) ≈⟨ lemma-f* (₂₊ p-2) ⟩
    Sim.S ^ p ≈⟨ _≈₂_.axiom order-S ⟩
    f'* ε ∎
    where
    open SR ws₂
  f-well-defined Symplectic.order-H = axiom order-H
  f-well-defined Symplectic.order-SH = _≈₂_.axiom order-SH
  f-well-defined Symplectic.comm-HHS = _≈₂_.axiom comm-HHS
  f-well-defined (Symplectic.M-mul x y) = begin
    f'* (Sym.M x • Sym.M y) ≈⟨ _≈₂_.refl ⟩
    f'* (Sym.M x) • f'* (Sym.M y) ≈⟨ cong (lemma-f'*-M x) (lemma-f'*-M y) ⟩
    (Sim.M x) • (Sim.M y) ≡⟨ auto ⟩
    (Sim.M x) • (Sim.M y) ≡⟨ {!!} ⟩
    (Sim.M (x *' y)) ≈⟨ sym (lemma-f'*-M (x *' y)) ⟩
    f'* (Sym.M (x *' y)) ∎
    where
    open SR ws₂
  f-well-defined (Symplectic.semi-MS (x , nz)) = {!!}
    where
    open SR ws₂

  h* = h WB.*

  lemma-h* : ∀ k -> h* (S ^ k) ≈₁ Sym.S ^ k
  lemma-h* ₀ = refl
  lemma-h* ₁ = refl
  lemma-h* (₂₊ k) = cong refl (lemma-h* (₁₊ k))

  lemma-h*-H : ∀ k -> h* (H ^ k) ≈₁ Sym.H ^ k
  lemma-h*-H ₀ = refl
  lemma-h*-H ₁ = refl
  lemma-h*-H (₂₊ k) = cong refl (lemma-h*-H (₁₊ k))

  lemma-h*'-H : ∀ k -> h* (H^ k) ≈₁ Sym.H ^ toℕ k
  lemma-h*'-H ₀ = refl
  lemma-h*'-H ₁ = refl
  lemma-h*'-H ₂ = refl
  lemma-h*'-H ₃ = refl


  lemma-h*-M : ∀ x -> h* (M x) ≈₁ Sym.M x
  lemma-h*-M x' = begin
    h* (M x') ≈⟨ refl ⟩
    h* (S^ x • H • S^ x⁻¹ • H • S^ x • H) ≈⟨ refl ⟩
    h* (S^ x) • Sym.H • h* (S^ x⁻¹) • Sym.H • h* (S^ x) • Sym.H ≈⟨ (cong (lemma-h* (toℕ x)) (cong refl (cong (lemma-h* (toℕ x⁻¹)) (cong refl (cong (lemma-h* (toℕ x)) refl))))) ⟩
    (Sym.S^ x) • Sym.H • (Sym.S^ x⁻¹) • Sym.H • (Sym.S^ x) • (Sym.H) ≈⟨ refl ⟩
    Sym.M x' ∎
    where
    open SR ws₁
    x = x' .proj₁
    x⁻¹ = ((x' ⁻¹) .proj₁ )

  h-well-defined : ∀ {w v} -> w ===₂ v -> h* w ≈₁ h* v
  h-well-defined Sim.order-S = begin
    h* (S • S ^ ₁₊ p-2) ≈⟨ lemma-h* p ⟩
    (Sym.S ^ p) ≈⟨ axiom Sym.order-S ⟩
    h* ε ∎
    where open SR ws₁
  h-well-defined Sim.order-H = axiom Sym.order-H
  h-well-defined Sim.order-SH = axiom Sym.order-SH
  h-well-defined Sim.comm-HHS = axiom Sym.comm-HHS
  h-well-defined (Sim.semi-MS) = begin
    h* (Mg • S) ≈⟨ refl ⟩
    h* Mg • h* S ≈⟨ refl ⟩
    h* (S^ x • H • S^ x⁻¹ • H • S^ x • H) • h* S ≈⟨ refl ⟩
    (h* (S^ x) • Sym.H • h* (S^ x⁻¹) • Sym.H • h* (S^ x) • Sym.H) • Sym.S ≈⟨ (cleft Sym._===_) (lemma-h*-M x') ⟩
    ((Sym.S^ x) • Sym.H • (Sym.S^ x⁻¹) • Sym.H • (Sym.S^ x) • Sym.H) • Sym.S ≈⟨ axiom (Sym.semi-MS x') ⟩
    Sym.S^ (x' Sym.^2) • ((Sym.S^ x) • Sym.H • (Sym.S^ x⁻¹) • Sym.H • (Sym.S^ x) • Sym.H) ≈⟨ cong refl ( refl) ⟩
    Sym.S^ (x' Sym.^2) • Sym.M x' ≈⟨ cong (sym (lemma-h* (toℕ (g * g)))) (sym (lemma-h*-M x')) ⟩
    h* (S^ (g * g) • Mg) ∎
    where
    open SR ws₁
    x' = (g , g≠0)
    x = x' .proj₁
    x⁻¹ = ((x' ⁻¹) .proj₁ )


  f-left-inv-gen : ∀ x -> [ x ↑] ≈₂ (f'*) (h x)
  f-left-inv-gen (Sim.H-gen) = _≈₂_.refl
  f-left-inv-gen (Sim.S-gen) = _≈₂_.refl

  h-left-inv-gen : ∀ x -> [ x ↑] ≈₁ (h*) (f' x)
  h-left-inv-gen Sym.S-gen = refl
  h-left-inv-gen Sym.H-gen = refl

  open import Algebra.Bundles using (Group)
  open import Algebra.Morphism.Structures using (module GroupMorphisms)

  open import Presentation.Morphism
  open GroupMorphisms
  module G1 = Group-Lemmas Sym.Gen Sym._===_ Sym.grouplike
  module G2 = Group-Lemmas Sim.Gen Sim._===_ Sim.grouplike

  Theorem-Sym-iso-Sim : IsGroupIsomorphism (Group.rawGroup G1.•-ε-group) (Group.rawGroup G2.•-ε-group) (f'*)
  Theorem-Sym-iso-Sim = StarGroupIsomorphism.isGroupIsomorphism f' h f-well-defined  f-left-inv-gen h-well-defined  h-left-inv-gen


