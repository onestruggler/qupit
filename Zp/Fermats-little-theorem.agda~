{-# OPTIONS  --safe #-}
{-# OPTIONS  --call-by-name #-}
{-# OPTIONS --termination-depth=5 #-}

import Data.Integer as Integer

module Fermat's-little-theorem where

open import Algebra.Structures

-- open Integer hiding (+_; _-_) -- using (_+_; _*_; -_; +0)
-- open import Data.Integer.GCD
-- open import Data.Integer.Properties hiding (*-1-isMonoid; *-1-isCommutativeMonoid; +-*-isCommutativeRing ; +-0-isAbelianGroup)
-- open import Data.Integer.Tactic.RingSolver

open import Data.Product

open import Relation.Binary
open import Relation.Binary.PropositionalEquality as ≡ using (_≡_ ; _≢_ ; inspect ; setoid ; module ≡-Reasoning ; _≗_) renaming ([_] to [_]')
open import Relation.Binary.PropositionalEquality as Eq hiding ([_])
open import Data.Nat.Divisibility

import Data.Fin as Fin
open import Data.Empty using (⊥ ; ⊥-elim)
open import Data.Fin hiding (_+_ ; _-_ ; _≤_)
open import Data.Fin.Properties

open import Data.Nat as ℕ hiding (_+_ ; _*_ ; _^_)
open import Data.Fin.Literals
import Data.Nat.Literals as NL
open import Agda.Builtin.FromNat
open import Data.Unit.Base using (⊤)
open import Data.Nat.DivMod
open import Data.Nat.Properties as NP using (n<1+n)
open import Data.Fin.Properties as FP
open import ModularArithmetic

open import Data.Nat.Primality
open import Data.Nat.Coprimality hiding (sym)
open import Data.Nat.GCD
open Bézout
open import Data.Empty
open import Algebra.Properties.Group
import Relation.Binary.Reasoning.Setoid as SR


private
  variable
    n : ℕ
    
module PrimeModulus' (p-2 : ℕ) (p-prime : Prime (₂₊ p-2)) where

  open PrimeModulus p-2 p-prime public

  open import Data.Vec.Functional as V
  open import Data.Vec.Functional.Properties
  open import Data.Vec.Functional.Relation.Binary.Permutation
  open import Data.Vec.Functional.Relation.Binary.Permutation.Properties
  import Data.Vec.Functional.Relation.Binary.Pointwise as PW
  import Data.Vec.Functional.Relation.Binary.Pointwise.Properties as PW
  open import Function
  open import Data.Product.Relation.Binary.Pointwise.NonDependent
    using () renaming (Pointwise to ×-Pointwise)    
  open import Data.Fin.Permutation as F
  open import Data.Vec.Functional.Relation.Binary.Pointwise
{-
  1--p-1 : Vector (ℤ ₚ) (p-1)
  1--p-1 = drop 1 (allFin p)

  a*1--p-1 : ∀ (a : ℤ ₚ) -> Vector (ℤ ₚ) (p-1)
  a*1--p-1 a = a *ᵥ 1--p-1

  1--n-1 : ∀ n-2 -> let n = ₂₊ n-2 in Vector (ℤ n) (₁₊ n-2)
  1--n-1 n-2 = drop 1 (allFin (₂₊ n-2))


  a*1--n-1 : ∀ n-2 -> let n = ₂₊ n-2 in (a : ℤ n) -> Vector (ℤ n) (₁₊ n-2)
  a*1--n-1 n-2 a = V.map (a *_) (1--n-1 n-2)

-}


  *-perm : ∀ (a : ℤ* ₚ) -> Permutation p p
  *-perm a*@(a , nz) =
    record { to = a *_ ; from = a⁻¹ *_ ; to-cong = cong (a *_) ; from-cong = cong (a⁻¹ *_) ; inverse = invl , invr }
    where
    a⁻¹ = (a* ⁻¹) .proj₁
    open import Function.Definitions
    invl : Inverseˡ (_≡_ {A = ℤ ₚ}) (_≡_ {A = ℤ ₚ}) (a *_) (a⁻¹ *_)
    invl {x} {y} eq = begin
      a * y ≡⟨ cong (a *_) eq ⟩
      a * (a⁻¹ * x) ≡⟨ sym (*-assoc a a⁻¹ x) ⟩
      a * a⁻¹ * x ≡⟨ cong (_* x) (lemma-⁻¹ʳ a {{nztoℕ {y = a} {neq0 = nz}}}) ⟩
      ₁ * x ≡⟨ *-identityˡ x  ⟩
      x ∎
      where open ≡-Reasoning

    invr : Inverseʳ (_≡_ {A = ℤ ₚ}) (_≡_ {A = ℤ ₚ}) (a *_) (a⁻¹ *_)
    invr {x} {y} eq = begin
      a⁻¹ * y ≡⟨ cong (a⁻¹ *_) eq ⟩
      a⁻¹ * (a * x) ≡⟨ sym (*-assoc a⁻¹ a x) ⟩
      a⁻¹ * a * x ≡⟨ cong (_* x) (lemma-⁻¹ˡ a {{nztoℕ {y = a} {neq0 = nz}}}) ⟩
      ₁ * x ≡⟨ *-identityˡ x  ⟩
      x ∎
      where open ≡-Reasoning


  *-perm* : ∀ (a : ℤ* ₚ) -> Permutation p-1 p-1
  *-perm* a = F.remove ₀ $ *-perm a


  *-perm-n : ∀ (a : ℤ* ₚ) -> Vector (ℤ ₚ) n -> Vector (ℤ ₚ) n
  *-perm-n a*@(a , nz) v = (a *_) ∘ v


  product : ∀ {n} -> Vector (ℤ ₚ) n -> ℤ ₚ
  product = foldr _*_ ₁

  perm₀ : ∀ (perm : Permutation 1 1) -> perm ⟨$⟩ʳ ₀ ≡ ₀
  perm₀ perm with perm ⟨$⟩ʳ ₀
  ... | ₀ = auto

  lemma-product : ∀ ((a , nz) : ℤ* ₚ) (v : Vector (ℤ ₚ) n) -> product ((a *_) ∘ v) ≡ a ^′ n * product  v
  lemma-product {₀} a v = auto
  lemma-product {n@(₁₊ n')} a*@(a , nz) v = begin
    product ((a *_) ∘ v) ≡⟨ auto ⟩
    (a * v ₀) * product ((a *_) ∘ v ∘ suc) ≡⟨ cong ((a * v ₀) *_) (lemma-product a* (v ∘ suc)) ⟩
    a * v ₀ * (a ^′ n' * product (v ∘ suc)) ≡⟨  *-assoc a (v ₀) (a ^′ n' * product (v ∘ suc)) ⟩
    a * (v ₀ * (a ^′ n' * product (v ∘ suc))) ≡⟨ cong (a *_) (sym ( *-assoc  (v ₀) (a ^′ n') (product (v ∘ suc)))) ⟩
    a * (v ₀ * a ^′ n' * product (v ∘ suc)) ≡⟨ cong (\ xx ->  a * (xx * product (v ∘ suc))) (*-comm (v ₀) (a ^′ n')) ⟩
    a * (a ^′ n' * v ₀ * product (v ∘ suc)) ≡⟨ cong (a *_) (*-assoc (a ^′ n') (v ₀) (product (v ∘ suc))) ⟩
    a * (a ^′ n' * (v ₀ * product (v ∘ suc))) ≡⟨ sym (*-assoc a (a ^′ n') (v ₀ * product (v ∘ suc))) ⟩
    a * a ^′ n' * (v ₀ * product (v ∘ suc)) ≡⟨ auto ⟩
    a ^′ n * product v ∎
    where open ≡-Reasoning



  lemma-π∘suc : ∀ {n-1} -> let n = ₁₊ n-1 in

    ∀ (p : Permutation n n) -> let π = p ⟨$⟩ʳ_ in
    π ₀ ≡ ₀ -> π ∘ suc ≗ suc ∘ (F.remove ₀ p ⟨$⟩ʳ_)

  lemma-π∘suc {n-1} p eq0 i = begin
     (π ∘ suc) i ≡⟨ auto ⟩
     π (suc i) ≡⟨ sym (lift₀-remove p eq0 (₁₊ i)) ⟩
     lift₀ (F.remove ₀ p) ⟨$⟩ʳ (suc i) ≡⟨ auto ⟩
     suc (F.remove ₀ p ⟨$⟩ʳ i) ≡⟨ auto ⟩
     (suc ∘ (F.remove ₀ p ⟨$⟩ʳ_)) i ∎
    where
    open ≡-Reasoning
    π = p ⟨$⟩ʳ_

  product-perm-cong : ∀ {n} (p q : Permutation n n) (v : Vector (ℤ ₚ) n) -> p ≈ q -> product {n} (v ∘ (p ⟨$⟩ʳ_)) ≡ product {n} (v ∘ (q ⟨$⟩ʳ_))
  product-perm-cong {n} p q v eq = PW.foldr-cong {R = _≡_ {A = ℤ ₚ}} {S = _≡_ {A = ℤ ₚ}} {f = _*_}  {g = _*_} (cong₂ _*_) (refl {x = ₁}) pwe
    where
    pwe : Pointwise _≡_ (v ∘ (p ⟨$⟩ʳ_)) (v ∘ (q ⟨$⟩ʳ_))
    pwe i rewrite eq i = auto


  open import Presentation.Groups.Sn

  act : ∀ {n} -> X n -> Fin (₁₊ n) -> Fin (₁₊ n)
  act {₀} () i
  act {₁₊ n} X.swap ₀ = ₁
  act {₁₊ n} X.swap ₁ = ₀
  act {₁₊ n} X.swap (₂₊ i) = ₂₊ i
  act {₁₊ n} (x ₛ) ₀ = ₀
  act {₁₊ n} (x ₛ) (₁₊ i) = ₁₊ (act x i)



  aex : ∀ {n} -> Fin n -> Permutation (₁₊ n) (₁₊ n)
  aex {n} i = F.transpose (inject₁ i) (suc i)


  open import Relation.Nullary using (does; _because_; yes; no)
  open import Data.Bool



  pwet'' : ∀ {n} (i : X n) -> (act (i ₛ) ∘ suc) ≗ (suc ∘ act i)
  pwet'' {₀} () x
  pwet'' {₁₊ n} X.swap ₀ = auto
  pwet'' {₁₊ n} X.swap (₁₊ x) = auto
  pwet'' {₁₊ n} (i ₛ) ₀ = auto
  pwet'' {₁₊ n} (i ₛ) (₁₊ x) = auto

  pwet' : ∀ {n} (i : Fin n) -> (_⟨$⟩ʳ_ (aex (₁₊ i)) ∘ suc) ≗ (suc ∘ _⟨$⟩ʳ_ (aex i))
  pwet' {n} i x with does (₁₊ x FP.≟ inject₁ (₁₊ i))
  ... | true = auto
  ... | false with does (₁₊ x FP.≟ ₂₊ i)
  ... | true = auto
  ... | false = auto


  pwet-x : ∀ {n} (i : X n) (v : Vector (ℤ ₚ) (₂₊ n)) -> Pointwise _≡_ (v ∘ act (i ₛ) ∘ suc) (v ∘ suc ∘ act i)
  pwet-x {n} i v x rewrite pwet'' i x = auto




  product∘etranspose=product : ∀ {n} (i : X n) v ->  product {₁₊ n} (v ∘ act i) ≡ product {₁₊ n} v
  product∘etranspose=product {₀} () v
  product∘etranspose=product {₁₊ n} swap v = begin
    product (v ∘ _⟨$⟩ʳ_ (F.transpose ₀ ₁)) ≡⟨ auto ⟩
    v ₁ * product (v ∘ _⟨$⟩ʳ_ (F.transpose ₀ ₁) ∘ suc) ≡⟨ auto ⟩
    v ₁ * (v ₀ * product ((v ∘ _⟨$⟩ʳ_ (F.transpose ₀ ₁) ∘ suc) ∘ suc)) ≡⟨ sym (*-assoc (v ₁) (v ₀) (product ((v ∘ _⟨$⟩ʳ_ (F.transpose ₀ ₁) ∘ suc) ∘ suc))) ⟩
    v ₁ * v ₀ * product ((v ∘ _⟨$⟩ʳ_ (F.transpose ₀ ₁) ∘ suc) ∘ suc) ≡⟨ cong (v ₁ * v ₀ *_) (PW.foldr-cong {R = _≡_ {A = ℤ ₚ}} {S = _≡_ {A = ℤ ₚ}} {f = _*_}  {g = _*_} (cong₂ _*_) (refl {x = ₁}) pwe) ⟩
    v ₁ * v ₀ * product ((v ∘ suc) ∘ suc) ≡⟨ cong (_* product ((v ∘ suc) ∘ suc)) (*-comm (v ₁) (v ₀)) ⟩
    v ₀ * v ₁ * product ((v ∘ suc) ∘ suc) ≡⟨ *-assoc (v ₀) (v ₁) (product ((v ∘ suc) ∘ suc)) ⟩
    v ₀ * (v ₁ * product ((v ∘ suc) ∘ suc)) ≡⟨ auto ⟩
    product v ∎
    where
    open ≡-Reasoning
    pwe : Pointwise _≡_ ((v ∘ _⟨$⟩ʳ_ (F.transpose ₀ ₁) ∘ suc) ∘ suc) ((v ∘ suc) ∘ suc)
    pwe i = auto
  product∘etranspose=product {₁₊ n} (i ₛ) v = begin
    product (v ∘ act (i ₛ)) ≡⟨ auto ⟩
    v ₀ * product (v ∘ (act (i ₛ)) ∘ suc) ≡⟨ cong (v ₀ *_) ((PW.foldr-cong {R = _≡_ {A = ℤ ₚ}} {S = _≡_ {A = ℤ ₚ}} {f = _*_}  {g = _*_} (cong₂ _*_) (refl {x = ₁}) pwe)) ⟩
    v ₀ * product (v ∘ suc ∘ (act i)) ≡⟨ cong (v ₀ *_) (product∘etranspose=product i (v ∘ suc)) ⟩
    v ₀ * product (v ∘ suc) ≡⟨ auto ⟩
    product v ∎
    where
    open ≡-Reasoning
    pwe : Pointwise _≡_ (v ∘ act (i ₛ) ∘ suc) (v ∘ suc ∘ act i)
    pwe x = pwet-x i v x



  open import Data.Unit
  open import Function.Construct.Composition
  import Presentation.Base as PB
  import Presentation.Properties as PP
  open import Presentation.GroupLike


  c-of-fin : ∀ {n} -> Fin (₁₊ n) -> C n
  c-of-fin {₀} ₀ = ε
  c-of-fin {₁₊ n} ₀ = ε
  c-of-fin {₁₊ n} (₁₊ x) = swap• (c-of-fin x)


  act-inv : ∀ {n} x y -> act {n} x (act x y) ≡ y
  act-inv {₀} () y
  act-inv {₁₊ n} X.swap ₀ = auto
  act-inv {₁₊ n} X.swap ₁ = auto
  act-inv {₁₊ n} X.swap (₂₊ y) = auto
  act-inv {₁₊ n} (x ₛ) ₀ = auto
  act-inv {₁₊ n} (x ₛ) (₁₊ y) = cong suc (act-inv x y)

  act' : X n → Permutation′ (₁₊ n)
  act' x = permutation
    (act x)
    (act x)
    (λ y → act-inv x y)
    (λ y → act-inv x y)

  open import Word.Base 
  wact' : Word (X n) → Permutation′ (₁₊ n)
  wact' [ x ]ʷ = act' x
  wact' ε = F.id
  wact' (w • w₁) = (wact' w₁) ∘ₚ (wact' w)

  lemma-wact-⇑₀ : ∀ {n} w -> wact' {₁₊ n} [ w ⇑] ⟨$⟩ʳ ₀ ≡ ₀
  lemma-wact-⇑₀ {n} [ X.swap ]ʷ = auto
  lemma-wact-⇑₀ {n} [ x ₛ ]ʷ = auto
  lemma-wact-⇑₀ {n} ε = auto
  lemma-wact-⇑₀ {n} (w • v) = let x = ₀ in  begin
    wact' {₁₊ n} [ (w • v) ⇑] ⟨$⟩ʳ (x) ≡⟨  auto ⟩
    wact' {₁₊ n} ([ w ⇑] • [ v ⇑]) ⟨$⟩ʳ (x) ≡⟨  auto ⟩
    wact' {₁₊ n} [ w ⇑] ⟨$⟩ʳ (wact' [ v ⇑] ⟨$⟩ʳ (x)) ≡⟨  cong (wact' {₁₊ n} [ w ⇑] ⟨$⟩ʳ_) (lemma-wact-⇑₀ v) ⟩
    wact' {₁₊ n} [ w ⇑] ⟨$⟩ʳ ₀ ≡⟨  lemma-wact-⇑₀ w  ⟩
    ₀ ∎
    where
    open ≡-Reasoning

  lemma-wact-⇑ : ∀ {n} w x -> wact' {₁₊ n} [ w ⇑] ⟨$⟩ʳ (suc x) ≡ suc (wact' {n} w ⟨$⟩ʳ x)
  lemma-wact-⇑ {n} [ x₁ ]ʷ x = auto
  lemma-wact-⇑ {n} ε x = auto
  lemma-wact-⇑ {n} (w • v) x = begin
    wact' {₁₊ n} [ (w • v) ⇑] ⟨$⟩ʳ (suc x) ≡⟨  auto ⟩
    wact' {₁₊ n} ([ w ⇑] • [ v ⇑]) ⟨$⟩ʳ (suc x) ≡⟨  auto ⟩
    wact' {₁₊ n} [ w ⇑] ⟨$⟩ʳ (wact' [ v ⇑] ⟨$⟩ʳ (suc x)) ≡⟨  cong (wact' {₁₊ n} [ w ⇑] ⟨$⟩ʳ_) (lemma-wact-⇑ v x) ⟩
    wact' {₁₊ n} [ w ⇑] ⟨$⟩ʳ suc (wact' v ⟨$⟩ʳ x) ≡⟨  lemma-wact-⇑ w ((wact' v ⟨$⟩ʳ x)) ⟩
    suc (wact' {n} (w • v) ⟨$⟩ʳ x) ∎
    where
    open ≡-Reasoning


  lemma-wact-cong-ax : ∀ {n} w v x -> let open PB (rel n) renaming (_≈_ to _≈ʷ_) in
    w === v -> wact' {n} w ⟨$⟩ʳ x ≡ wact' {n} v ⟨$⟩ʳ x 
  lemma-wact-cong-ax {₀} w v x ()
  lemma-wact-cong-ax {₁₊ n} w v ₀ order = auto
  lemma-wact-cong-ax {₁} w v ₁ order = auto
  lemma-wact-cong-ax {₂₊ n} w v ₁ order = auto
  lemma-wact-cong-ax {₂₊ n} w v (₂₊ x) order = auto
  lemma-wact-cong-ax {₁₊ n} w v ₀ comm = auto
  lemma-wact-cong-ax {₃₊ n} w v ₁ comm = auto
  lemma-wact-cong-ax {₃₊ n} w v (₂₊ x) comm = auto
  lemma-wact-cong-ax {₂₊ n} w v ₀ yang-baxter = auto
  lemma-wact-cong-ax {₂} w v ₁ yang-baxter = auto
  lemma-wact-cong-ax {₂} w v ₂ yang-baxter = auto
  lemma-wact-cong-ax {₃₊ n} w v ₁ yang-baxter = auto
  lemma-wact-cong-ax {₃} w v ₂ yang-baxter = auto
  lemma-wact-cong-ax {₃} w v (₃₊ x) yang-baxter = auto
  lemma-wact-cong-ax {₄₊ n} w v ₂ yang-baxter = auto
  lemma-wact-cong-ax {₄₊ n} w v (₃₊ x) yang-baxter = auto
  lemma-wact-cong-ax {₁₊ n} w v ₀ (congₛ {w = w'} {v = v'} eq) = trans (lemma-wact-⇑₀ w') (sym (lemma-wact-⇑₀ v'))
  lemma-wact-cong-ax {₁₊ n} w v (₁₊ x) (congₛ {w = w'} {v = v'} eq) = begin
    wact' w ⟨$⟩ʳ (₁₊ x) ≡⟨ lemma-wact-⇑ w' x ⟩
    suc (wact' w' ⟨$⟩ʳ x) ≡⟨ cong suc (lemma-wact-cong-ax _ _ x eq) ⟩
    suc (wact' v' ⟨$⟩ʳ x) ≡⟨ sym (lemma-wact-⇑ v' x) ⟩
    wact' v ⟨$⟩ʳ (₁₊ x) ∎
    where
    open ≡-Reasoning

  lemma-wact-cong : ∀ {n} w v x -> let open PB (rel n) renaming (_≈_ to _≈ʷ_) in
    w ≈ʷ v -> wact' {n} w ⟨$⟩ʳ x ≡ wact' {n} v ⟨$⟩ʳ x 
  lemma-wact-cong {n} w v x PB.refl = auto
  lemma-wact-cong {n} w v x (PB.sym eq) = sym (lemma-wact-cong v w x eq)
  lemma-wact-cong {n} w v x (PB.trans eq eq₁) = trans (lemma-wact-cong w _ x eq) (lemma-wact-cong _ v x eq₁)
  lemma-wact-cong {n} w v x (PB.cong {w = wl} {w' = wr} {v = vl} {v' = vr} eq eq₁) = begin
    wact' vl ∘ₚ wact' wl ⟨$⟩ʳ x ≡⟨ auto ⟩
    wact' wl ⟨$⟩ʳ (wact' vl ⟨$⟩ʳ x) ≡⟨ cong (wact' wl ⟨$⟩ʳ_) (lemma-wact-cong _ _ x eq₁) ⟩
    wact' wl ⟨$⟩ʳ (wact' vr ⟨$⟩ʳ x) ≡⟨ lemma-wact-cong _ _ (wact' vr ⟨$⟩ʳ x) eq ⟩
    wact' wr ⟨$⟩ʳ (wact' vr ⟨$⟩ʳ x) ≡⟨ auto ⟩
    wact' vr ∘ₚ wact' wr ⟨$⟩ʳ x ∎
    where
    open ≡-Reasoning
  lemma-wact-cong {n} w v x PB.assoc = auto
  lemma-wact-cong {n} w v x PB.left-unit = auto
  lemma-wact-cong {n} w v x PB.right-unit = auto
  lemma-wact-cong {n} w v x (PB.axiom x₁) = lemma-wact-cong-ax _ _ x x₁


  lemma-wact-inv-⇑ : ∀ {n} w ->
    let
    open Group-Lemmas _ _ (grouplike {n}) renaming (_⁻¹ to _⁻¹ʷ)
    open Group-Lemmas _ _ (grouplike {₁₊ n}) renaming (_⁻¹ to _⁻¹ʷ')
    open PB (rel (₁₊ n)) renaming (_≈_ to _≈ʷ_)
    in
    [ w ⇑] ⁻¹ʷ' ≈ʷ [ w ⁻¹ʷ ⇑]
  lemma-wact-inv-⇑ {n} [ x ]ʷ = PB.refl
  lemma-wact-inv-⇑ {n} ε = PB.refl
  lemma-wact-inv-⇑ {n} (w • w₁) = begin
    [ w • w₁ ⇑] ⁻¹ʷ' ≈⟨ refl ⟩
    [ w₁ ⇑] ⁻¹ʷ' • [ w ⇑] ⁻¹ʷ' ≈⟨ PB.cong (lemma-wact-inv-⇑ w₁) (lemma-wact-inv-⇑ w) ⟩
    [ (w • w₁) ⁻¹ʷ ⇑] ∎
    where
    open Group-Lemmas _ _ (grouplike {n}) renaming (_⁻¹ to _⁻¹ʷ) 
    open Group-Lemmas _ _ (grouplike {₁₊ n}) renaming (_⁻¹ to _⁻¹ʷ')
    open PB (rel (₁₊ n)) renaming (_≈_ to _≈ʷ_)
    open PP (rel (₁₊ n))
    open SR word-setoid


  lemma-wact-inv : ∀ {n} w x -> let open Group-Lemmas _ _ (grouplike {n}) renaming (_⁻¹ to _⁻¹ʷ) in
    wact' {n} w ⟨$⟩ʳ (wact' (w ⁻¹ʷ) ⟨$⟩ʳ x) ≡ x
  lemma-wact-inv {n} w x = begin
    wact' w ⟨$⟩ʳ (wact' (w ⁻¹ʷ) ⟨$⟩ʳ x) ≡⟨ auto ⟩
    wact' (w • w ⁻¹ʷ) ⟨$⟩ʳ x ≡⟨ lemma-wact-cong _ _ x (lemma-right-inverse {w})⟩
    wact' ε ⟨$⟩ʳ x ≡⟨ auto ⟩
    x ∎
    where
    open Group-Lemmas _ _ (grouplike {n}) renaming (_⁻¹ to _⁻¹ʷ) 
    open ≡-Reasoning

  lemma-wact-invˡ : ∀ {n} w x -> let open Group-Lemmas _ _ (grouplike {n}) renaming (_⁻¹ to _⁻¹ʷ) in
    wact' {n}  (w ⁻¹ʷ) ⟨$⟩ʳ (wact' w ⟨$⟩ʳ x) ≡ x
  lemma-wact-invˡ {n} w x = begin
    wact'  (w ⁻¹ʷ) ⟨$⟩ʳ (wact' w ⟨$⟩ʳ x) ≡⟨ auto ⟩
    wact' (w ⁻¹ʷ • w) ⟨$⟩ʳ x ≡⟨ lemma-wact-cong _ _ x (lemma-left-inverse {w})⟩
    wact' ε ⟨$⟩ʳ x ≡⟨ auto ⟩
    x ∎
    where
    open Group-Lemmas _ _ (grouplike {n}) renaming (_⁻¹ to _⁻¹ʷ) 
    open ≡-Reasoning


  lemma-wact₀ : ∀ {n} c -> wact' {n} [ c-of-fin c ] ⟨$⟩ʳ c ≡ ₀
  lemma-wact₀ {₀} ₀ = auto
  lemma-wact₀ {₁₊ n} c@₀ = auto
  lemma-wact₀ {₁₊ n} c@(₁₊ x) = begin
    (act' X.swap) ⟨$⟩ʳ (wact' [ [ c-of-fin x ] ⇑] ⟨$⟩ʳ c) ≡⟨ cong ((act' X.swap) ⟨$⟩ʳ_) (lemma-wact-⇑ [ c-of-fin x ] x) ⟩
    (act' X.swap) ⟨$⟩ʳ suc (wact' [ c-of-fin x ] ⟨$⟩ʳ x) ≡⟨ cong (act' X.swap ⟨$⟩ʳ_) (cong suc (lemma-wact₀ x)) ⟩
    (act' X.swap) ⟨$⟩ʳ suc ₀ ≡⟨ auto ⟩
    ₀ ∎
    where
    open ≡-Reasoning


  lemma-wact₀' : ∀ {n} c -> let open Group-Lemmas _ _ (grouplike {n}) renaming (_⁻¹ to _⁻¹ʷ) in
    wact' {n} ([ c-of-fin c ] ⁻¹ʷ) ⟨$⟩ʳ ₀ ≡ c
  lemma-wact₀' {n} c = begin
    wact' {n} ([ c-of-fin c ] ⁻¹ʷ) ⟨$⟩ʳ ₀ ≡⟨ cong (wact' {n} ([ c-of-fin c ] ⁻¹ʷ) ⟨$⟩ʳ_) (sym (lemma-wact₀ c)) ⟩
    wact' {n} ([ c-of-fin c ] ⁻¹ʷ) ⟨$⟩ʳ (wact' {n} [ c-of-fin c ] ⟨$⟩ʳ c) ≡⟨ lemma-wact-invˡ [ c-of-fin c ] c ⟩
    c ∎
    where
    open Group-Lemmas _ _ (grouplike {n}) renaming (_⁻¹ to _⁻¹ʷ) 
    open ≡-Reasoning

  wact : Word (X n) -> Fin (₁₊ n) -> Fin (₁₊ n)
  wact [ x ]ʷ i = act x i
  wact ε i = i
  wact (w • w₁) i = wact w (wact w₁ i)

  decompose : ∀ {n} -> Permutation′ (₁₊ n) -> NF n
  decompose {₀} p = tt
  decompose {₁₊ n} p = let x = p ⟨$⟩ʳ ₀ in decompose (F.remove ₀ (p ∘ₚ wact' ([ c-of-fin x ]))) , c-of-fin x

  decompose' : ∀ {n} -> Permutation′ (₁₊ n) -> NF n
  decompose' {₀} p = tt
  decompose' {₁₊ n} p = let x = p ⟨$⟩ʳ ₀ in decompose' (F.remove ₀ (wact' ([ c-of-fin x ] ⁻¹ʷ) ∘ₚ p)) , c-of-fin x
    where
    open Group-Lemmas _ _ (grouplike {₁₊ n}) renaming (_⁻¹ to _⁻¹ʷ)


  eval : ∀ {n} -> NF n -> Permutation′ (₁₊ n)
  eval {₀} tt = F.id
  eval {₁₊ n} (nf' , c) = (lift₀ (eval nf')) ∘ₚ wact' ([ c ] ⁻¹ʷ)
    where
    open Group-Lemmas _ _ (grouplike {₁₊ n}) renaming (_⁻¹ to _⁻¹ʷ)

  eval' : ∀ {n} -> NF n -> Permutation′ (₁₊ n)
  eval' {n} nf = wact' (inv-f n nf)

  eval'' : ∀ {n} -> NF n -> Permutation′ (₁₊ n)
  eval'' {n} nf = wact' ((inv-f n nf) ⁻¹ʷ)
    where
    open Group-Lemmas _ _ (grouplike {n}) renaming (_⁻¹ to _⁻¹ʷ)


  lift0 : ∀ {n} -> (Fin n -> Fin n) -> Fin (₁₊ n) -> Fin (₁₊ n)
  lift0 {n} f ₀ = ₀
  lift0 {n} f (₁₊ i) = suc (f i)

  nf-act : ∀ {n} -> NF n -> Fin (₁₊ n) -> Fin (₁₊ n)
  nf-act {₀} tt i = i
  nf-act {₁₊ n} (nf , c) i = lift0 (nf-act nf) (wact [ c ] i)

  lemma-fix₀ : ∀ (p : Permutation′ (₁₊ n)) -> p ∘ₚ wact' {n} [ c-of-fin (p ⟨$⟩ʳ ₀) ] ⟨$⟩ʳ ₀ ≡ ₀
  lemma-fix₀ {n} p = begin
    p ∘ₚ wact' {n} [ c-of-fin (p ⟨$⟩ʳ ₀) ] ⟨$⟩ʳ ₀ ≡⟨ auto ⟩
    wact' {n} [ c-of-fin (p ⟨$⟩ʳ ₀) ] ⟨$⟩ʳ (p ⟨$⟩ʳ ₀) ≡⟨ lemma-wact₀ (p ⟨$⟩ʳ ₀) ⟩
    ₀ ∎
    where
    open ≡-Reasoning


  eval-decompose : ∀ {n} (p : Permutation′ (₁₊ n)) -> eval (decompose p) ≈ p
  eval-decompose {₀} p ₀ with p ⟨$⟩ʳ ₀
  ... | ₀ = auto
  eval-decompose {₁₊ n} p i = begin
    lift₀ (eval (decompose (F.remove ₀ ( p ∘ₚ wact' [ c-of-fin (p ⟨$⟩ʳ ₀) ])))) ∘ₚ wact' ([ c-of-fin (p ⟨$⟩ʳ ₀) ] ⁻¹ʷ) ⟨$⟩ʳ i ≡⟨ auto ⟩
    wact' ([ c-of-fin (p ⟨$⟩ʳ ₀) ] ⁻¹ʷ) ⟨$⟩ʳ (lift₀ (eval (decompose (F.remove ₀ ( p ∘ₚ wact' [ c-of-fin (p ⟨$⟩ʳ ₀) ])))) ⟨$⟩ʳ i) ≡⟨ cong (wact' ([ c-of-fin (p ⟨$⟩ʳ ₀) ] ⁻¹ʷ) ⟨$⟩ʳ_) (lift₀-cong ((eval (decompose (F.remove ₀ ( p ∘ₚ wact' [ c-of-fin (p ⟨$⟩ʳ ₀) ]))))) ((F.remove ₀ ( p ∘ₚ wact' [ c-of-fin (p ⟨$⟩ʳ ₀) ]))) (eval-decompose ((F.remove ₀ ( p ∘ₚ wact' [ c-of-fin (p ⟨$⟩ʳ ₀) ])))) i) ⟩
    wact' ([ c-of-fin (p ⟨$⟩ʳ ₀) ] ⁻¹ʷ) ⟨$⟩ʳ (lift₀ (F.remove ₀ ( p ∘ₚ wact' [ c-of-fin (p ⟨$⟩ʳ ₀) ])) ⟨$⟩ʳ i) ≡⟨ cong (wact' ([ c-of-fin (p ⟨$⟩ʳ ₀) ] ⁻¹ʷ) ⟨$⟩ʳ_) (lift₀-remove ( p ∘ₚ wact' [ c-of-fin (p ⟨$⟩ʳ ₀) ]) (lemma-fix₀ p) i) ⟩
    wact' ([ c-of-fin (p ⟨$⟩ʳ ₀) ] ⁻¹ʷ) ⟨$⟩ʳ ((wact' [ c-of-fin (p ⟨$⟩ʳ ₀) ]) ⟨$⟩ʳ (p ⟨$⟩ʳ i)) ≡⟨ lemma-wact-invˡ [ c-of-fin (p ⟨$⟩ʳ ₀) ] (p ⟨$⟩ʳ i) ⟩
    p ⟨$⟩ʳ i ∎
    where
    open ≡-Reasoning
    open Group-Lemmas _ _ (grouplike {₁₊ n}) renaming (_⁻¹ to _⁻¹ʷ)


  eval-decompose''-aux' : ∀ {n} nf ->
    let
    open Group-Lemmas _ _ (grouplike {₁₊ n}) renaming (_⁻¹ to _⁻¹ʷ)
    open Group-Lemmas _ _ (grouplike {n}) renaming (_⁻¹ to _⁻¹ʷ')
    in
    wact' ([ inv-f n nf ⇑] ⁻¹ʷ) ≈ lift₀ (eval nf)
  eval-decompose''-aux' {₀} tt ₀ = auto
  eval-decompose''-aux' {₀} tt (₁₊ i) = auto
  eval-decompose''-aux' {₁₊ n} nf'@(nf , c) ₀ =  begin
    wact' ([ inv-f (₁₊ n) nf' ⇑] ⁻¹ʷ) ⟨$⟩ʳ ₀ ≡⟨ lemma-wact-cong ([ inv-f (₁₊ n) nf' ⇑] ⁻¹ʷ) [ (inv-f (₁₊ n) nf') ⁻¹ʷ' ⇑] ₀ (lemma-wact-inv-⇑ (inv-f (₁₊ n) nf')) ⟩
    wact' ([ (inv-f (₁₊ n) nf') ⁻¹ʷ' ⇑] ) ⟨$⟩ʳ ₀ ≡⟨ lemma-wact-⇑₀ ((inv-f (₁₊ n) nf') ⁻¹ʷ') ⟩
    ₀ ≡⟨ auto ⟩
    lift₀ (lift₀ (eval nf) ∘ₚ wact' ([ c ] ⁻¹ʷ')) ⟨$⟩ʳ ₀ ∎
    where
    open ≡-Reasoning
    open Group-Lemmas _ _ (grouplike {₂₊ n}) renaming (_⁻¹ to _⁻¹ʷ)
    open Group-Lemmas _ _ (grouplike {₁₊ n}) renaming (_⁻¹ to _⁻¹ʷ')

  eval-decompose''-aux' {₁₊ n} nf'@(nf , c) (₁₊ i) = begin
    wact' ([ inv-f (₁₊ n) nf' ⇑] ⁻¹ʷ) ⟨$⟩ʳ (₁₊ i) ≡⟨ lemma-wact-cong ([ inv-f (₁₊ n) nf' ⇑] ⁻¹ʷ) [ (inv-f (₁₊ n) nf') ⁻¹ʷ' ⇑] (₁₊ i) (lemma-wact-inv-⇑ (inv-f (₁₊ n) nf')) ⟩
    wact' ([ (inv-f (₁₊ n) nf') ⁻¹ʷ' ⇑] ) ⟨$⟩ʳ (₁₊ i) ≡⟨ lemma-wact-⇑ ((inv-f (₁₊ n) nf') ⁻¹ʷ') i ⟩
    suc (wact' ((inv-f (₁₊ n) nf') ⁻¹ʷ' ) ⟨$⟩ʳ i) ≡⟨ cong suc (lemma-wact-cong (((inv-f (₁₊ n) nf') ⁻¹ʷ' )) ([ c ] ⁻¹ʷ' • [ inv-f n nf ⇑] ⁻¹ʷ') i PB.refl) ⟩

    suc (wact' ([ c ] ⁻¹ʷ' • [ inv-f n nf ⇑] ⁻¹ʷ' ) ⟨$⟩ʳ i) ≡⟨ cong suc (cong (wact' ([ c ] ⁻¹ʷ') ⟨$⟩ʳ_) (eval-decompose''-aux' nf i)) ⟩

    suc (wact' ([ c ] ⁻¹ʷ') ⟨$⟩ʳ (lift₀ (eval nf) ⟨$⟩ʳ i)) ≡⟨ auto ⟩
    suc ((lift₀ (eval nf) ∘ₚ wact' ([ c ] ⁻¹ʷ')) ⟨$⟩ʳ i) ≡⟨ auto ⟩
    lift₀ (lift₀ (eval nf) ∘ₚ wact' ([ c ] ⁻¹ʷ')) ⟨$⟩ʳ (₁₊ i) ∎
    where
    open ≡-Reasoning
    open Group-Lemmas _ _ (grouplike {₂₊ n}) renaming (_⁻¹ to _⁻¹ʷ)
    open Group-Lemmas _ _ (grouplike {₁₊ n}) renaming (_⁻¹ to _⁻¹ʷ')




  eval-decompose'' : ∀ {n} (p : Permutation′ (₁₊ n)) -> eval'' (decompose p) ≈ p
  eval-decompose'' {₀} p ₀ with p ⟨$⟩ʳ ₀
  ... | ₀ = auto
  eval-decompose'' {₁₊ n} p i = begin
    eval'' (decompose (F.remove ₀ (p ∘ₚ wact' [ c-of-fin (p ⟨$⟩ʳ ₀) ])) , c-of-fin (p ⟨$⟩ʳ ₀)) ⟨$⟩ʳ i ≡⟨ auto ⟩
    wact' ((inv-f (₁₊ n) ((decompose (F.remove ₀ (p ∘ₚ wact' [ c-of-fin (p ⟨$⟩ʳ ₀) ])) , c-of-fin (p ⟨$⟩ʳ ₀)) )) ⁻¹ʷ) ⟨$⟩ʳ i ≡⟨ auto ⟩
    wact' (([ inv-f n (decompose (F.remove ₀ (p ∘ₚ wact' [ c-of-fin (p ⟨$⟩ʳ ₀) ]))) ⇑] • [ c-of-fin (p ⟨$⟩ʳ ₀)]) ⁻¹ʷ) ⟨$⟩ʳ i ≡⟨ lemma-wact-cong ((([ inv-f n (decompose (F.remove ₀ (p ∘ₚ wact' [ c-of-fin (p ⟨$⟩ʳ ₀) ]))) ⇑] • [ c-of-fin (p ⟨$⟩ʳ ₀)]) ⁻¹ʷ)) ((([ c-of-fin (p ⟨$⟩ʳ ₀)]) ⁻¹ʷ • [ inv-f n (decompose (F.remove ₀ (p ∘ₚ wact' [ c-of-fin (p ⟨$⟩ʳ ₀) ]))) ⇑]  ⁻¹ʷ)) i PB.refl ⟩
    wact' (([ c-of-fin (p ⟨$⟩ʳ ₀)]) ⁻¹ʷ • [ inv-f n (decompose (F.remove ₀ (p ∘ₚ wact' [ c-of-fin (p ⟨$⟩ʳ ₀) ]))) ⇑]  ⁻¹ʷ) ⟨$⟩ʳ i ≡⟨ auto ⟩
    wact' (([ c-of-fin (p ⟨$⟩ʳ ₀)]) ⁻¹ʷ) ⟨$⟩ʳ (wact' ([ inv-f n (decompose (F.remove ₀ (p ∘ₚ wact' [ c-of-fin (p ⟨$⟩ʳ ₀) ]))) ⇑]  ⁻¹ʷ) ⟨$⟩ʳ i) ≡⟨ auto ⟩
    wact' ([ inv-f n (decompose (F.remove ₀ (p ∘ₚ wact' [ c-of-fin (p ⟨$⟩ʳ ₀) ]))) ⇑]  ⁻¹ʷ) ∘ₚ wact' (([ c-of-fin (p ⟨$⟩ʳ ₀)]) ⁻¹ʷ)  ⟨$⟩ʳ i ≡⟨ cong (wact' (([ c-of-fin (p ⟨$⟩ʳ ₀)]) ⁻¹ʷ) ⟨$⟩ʳ_) (aux i) ⟩
    lift₀ (eval (decompose (F.remove ₀ ( p ∘ₚ wact' [ c-of-fin (p ⟨$⟩ʳ ₀) ])))) ∘ₚ wact' (([ c-of-fin (p ⟨$⟩ʳ ₀)]) ⁻¹ʷ)  ⟨$⟩ʳ i ≡⟨ eval-decompose p i ⟩

    p ⟨$⟩ʳ i ∎
    where
    open ≡-Reasoning
    open Group-Lemmas _ _ (grouplike {₁₊ n}) renaming (_⁻¹ to _⁻¹ʷ)
    open Group-Lemmas _ _ (grouplike {n}) renaming (_⁻¹ to _⁻¹ʷ')
    aux : wact' ([ inv-f n (decompose (F.remove ₀ (p ∘ₚ wact' [ c-of-fin (p ⟨$⟩ʳ ₀) ]))) ⇑]  ⁻¹ʷ) ≈ lift₀ (eval (decompose (F.remove ₀ ( p ∘ₚ wact' [ c-of-fin (p ⟨$⟩ʳ ₀) ]))))
    aux = eval-decompose''-aux' ((decompose (F.remove ₀ (p ∘ₚ wact' [ c-of-fin (p ⟨$⟩ʳ ₀) ]))))


{-
  eval-decompose' : ∀ {n} (p : Permutation′ (₁₊ n)) -> eval' (decompose' p) ≈ p
  eval-decompose' {₀} p ₀ with p ⟨$⟩ʳ ₀
  ... | ₀ = auto
  eval-decompose' {₁₊ n} p i = begin
    wact' ([ inv-f n (decompose' (F.remove ₀ (wact' ([ c-of-fin (p ⟨$⟩ʳ ₀) ] ⁻¹ʷ) ∘ₚ p))) ⇑] • [ c-of-fin (p ⟨$⟩ʳ ₀)]) ⟨$⟩ʳ i ≡⟨ auto ⟩
    wact' ([ inv-f n (decompose' (F.remove ₀ (wact' ([ c-of-fin (p ⟨$⟩ʳ ₀) ] ⁻¹ʷ) ∘ₚ p))) ⇑]) ⟨$⟩ʳ (wact' [ c-of-fin (p ⟨$⟩ʳ ₀)] ⟨$⟩ʳ i) ≡⟨ {!!} ⟩

    p ⟨$⟩ʳ i ∎
    where
    open ≡-Reasoning
    open Group-Lemmas _ _ (grouplike {₁₊ n}) renaming (_⁻¹ to _⁻¹ʷ)
-}

  product∘p=product'-ax : ∀ {n} w (v : Vector (ℤ ₚ) (₁₊ n)) -> let p = act' {n} w in product {₁₊ n} (v ∘ (p ⟨$⟩ʳ_)) ≡ product v
  product∘p=product'-ax {₀} () v
  product∘p=product'-ax {₁₊ n} X.swap v = begin
    product (v ∘ _⟨$⟩ʳ_ (act' X.swap)) ≡⟨ auto ⟩
    (v ∘ _⟨$⟩ʳ_ (act' X.swap)) ₀ * ((v ∘ _⟨$⟩ʳ_ (act' X.swap)) ₁ * product ((v ∘ _⟨$⟩ʳ_ (act' X.swap) ∘ suc) ∘ suc)) ≡⟨ sym (*-assoc ((v ∘ _⟨$⟩ʳ_ (act' X.swap)) ₀) ((v ∘ _⟨$⟩ʳ_ (act' X.swap)) ₁) (product ((v ∘ _⟨$⟩ʳ_ (act' X.swap) ∘ suc) ∘ suc))) ⟩
    (v ∘ _⟨$⟩ʳ_ (act' X.swap)) ₀ * (v ∘ _⟨$⟩ʳ_ (act' X.swap)) ₁ * product ((v ∘ suc) ∘ suc) ≡⟨ cong₂ _*_ (*-comm (v ₁) (v ₀)) refl ⟩
    v ₀ * v ₁ * product ((v ∘ suc) ∘ suc) ≡⟨ *-assoc (v ₀) (v ₁) (product ((v ∘ suc) ∘ suc)) ⟩
    v ₀ * (v ₁ * product ((v ∘ suc) ∘ suc)) ≡⟨ auto ⟩
    product v ∎
    where
    open ≡-Reasoning
  product∘p=product'-ax {₁₊ n} (w ₛ) v = begin
    product (v ∘ _⟨$⟩ʳ_ (act' (w ₛ))) ≡⟨ auto ⟩
    (v ∘ _⟨$⟩ʳ_ (act' (w ₛ))) ₀ * product (v ∘ _⟨$⟩ʳ_ (act' (w ₛ)) ∘ suc) ≡⟨ auto ⟩
    v ₀ * product (v ∘ _⟨$⟩ʳ_ (act' (w ₛ)) ∘ suc) ≡⟨ cong (v ₀ *_) (product∘p=product'-ax w (v ∘ suc)) ⟩
    v ₀ * product (v ∘ suc) ≡⟨ auto ⟩
    product v ∎
    where
    open ≡-Reasoning


  product∘p=product' : ∀ {n} w (v : Vector (ℤ ₚ) (₁₊ n)) -> let p = wact' {n} w in product {₁₊ n} (v ∘ (p ⟨$⟩ʳ_)) ≡ product v
  product∘p=product' {n} [ x ]ʷ v = product∘p=product'-ax x v
  product∘p=product' {n} ε v = auto
  product∘p=product' {n} (w • w₁) v = begin
    product (v ∘ _⟨$⟩ʳ_ (wact' w₁ ∘ₚ wact' w)) ≡⟨ auto ⟩
    product ((v ∘ _⟨$⟩ʳ_ (wact' w)) ∘ _⟨$⟩ʳ_ (wact' w₁)) ≡⟨ product∘p=product' w₁ (v ∘ _⟨$⟩ʳ_ (wact' w)) ⟩
    product ((v ∘ _⟨$⟩ʳ_ (wact' w))) ≡⟨ product∘p=product' w v ⟩
    product v ∎
    where
    open ≡-Reasoning



  product∘p=product : ∀ {n} (p : Permutation n n) v -> product {n} (v ∘ (p ⟨$⟩ʳ_)) ≡ product {n} v
  product∘p=product {n@(₀)} p v = auto
  product∘p=product {n@(₁₊ n')} p v = begin
    product {n} (v ∘ (p ⟨$⟩ʳ_)) ≡⟨ PW.foldr-cong {R = _≡_ {A = ℤ ₚ}} {S = _≡_ {A = ℤ ₚ}} {f = _*_}  {g = _*_} (cong₂ _*_) (refl {x = ₁}) pwe ⟩
    product {n} (v ∘ (eval'' (decompose p) ⟨$⟩ʳ_)) ≡⟨ product∘p=product' (((inv-f n' ((decompose p))) ⁻¹ʷ)) v ⟩
    product {n} v ∎
    where
    open Group-Lemmas _ _ (grouplike {n'}) renaming (_⁻¹ to _⁻¹ʷ)
    open ≡-Reasoning
    pwe : Pointwise _≡_  (v ∘ (p ⟨$⟩ʳ_)) (v ∘ (eval'' (decompose p) ⟨$⟩ʳ_))
    pwe i rewrite eval-decompose'' p i = auto


  aux-decompose : ∀ (p : Permutation′ (₂₊ n)) → p ⟨$⟩ʳ ₀ ≡ ₀ -> decompose p .proj₂ ≡ ε
  aux-decompose {n} p eq rewrite eq = auto

  fix0⇒∃w : ∀ (p : Permutation′ (₂₊ n)) → p ⟨$⟩ʳ ₀ ≡ ₀ -> ∃ \ w -> p ≈ wact' [ w ⇑]
  fix0⇒∃w {n} p eq = ((inv-f n nf) ⁻¹ʷ') , claim
    where
    open ≡-Reasoning
    open Group-Lemmas _ _ (grouplike {₁₊ n}) renaming (_⁻¹ to _⁻¹ʷ)
    open Group-Lemmas _ _ (grouplike {n}) renaming (_⁻¹ to _⁻¹ʷ')
    nfc = decompose p
    nf = nfc .proj₁
    claim : p ≈ wact' [ (inv-f n nf) ⁻¹ʷ' ⇑]
    claim i = begin
      p ⟨$⟩ʳ i ≡⟨ sym (eval-decompose'' p i) ⟩
      eval'' (decompose p) ⟨$⟩ʳ i ≡⟨ cong (\ xx -> eval'' (nf , xx) ⟨$⟩ʳ i) (aux-decompose p eq) ⟩
      eval'' (nf , ε) ⟨$⟩ʳ i ≡⟨ auto ⟩
      wact' (([ (inv-f n nf) ⇑] • ε) ⁻¹ʷ) ⟨$⟩ʳ i ≡⟨ lemma-wact-cong (([ (inv-f n nf) ⇑] • ε) ⁻¹ʷ) (((ε) ⁻¹ʷ • [ (inv-f n nf) ⇑] ⁻¹ʷ )) i PB.refl ⟩
      wact' ((ε) ⁻¹ʷ • [ (inv-f n nf) ⇑] ⁻¹ʷ ) ⟨$⟩ʳ i ≡⟨ lemma-wact-cong (((ε) ⁻¹ʷ • [ (inv-f n nf) ⇑] ⁻¹ʷ )) (([ (inv-f n nf) ⇑] ⁻¹ʷ )) i (PB.trans (PB.cong PB.refl PB.refl) PB.left-unit) ⟩
      wact' ([ (inv-f n nf) ⇑] ⁻¹ʷ ) ⟨$⟩ʳ i ≡⟨ lemma-wact-cong (([ (inv-f n nf) ⇑] ⁻¹ʷ )) ([ (inv-f n nf)  ⁻¹ʷ' ⇑] ) i (lemma-wact-inv-⇑ (inv-f n nf)) ⟩
      wact' ([ (inv-f n nf)  ⁻¹ʷ' ⇑] ) ⟨$⟩ʳ i ∎



  1--p-1 : Vector (ℤ ₚ) (p-1)
  1--p-1 = suc

  import Function as Fun
  0--p-1 : Vector (ℤ ₚ) p
  0--p-1 = Fun.id

  a*1--p-1 : ∀ (a : ℤ* ₚ) -> Vector (ℤ ₚ) (p-1)
  a*1--p-1 a*@(a , nz) = (a *_) ∘ 1--p-1


  lemma-*-perm' : ∀ ((a , nz) : ℤ* ₚ) -> let v = 1--p-1 in ∃ \ w ->  (a *_) ∘ v ≗ v ∘ (wact' w ⟨$⟩ʳ_)
  lemma-*-perm' a*@(a , nz) = w , claim
    where
    open ≡-Reasoning
    hyp = fix0⇒∃w (*-perm a*) (*-zeroʳ a)
    w = hyp .proj₁
    v = 1--p-1
    claim : (a *_) ∘ v ≗ v ∘ (wact' w ⟨$⟩ʳ_)
    claim i = begin
      a * suc i ≡⟨ auto ⟩
      (*-perm a* ⟨$⟩ʳ (suc i)) ≡⟨ hyp .proj₂ (suc i) ⟩
      (wact' [ w ⇑] ⟨$⟩ʳ (suc i)) ≡⟨ lemma-wact-⇑ w i ⟩
      suc (wact' w ⟨$⟩ʳ i) ∎


  prod-a*1--p-1 : ∀ (a : ℤ* ₚ) -> product (a*1--p-1 a) ≡ product 1--p-1
  prod-a*1--p-1 a*@(a , nz) = begin
    product (a*1--p-1 a*) ≡⟨ PW.foldr-cong {R = _≡_ {A = ℤ ₚ}} {S = _≡_ {A = ℤ ₚ}} {f = _*_}  {g = _*_} (cong₂ _*_) (refl {x = ₁}) pwe' ⟩
    product (v ∘ (wact' w ⟨$⟩ʳ_)) ≡⟨ product∘p=product' w v ⟩
    product 1--p-1 ∎
    where
    open ≡-Reasoning
    hyp = lemma-*-perm' a*
    w = hyp .proj₁
    v = 1--p-1

    pwe' : Pointwise _≡_ (a*1--p-1 a*) (v ∘ (wact' w ⟨$⟩ʳ_))
    pwe' i = hyp .proj₂ i


  prod-a*1--p-1' : ∀ (a*@(a , nz) : ℤ* ₚ) -> product (a*1--p-1 a*) ≡ a ^′ p-1 * product 1--p-1
  prod-a*1--p-1' a = lemma-product a 1--p-1


  lemma-nz : ∀ (v : Vector (ℤ ₚ) n) -> (∀ i -> v i ≢ ₀) -> product v ≢ ₀
  lemma-nz {₀} v nz = λ ()
  lemma-nz {₁₊ n} v nz nzp = lemma-nz (v ∘ suc) (nz ∘ suc) claim
    where
    open ≡-Reasoning
    claim : product (v ∘ suc) ≡ ₀
    claim = begin
      product (v ∘ suc) ≡⟨ sym (*-identityˡ (product (v ∘ suc))) ⟩
      ₁ * product (v ∘ suc) ≡⟨ cong (\ xx -> xx * (product (v ∘ suc))) (sym (lemma-⁻¹ˡ (v ₀) {{nztoℕ {y = v ₀} {neq0 = nz ₀}}} )) ⟩
      v₀⁻¹ * v ₀ * product (v ∘ suc) ≡⟨ *-assoc v₀⁻¹ (v ₀) (product (v ∘ suc)) ⟩
      v₀⁻¹ * (v ₀ * product (v ∘ suc)) ≡⟨ cong (v₀⁻¹ *_) nzp ⟩
      v₀⁻¹ * ₀ ≡⟨ *-zeroʳ v₀⁻¹ ⟩
      ₀ ∎
      where
      v₀⁻¹ = ((v ₀ , nz ₀) ⁻¹) .proj₁

  Fermat's-little-theorem : ∀ (a*@(a , nz) : ℤ* ₚ) -> a ^′ p-1 ≡ ₁
  Fermat's-little-theorem a*@(a , nz) = begin
    a ^′ p-1 ≡⟨ sym (*-identityʳ (a ^′ p-1 ))  ⟩
    a ^′ p-1 * ₁ ≡⟨ cong (\ xx -> a ^′ p-1 * xx) (sym (lemma-⁻¹ʳ x {{nztoℕ {y = x} {neq0 = lemma-nz 1--p-1 λ i ()}}})) ⟩
    a ^′ p-1 * (x * x⁻¹) ≡⟨ sym (*-assoc (a ^′ p-1) x x⁻¹) ⟩
    a ^′ p-1 * x * x⁻¹ ≡⟨ cong (\ xx ->  xx * x⁻¹) (trans (sym ( prod-a*1--p-1' a*)) (prod-a*1--p-1 a*)) ⟩
    x * x⁻¹ ≡⟨ lemma-⁻¹ʳ x {{nztoℕ {y = x} {neq0 = lemma-nz 1--p-1 λ i ()}}} ⟩
    ₁ ∎
    where
    open ≡-Reasoning
    x = product 1--p-1
    x⁻¹ = ((x , lemma-nz 1--p-1 λ i () ) ⁻¹) .proj₁



{-

  module Primitive-Root-Modp
    (g : ℤ ₚ)
    (g-gen : ∀ ((x , _) : ℤ* ₚ) -> ∃ \ (k : ℤ ₚ-₁) -> x ≡ g ^′ toℕ k )
    where

    g-gen1 = g-gen (₁ , λ ())
    g-gen2 = g-gen (₂ , λ ())
    g≠0 : g ≢ ₀
    g≠0 eq0 with g-gen2
    g≠0 eq0 | (suc k , eq) rewrite eq0 | lemma-0^′k {p-2} (toℕ k) with eq
    g≠0 eq0 | (suc k , eq) | ()
    g≠0 eq0 | (₀ , eq) with eq
    g≠0 eq0 | (₀ , eq) | ()

    lemma-g^′k≠0 : ∀ k -> g ^′ k ≢ 0ₚ
    lemma-g^′k≠0 k = lemma-x^′k≠0 g k g≠0


    lemma-g^′1=g : g ^′ 1 ≡ g
    lemma-g^′1=g = lemma-x^′1=x g


    g′ : ℤ* ₚ
    g′ = (g , g≠0)

    g^_ : ∀ (k : ℤ ₚ) -> ℤ* ₚ
    g^_ k = (g ^′ toℕ k , lemma-g^′k≠0 (toℕ k))

    g^′_ : ∀ k -> ℤ* ₚ
    g^′_ k = (g ^′ k , lemma-g^′k≠0 k)


    open import Algebra.Properties.Ring (+-*-ring p-2)

    aux-g^′-% : ∀ k -> g ^′ k ≡ g ^′ (k ℕ.% p-1)
    aux-g^′-% k = begin
      g ^′ k ≡⟨ Eq.cong (g ^′_) ( m≡m%n+[m/n]*n k p-1) ⟩
      g ^′ (k%p-1 ℕ.+ k/p-1 ℕ.* p-1) ≡⟨ Eq.sym (+-^′-distribʳ g k%p-1 ((k/p-1 ℕ.* p-1))) ⟩
      g ^′ k%p-1 * g ^′ (k/p-1 ℕ.* p-1) ≡⟨ Eq.cong (\ xx -> g ^′ k%p-1 * g ^′ xx) (NP.*-comm k/p-1 p-1) ⟩
      g ^′ k%p-1 * g ^′ (p-1 ℕ.* k/p-1) ≡⟨ Eq.cong (g ^′ k%p-1 *_) ( (lemma-^^-* g p-1 k/p-1)) ⟩
      g ^′ k%p-1 * (g ^′ p-1) ^′ k/p-1 ≡⟨ Eq.cong (\ xx -> g ^′ k%p-1 * xx ^′ k/p-1) (Fermat's-little-theorem (g , g≠0)) ⟩
      g ^′ k%p-1 * 1ₚ ^′ k/p-1 ≡⟨ Eq.cong (\ xx -> g ^′ k%p-1 * xx) (1^k=1 k/p-1) ⟩
      g ^′ k%p-1 * 1ₚ ≡⟨ *-identityʳ (g ^′ k%p-1) ⟩
      g ^′ k%p-1 ≡⟨ auto ⟩
      g ^′ (k ℕ.% p-1) ∎
      where
      open ≡-Reasoning
      k%p-1 = k ℕ.% p-1
      k/p-1 = k ℕ./ p-1


    log : ℤ* ₚ -> ℤ ₚ-₁
    log  x = g-gen x .proj₁


    lemma-inject : ∀ (x : ℤ ₚ-₁) -> g ^′ toℕ x ≡ (g^ (inject₁ x)) .proj₁
    lemma-inject  x = begin
      g ^′ toℕ x ≡⟨ Eq.cong (g ^′_) (Eq.sym (toℕ-inject₁ x) ) ⟩
      g ^′ toℕ (inject₁ x) ≡⟨ auto ⟩
      (g^ inject₁ x) .proj₁ ∎
      where
      open ≡-Reasoning

    lemma-log-inject : ∀ (x : ℤ* ₚ) -> (g^ (inject₁ (log x))) .proj₁ ≡ x .proj₁
    lemma-log-inject x = begin
      (g^ (inject₁ (log x))) .proj₁ ≡⟨ Eq.sym (lemma-inject (log x)) ⟩
      g ^′ toℕ (log x) ≡⟨ Eq.sym (g-gen x .proj₂) ⟩
      x .proj₁ ∎
      where
      open ≡-Reasoning

    choose : ∀ (n k : ℕ)-> ℕ
    choose n ₀ = ₁
    choose ₀ (₁₊ _) = ₀
    choose (₁₊ n) (₁₊ k) = choose n k ℕ.+ choose n (₁₊ k)


    Fermat's-little-theorem' : g ^′ p-1 ≡ ₁
    Fermat's-little-theorem' = Fermat's-little-theorem (g , g≠0)

-}




  module Primitive-Root-Modp'
    (g*@(g , g≠0) : ℤ* ₚ)
    (g-gen : ∀ ((x , _) : ℤ* ₚ) -> ∃ \ (k : ℤ ₚ-₁) -> x ≡ g ^′ toℕ k )
    where

    g-gen1 = g-gen (₁ , λ ())

    lemma-g^′k≠0 : ∀ k -> g ^′ k ≢ 0ₚ
    lemma-g^′k≠0 k = lemma-x^′k≠0 g k g≠0


    lemma-g^′1=g : g ^′ 1 ≡ g
    lemma-g^′1=g = lemma-x^′1=x g


    g′ : ℤ* ₚ
    g′ = (g , g≠0)

    g^_ : ∀ (k : ℤ ₚ) -> ℤ* ₚ
    g^_ k = (g ^′ toℕ k , lemma-g^′k≠0 (toℕ k))

    g^′_ : ∀ k -> ℤ* ₚ
    g^′_ k = (g ^′ k , lemma-g^′k≠0 k)


    open import Algebra.Properties.Ring (+-*-ring p-2)

    aux-g^′-% : ∀ k -> g ^′ k ≡ g ^′ (k ℕ.% p-1)
    aux-g^′-% k = begin
      g ^′ k ≡⟨ Eq.cong (g ^′_) ( m≡m%n+[m/n]*n k p-1) ⟩
      g ^′ (k%p-1 ℕ.+ k/p-1 ℕ.* p-1) ≡⟨ Eq.sym (+-^′-distribʳ g k%p-1 ((k/p-1 ℕ.* p-1))) ⟩
      g ^′ k%p-1 * g ^′ (k/p-1 ℕ.* p-1) ≡⟨ Eq.cong (\ xx -> g ^′ k%p-1 * g ^′ xx) (NP.*-comm k/p-1 p-1) ⟩
      g ^′ k%p-1 * g ^′ (p-1 ℕ.* k/p-1) ≡⟨ Eq.cong (g ^′ k%p-1 *_) ( (lemma-^^-* g p-1 k/p-1)) ⟩
      g ^′ k%p-1 * (g ^′ p-1) ^′ k/p-1 ≡⟨ Eq.cong (\ xx -> g ^′ k%p-1 * xx ^′ k/p-1) (Fermat's-little-theorem (g , g≠0)) ⟩
      g ^′ k%p-1 * 1ₚ ^′ k/p-1 ≡⟨ Eq.cong (\ xx -> g ^′ k%p-1 * xx) (1^k=1 k/p-1) ⟩
      g ^′ k%p-1 * 1ₚ ≡⟨ *-identityʳ (g ^′ k%p-1) ⟩
      g ^′ k%p-1 ≡⟨ auto ⟩
      g ^′ (k ℕ.% p-1) ∎
      where
      open ≡-Reasoning
      k%p-1 = k ℕ.% p-1
      k/p-1 = k ℕ./ p-1


    log : ℤ* ₚ -> ℤ ₚ-₁
    log  x = g-gen x .proj₁


    lemma-inject : ∀ (x : ℤ ₚ-₁) -> g ^′ toℕ x ≡ (g^ (inject₁ x)) .proj₁
    lemma-inject  x = begin
      g ^′ toℕ x ≡⟨ Eq.cong (g ^′_) (Eq.sym (toℕ-inject₁ x) ) ⟩
      g ^′ toℕ (inject₁ x) ≡⟨ auto ⟩
      (g^ inject₁ x) .proj₁ ∎
      where
      open ≡-Reasoning

    lemma-log-inject : ∀ (x : ℤ* ₚ) -> (g^ (inject₁ (log x))) .proj₁ ≡ x .proj₁
    lemma-log-inject x = begin
      (g^ (inject₁ (log x))) .proj₁ ≡⟨ Eq.sym (lemma-inject (log x)) ⟩
      g ^′ toℕ (log x) ≡⟨ Eq.sym (g-gen x .proj₂) ⟩
      x .proj₁ ∎
      where
      open ≡-Reasoning

    choose : ∀ (n k : ℕ)-> ℕ
    choose n ₀ = ₁
    choose ₀ (₁₊ _) = ₀
    choose (₁₊ n) (₁₊ k) = choose n k ℕ.+ choose n (₁₊ k)


    Fermat's-little-theorem' : g ^′ p-1 ≡ ₁
    Fermat's-little-theorem' = Fermat's-little-theorem (g , g≠0)





















{- 
    open import Data.Vec.Recursive as V renaming (_^_ to _′^_)
    open import Data.Vec.Properties
    open import Data.Vec.Recursive.Properties
    open import Function
    
    sum : ℤ ₚ ′^ n → ℤ ₚ
    sum {n} = foldr 0ₚ id (\ n a s -> a + s) n

    infix 7 _*ᵥ_ _*ᵢ_ _ᵥ*_
    infix 6 _+ᵢ_
    infix 5 _*ₛ_
    
    _*ᵥ_ : ℤ ₚ -> ℤ ₚ ′^ n -> ℤ ₚ ′^ n
    _*ᵥ_ {n} x = V.map (x *_) n

    _ᵥ*_ : ℤ ₚ -> ℤ ₚ ′^ n -> ℤ ₚ ′^ n
    _ᵥ*_ {n} x = V.map (_* x) n

    _*ᵢ_ : ℤ ₚ ′^ n -> ℤ ₚ ′^ n -> ℤ ₚ ′^ n
    _*ᵢ_ {n} = V.zipWith _*_ n

    _*ₛ_ : ℕ ′^ n -> ℤ ₚ ′^ n -> ℤ ₚ ′^ n
    _*ₛ_ {n} = V.zipWith _＊_ n

    _ +ᵢ_ : ℤ ₚ ′^ n -> ℤ ₚ ′^ n -> ℤ ₚ ′^ n
    _+ᵢ_ {n} = V.zipWith _+_ n

    open import Data.Unit.Base
    

    *-distribˡ-sum : ∀ x (vs : ℤ ₚ ′^ n) -> x * sum vs ≡ sum (x *ᵥ vs)
    *-distribˡ-sum {1} x vs = auto
    *-distribˡ-sum {0} x vs = begin
      x * sum vs ≡⟨ auto ⟩
      x * ₀ ≡⟨ *-zeroʳ x ⟩
      ₀ ≡⟨ auto ⟩
      sum (x *ᵥ vs) ∎
      where
      open ≡-Reasoning
    *-distribˡ-sum {₂₊ n} x vs@(v , t) = begin
      x * sum vs ≡⟨ auto ⟩
      x * (v + sum t) ≡⟨ *-distribˡ-+ x v (sum t) ⟩
      x * v + x * sum t ≡⟨ cong (x * v +_) (*-distribˡ-sum x t) ⟩
      x * v + sum (x *ᵥ t) ≡⟨ auto ⟩
      sum (x *ᵥ vs) ∎
      where
      open ≡-Reasoning


    +-sum-comm : ∀ (v1 v2 : ℤ ₚ ′^ n) -> sum v1 + sum v2 ≡ sum (v1 +ᵢ v2)
    +-sum-comm {1} v1 v2 = auto
    +-sum-comm {0} v1 v2 = auto
    +-sum-comm {₂₊ n} v1@(x , t) v2@(y , t2) = begin
      sum v1 + sum v2 ≡⟨ auto ⟩
      x + sum t + (y + sum t2) ≡⟨ +-assoc x (sum t) (y + sum t2) ⟩
      x + (sum t + (y + sum t2)) ≡⟨ cong (x +_) (sym (+-assoc (sum t) y (sum t2))) ⟩
      x + (sum t + y + sum t2) ≡⟨ cong (x +_) (cong (_+ sum t2) (+-comm (sum t) y)) ⟩
      x + (y + sum t + sum t2) ≡⟨ cong (x +_) (+-assoc y (sum t) (sum t2)) ⟩
      x + (y + (sum t + sum t2)) ≡⟨ sym (+-assoc x y (sum t + sum t2)) ⟩
      (x + y) + (sum t + sum t2) ≡⟨ cong ((x + y) +_) (+-sum-comm t t2) ⟩
      (x + y) + sum (t +ᵢ t2) ≡⟨ auto ⟩
      sum (v1 +ᵢ v2) ∎
      where
      open ≡-Reasoning


    add-adj : ℕ ′^ (₁₊ n) -> ℕ ′^ n
    add-adj {₀} _ = []
    add-adj {₁} (x , v) = x ℕ.+ v
    add-adj {₂₊ n} (x , x₁ , v) = x ℕ.+ x₁ , add-adj (x₁ , v)

    infixr 5 _,ʳ_
    _,ʳ_ : ∀ {a}{A : Set a} -> A ′^ n -> A -> A ′^ (₁₊ n) 
    _,ʳ_ {0} {a}{A} xs x = x
    _,ʳ_ {1} {a}{A} xs x = xs , x
    _,ʳ_ {₂₊ n} {a}{A} xs@(h , t) x = h , t ,ʳ x

    pascal-row : ∀ (n : ℕ) -> ℕ ′^ (₁₊ n)
    pascal-row ₀ = ₁
    pascal-row ₁ = ₁ , ₁
    pascal-row (₂₊ n) = ₁ , (add-adj {₁₊ n} (pascal-row (₁₊ n)) ,ʳ 1)

    x^k : (a : ℤ ₚ) (k : ℕ) -> ℤ ₚ ′^ (₁₊ k)
    x^k a ₀ = (a ^′ ₀)
    x^k a (₁₊ k) = (a ^′ (₁₊ k)) , (x^k a k)

    x^kʳ : (a : ℤ ₚ) (k : ℕ) -> ℤ ₚ ′^ (₁₊ k)
    x^kʳ a ₀ = [] ,ʳ a ^′ ₀
    x^kʳ a (₁₊ k) = x^kʳ a k ,ʳ a ^′ (₁₊ k)

    lemma-*ᵥ-,ʳ : ∀ a (as : ℤ ₚ ′^ n) l -> a *ᵥ (as ,ʳ l) ≡ a *ᵥ as ,ʳ a * l
    lemma-*ᵥ-,ʳ {0} a as l = auto
    lemma-*ᵥ-,ʳ {1} a as l = auto
    lemma-*ᵥ-,ʳ {₂₊ n} a as l = begin
      a *ᵥ (as ,ʳ l) ≡⟨ cong (\ xx -> a *ᵥ (xx ,ʳ l)) (sym (cons-head-tail-identity (₁₊ n) as)) ⟩
      a *ᵥ (cons (₁₊ n) (head (₁₊ n) as) (tail (₁₊ n) as) ,ʳ l) ≡⟨ auto ⟩
      a * head (₁₊ n) as , a *ᵥ (tail (₁₊ n) as ,ʳ l) ≡⟨ cong (a * head (₁₊ n) as ,_) (lemma-*ᵥ-,ʳ a (tail (₁₊ n) as) l) ⟩
      a * head (₁₊ n) as , a *ᵥ tail (₁₊ n) as ,ʳ a * l ≡⟨ auto ⟩
      a *ᵥ (head (₁₊ n) as , tail (₁₊ n) as) ,ʳ a * l ≡⟨ auto ⟩
      a *ᵥ as ,ʳ a * l ∎
      where
      open ≡-Reasoning

    lemma-head : (v : ℤ ₚ ′^ (₁₊ n)) (a : ℤ ₚ) -> head (₁₊ n) (v ,ʳ a) ≡ head n v
    lemma-head {0} v a = auto
    lemma-head {1} v a = auto
    lemma-head {₂₊ n} v a = auto

    head-x^kʳ : ∀ a k -> head k (x^kʳ a k) ≡ ₁
    head-x^kʳ a k@₀ = auto
    head-x^kʳ a k@(₁) = auto
    head-x^kʳ a k@(₂₊ k-2) = let k-1 = ₁₊ k-2 in begin
      head k (x^kʳ a k) ≡⟨ auto ⟩
      head k (x^kʳ a k-1 ,ʳ a ^′ k) ≡⟨ auto ⟩
      head k-1 (x^kʳ a k-1) ≡⟨ head-x^kʳ a k-1 ⟩
      ₁ ∎
      where
      open ≡-Reasoning
    
    tail-x^kʳ : ∀ a k-1 -> let k = ₁₊ k-1 in tail k (x^kʳ a k) ≡ a *ᵥ x^kʳ a k-1
    tail-x^kʳ a k-1@0 = auto
    tail-x^kʳ a k-1@1 = auto
    tail-x^kʳ a k-1@(₂₊ k-3) = let k = ₁₊ k-1 in let k-2 = ₁₊ k-3 in begin
      tail k (x^kʳ a k) ≡⟨ auto ⟩
      tail k (x^kʳ a k-1 ,ʳ a ^′ k) ≡⟨ auto ⟩
      tail k-1 (x^kʳ a k-1) ,ʳ a ^′ k ≡⟨ cong (_,ʳ a ^′ k) (tail-x^kʳ a k-2) ⟩
      a *ᵥ x^kʳ a k-2 ,ʳ a * a ^′ k-1 ≡⟨ sym (lemma-*ᵥ-,ʳ a (x^kʳ a k-2) (a ^′ k-1)) ⟩
      a *ᵥ (x^kʳ a k-2 ,ʳ a ^′ k-1) ≡⟨ auto ⟩
      a *ᵥ x^kʳ a k-1 ∎
      where
      open ≡-Reasoning


    *ᵥ-*ᵢ-assoc : ∀ a (xs ys : ℤ ₚ ′^ n) -> (a *ᵥ xs) *ᵢ ys ≡ a *ᵥ (xs *ᵢ ys)
    *ᵥ-*ᵢ-assoc {0} a xs ys = auto
    *ᵥ-*ᵢ-assoc {1} a xs ys = *-assoc a xs ys
    *ᵥ-*ᵢ-assoc {₂₊ n-2} a xs@(x , xt) ys@(y , yt) = begin
      (a *ᵥ xs) *ᵢ ys ≡⟨ auto ⟩
      (a * x , a *ᵥ xt) *ᵢ (y , yt) ≡⟨ auto ⟩
      a * x * y , (a *ᵥ xt) *ᵢ yt ≡⟨ cong₂ _,_ (*-assoc a x y) (*ᵥ-*ᵢ-assoc a xt yt) ⟩
      a * (x * y) , a *ᵥ (xt *ᵢ yt) ≡⟨ auto ⟩
      a *ᵥ (xs *ᵢ ys) ∎
      where
      open ≡-Reasoning

    lemma-x^k : ∀ (a b : ℤ ₚ) (k-1 : ℕ) -> let k = ₁₊ k-1 in
    
      (x^kʳ a k) *ᵢ (x^k b k) ≡ (b ^′ k , a *ᵥ (x^kʳ a k-1 *ᵢ x^k b k-1))
      
    lemma-x^k a b k-1 = let k = ₁₊ k-1 in begin
      (x^kʳ a k) *ᵢ (x^k b k) ≡⟨ cong (_*ᵢ (x^k b k)) (sym (cons-head-tail-identity k (x^kʳ a k))) ⟩
      cons k (head k (x^kʳ a k)) (tail k (x^kʳ a k)) *ᵢ (x^k b k) ≡⟨ cong (\ xx -> cons k xx (tail k (x^kʳ a k)) *ᵢ (x^k b k)) (head-x^kʳ a k) ⟩
      cons k ₁ (tail k (x^kʳ a k)) *ᵢ x^k b k ≡⟨ cong (\ xx -> cons k ₁ xx *ᵢ (x^k b k)) (tail-x^kʳ a k-1) ⟩
      cons k ₁ (a *ᵥ x^kʳ a k-1) *ᵢ x^k b k ≡⟨ auto ⟩
      ₁ * b ^′ k , (a *ᵥ x^kʳ a k-1) *ᵢ x^k b k-1 ≡⟨ cong₂ _,_ (*-identityˡ (b ^′ k)) (*ᵥ-*ᵢ-assoc a (x^kʳ a k-1) (x^k b k-1)) ⟩
      b ^′ k , a *ᵥ (x^kʳ a k-1 *ᵢ x^k b k-1) ∎
      where
      open ≡-Reasoning


    binomial-terms : ∀ (a b : ℤ ₚ) (k : ℕ) -> ℤ ₚ ′^ (₁₊ k)
    binomial-terms a b k = pascal-row k *ₛ (x^kʳ a k) *ᵢ (x^k b k)

    lemma-binomia-terms' : ∀ (a b : ℤ ₚ) (k-1 : ℕ) -> let k = ₁₊ k-1 in
    
      binomial-terms a b k ≡ (b ^′ k , (add-adj (pascal-row k-1) ,ʳ 1) *ₛ a *ᵥ (x^kʳ a k-1 *ᵢ x^k b k-1))
      
    lemma-binomia-terms' a b k-1@(0) = let k = ₁₊ k-1 in begin
      pascal-row k *ₛ (x^kʳ a k) *ᵢ (x^k b k) ≡⟨ cong (pascal-row k *ₛ_) (lemma-x^k a b k-1) ⟩
      (₁ , ₁) *ₛ (b ^′ k , a *ᵥ (x^kʳ a k-1 *ᵢ x^k b k-1)) ≡⟨ cong₂ _,_ (*-identityˡ (b ^′ k)) auto ⟩
      (b ^′ k , 1 *ₛ a *ᵥ (x^kʳ a k-1 *ᵢ x^k b k-1)) ∎
      where
      open ≡-Reasoning
    lemma-binomia-terms' a b k-1@(₁₊ k-2) = let k = ₁₊ k-1 in begin
      pascal-row k *ₛ (x^kʳ a k) *ᵢ (x^k b k) ≡⟨ cong (pascal-row k *ₛ_) (lemma-x^k a b k-1) ⟩
      pascal-row k *ₛ (b ^′ k , a *ᵥ (x^kʳ a k-1 *ᵢ x^k b k-1)) ≡⟨ cong₂ _,_ (*-identityˡ (b ^′ k)) auto ⟩
      (b ^′ k , (add-adj (pascal-row k-1) ,ʳ 1) *ₛ a *ᵥ (x^kʳ a k-1 *ᵢ x^k b k-1)) ∎
      where
      open ≡-Reasoning


-}

{-
    lemma-binomia-terms : ∀ (a b : ℤ ₚ) (k-1 : ℕ) -> let k = ₁₊ k-1 in
    
      binomial-terms a b k ≡ (₀ , a *ᵥ binomial-terms a b k-1) +ᵢ (b *ᵥ binomial-terms a b k-1 ,ʳ ₀)
      
    lemma-binomia-terms a b k-1@₀ = let k = ₁₊ k-1 in begin
      binomial-terms a b k ≡⟨ auto ⟩
      pascal-row k *ₛ (x^kʳ a k) *ᵢ (x^k b k) ≡⟨ auto ⟩
      (₁ ＊ a ^′ ₀ * b ^′ k) , (₁ ＊ a ^′ ₁ * b ^′ ₀ , []) ≡⟨ cong₂ (\ xx yy -> xx , yy , []) (1＊x=x (₁ * b ^′ ₁)) (1＊x=x (a ^′ ₁ * ₁)) ⟩
      (₁ * b ^′ ₁) , (a ^′ ₁ * ₁ , []) ≡⟨ cong₂ (\ xx yy -> xx , yy , []) (*-identityˡ (b ^′ ₁)) (*-identityʳ (a ^′ ₁)) ⟩
      b ^′ ₁ , a ^′ ₁ , [] ≡⟨ cong₂ (λ xx yy → xx , (yy , [])) (*-identityʳ b) (*-identityʳ a) ⟩
      b , a , [] ≡⟨ sym (cong₂ (λ xx yy → xx , (yy , [])) (*-identityʳ b) (*-identityʳ a)) ⟩
      b * ₁ , a * ₁ , [] ≡⟨ sym (cong₂ (λ xx yy → xx , (yy , [])) (*-identityˡ (b * ₁)) (*-identityʳ (a * ₁))) ⟩
      ₁ * (b * ₁) , a * ₁ * ₁ , [] ≡⟨ cong₂ (λ xx yy → xx , (yy , [])) (trans (*-identityˡ (b * ₁)) (*-identityʳ b)) (trans (*-identityʳ (a * ₁)) (*-identityʳ a)) ⟩
      b , a , [] ≡⟨ cong₂ (λ xx yy → xx , (yy , [])) (sym (+-identityˡ b)) (sym (+-identityʳ a)) ⟩
      ₀ + b , a + ₀ , [] ≡⟨ auto ⟩
      (₀ , a , []) +ᵢ ((b , []) ,ʳ ₀) ≡⟨ cong₂ (\ xx yy -> (₀ , xx , []) +ᵢ ((yy , []) ,ʳ ₀)) (sym (*-identityʳ a)) (sym (*-identityʳ b)) ⟩
      (₀ , (a * ₁ , [])) +ᵢ ((b * ₁ , []) ,ʳ ₀) ≡⟨ auto ⟩
      (₀ , a *ᵥ binomial-terms a b k-1) +ᵢ (b *ᵥ binomial-terms a b k-1 ,ʳ ₀) ∎
      where
      open ≡-Reasoning
    lemma-binomia-terms a b k-1@(₁₊ k-2) = let k = ₁₊ k-1 in begin
      binomial-terms a b k ≡⟨ auto ⟩
      pascal-row k *ₛ (x^kʳ a k) *ᵢ (x^k b k) ≡⟨ {!auto!} ⟩
      ₁ ＊ a ^′ ₀ * b ^′ k , ((add-adj (pascal-row k-1) ,ʳ ₁) *ₛ (x^kʳ a k-1) *ᵢ (x^k b k-1)) ≡⟨ {!!} ⟩
      (₀ , a *ᵥ binomial-terms a b k-1) +ᵢ (b *ᵥ binomial-terms a b k-1 ,ʳ ₀) ∎
      where
      open ≡-Reasoning

    binomial-formula : ∀ (a b : ℤ ₚ) (k : ℕ) -> ℤ ₚ
    binomial-formula a b k = sum $ binomial-terms a b k

    binomial-theorem : ∀ (a b : ℤ ₚ) (k : ℕ) -> (a + b) ^′ k ≡ binomial-formula a b k
    binomial-theorem a b 0 = auto
    binomial-theorem a b k@(₁₊ k-1) = begin
      (a + b) ^′ k ≡⟨ auto ⟩
      (a + b) * (a + b) ^′ k-1 ≡⟨ cong ((a + b) *_) (binomial-theorem a b k-1) ⟩
      (a + b) * binomial-formula a b k-1 ≡⟨ *-distribʳ-+ (binomial-formula a b k-1) a b ⟩
      a * binomial-formula a b k-1 + b * binomial-formula a b k-1 ≡⟨ (cong₂ _+_ (*-distribˡ-sum a (binomial-terms a b k-1)) (*-distribˡ-sum b (binomial-terms a b k-1))) ⟩
      sum (a *ᵥ binomial-terms a b k-1) + sum (b *ᵥ binomial-terms a b k-1) ≡⟨ +-sum-comm (a *ᵥ binomial-terms a b k-1) (b *ᵥ binomial-terms a b k-1) ⟩
      sum (a *ᵥ binomial-terms a b k-1 +ᵢ b *ᵥ binomial-terms a b k-1) ≡⟨ {!!} ⟩
      binomial-formula a b k ∎
      where
      open ≡-Reasoning

  {-

    freshman's-dream : ∀ (a b : ℤ ₚ) (k-1 : ℕ) -> let k = ₁₊ k-1 in (a + b) ^′ k ≡ a ^′ k + b ^′ k
    freshman's-dream a b 0 = {!!}
    freshman's-dream a b k-1@(₁₊ k-2) = let k = ₁₊ k-1 in begin
      (a + b) ^′ k ≡⟨ auto ⟩
      (a + b) * (a + b) ^′ k-1 ≡⟨ cong ((a + b) *_) (freshman's-dream a b k-2) ⟩
      (a + b) * (a ^′ k-1 + b ^′ k-1) ≡⟨ *-distribˡ-+ (a + b) (a ^′ k-1) (b ^′ k-1) ⟩
      (a + b) * a ^′ k-1 + (a + b) * b ^′ k-1 ≡⟨ cong₂ _+_ (*-distribʳ-+ (a ^′ k-1) a b) (*-distribʳ-+ (b ^′ k-1) a b) ⟩
      (a * a ^′ k-1 + b * a ^′ k-1) + (a * b ^′ k-1 + b * b ^′ k-1) ≡⟨ {!!} ⟩
      (a ^′ k + b * a ^′ k-1) + (a * b ^′ k-1 + b ^′ k) ≡⟨ {!!} ⟩
      a ^′ k + b ^′ k ∎
      where
      open ≡-Reasoning



    Fermat's-little-theorem : g ^′ p-1 ≡ 1ₚ
    Fermat's-little-theorem with g-gen (g ^′ p-1 , {!!}) -- lemma-g^′k≠0 p-1
    ... | k@₀ , eq = begin
      g ^′ p-1 ≡⟨ eq ⟩
      g ^′ toℕ k ≡⟨ auto ⟩
      1ₚ ∎
      where
      open ≡-Reasoning
    ... | k@(₁₊ _) , eq = {!aux-5!}
      where
      open ≡-Reasoning
      aux-1 : g ^′ p-1 + - (g ^′ toℕ k) ≡ 0ₚ
      aux-1 = begin
        g ^′ p-1 + - (g ^′ toℕ k) ≡⟨ Eq.cong (\ xx -> g ^′ p-1 + - (xx)) (Eq.sym eq) ⟩
        g ^′ p-1 + - (g ^′ p-1) ≡⟨ +-inverseʳ (g ^′ p-1) ⟩
        0ₚ ∎
      l = toℕ k
      aux-2 : (g ^′ (p-1 ∸ l)  + - 1ₚ) * (g ^′ l) ≡ 0ₚ
      aux-2 = begin
        (g ^′ (p-1 ∸ l)  + - 1ₚ) * (g ^′ l) ≡⟨ *-distribʳ-+ (g ^′ l) (g ^′ (p-1 ∸ l)) (- 1ₚ) ⟩
        g ^′ (p-1 ∸ l) * (g ^′ l)  + - 1ₚ * (g ^′ l) ≡⟨ Eq.cong₂ _+_ (+-^′-distribʳ g (p-1 ∸ l) l) (-1*x≈-x (g ^′ l)) ⟩
        g ^′ ((p-1 ∸ l) ℕ.+ l)  + - ((g ^′ l)) ≡⟨ Eq.cong (\ xx -> g ^′ xx  + - ((g ^′ l))) (Eq.sym (NP.+-∸-comm l (FP.toℕ≤n k))) ⟩
        g ^′ ((p-1 ℕ.+ l) ∸ l )  + - ((g ^′ l)) ≡⟨ Eq.cong (\ xx -> g ^′ xx  + - ((g ^′ l))) (NP.m+n∸n≡m p-1 l) ⟩
        g ^′ (p-1) + - ((g ^′ l)) ≡⟨ aux-1 ⟩
        0ₚ ∎
      aux-3 : (g ^′ (p-1 ∸ l)  + - 1ₚ)  ≡ 0ₚ
      aux-3 = begin
        (g ^′ (p-1 ∸ l)  + - 1ₚ) ≡⟨ Eq.sym (*-identityʳ (g ^′ (p-1 ∸ l)  + - 1ₚ)) ⟩
        (g ^′ (p-1 ∸ l)  + - 1ₚ) * ₁ ≡⟨ Eq.cong ((g ^′ (p-1 ∸ l)  + - 1ₚ) *_) (Eq.sym (lemma-⁻¹ʳ (g ^′ l) {{nztoℕ {y = g ^′ l} {neq0 = lemma-g^′k≠0 l}}})) ⟩
        (g ^′ (p-1 ∸ l)  + - 1ₚ) * ((g ^′ l) * glinv)  ≡⟨ Eq.sym (*-assoc ((g ^′ (p-1 ∸ l)  + - 1ₚ)) ((g ^′ l)) glinv) ⟩
        ((g ^′ (p-1 ∸ l)  + - 1ₚ) * g ^′ l) * glinv  ≡⟨ Eq.cong (_* glinv) aux-2 ⟩
        0ₚ * glinv  ≡⟨ *-zeroˡ glinv ⟩
        0ₚ ∎
        where
        glinv = _⁻¹' (g ^′ l) {{nztoℕ {y = g ^′ l} {neq0 = lemma-g^′k≠0 l}}}

      aux-3b : (g ^′ (p-1 ∸ l)  + - 1ₚ)  ≡ 1ₚ + - 1ₚ
      aux-3b = Eq.trans aux-3 (Eq.sym (+-inverseʳ 1ₚ))

      aux-4 : g ^′ (p-1 ∸ l) ≡ 1ₚ
      aux-4 = begin
        g ^′ (p-1 ∸ l) ≡⟨ +-cancelʳ (- 1ₚ) (g ^′ (p-1 ∸ l)) 1ₚ aux-3b ⟩
        1ₚ ∎

      aux-5 : g ^′ (p-1 ∸ l) ^′ l ≡ 1ₚ
      aux-5 = begin
        g ^′ (p-1 ∸ l) ^′ l ≡⟨ Eq.cong (_^′ l) aux-4 ⟩
        1ₚ ^′ l ≡⟨ 1^k=1 l ⟩
        1ₚ ∎

  --    ok = _⁻¹' (p-1 ∸ l) {{?}} *  = p-1
      aux-6 : g ^′ p-1 ≡ 1ₚ
      aux-6 = begin
        g ^′ p-1 ≡⟨ Eq.cong (g ^′_) (Eq.sym (NP.m+n∸n≡m p-1 l)) ⟩
        g ^′ ((p-1 ℕ.+ l) ∸ l) ≡⟨ Eq.cong (g ^′_) (NP.+-∸-comm l (FP.toℕ≤n k)) ⟩
        g ^′ ((p-1 ∸ l) ℕ.+ l) ≡⟨ {!!} ⟩
        g ^′ (p-1 ∸ l) ^′ l ≡⟨ {!!} ⟩
        1ₚ ∎

    lemma-g^′p-1 : g ^′ p-1 ≡ 1ₚ
    lemma-g^′p-1 = begin
      g ^′ p-1 ≡⟨ {!!} ⟩
      1ₚ ∎
      where
      open ≡-Reasoning
  -}






{- bak


    open import Data.Vec as V hiding (sum)
    open import Data.Vec.Properties
    open import Data.Vec.Recursive.Properties
    open import Function
    
    sum : Vec (ℤ ₚ) n → (ℤ ₚ)
    sum = foldr _ _+_ 0ₚ

    infix 7 _*ᵥ_ _*ᵢ_ _ᵥ*_
    infix 6 _+ᵢ_
    infix 5 _*ₛ_
    
    _*ᵥ_ : ℤ ₚ -> Vec (ℤ ₚ) n -> Vec (ℤ ₚ) n
    _*ᵥ_ x = V.map (x *_)

    _ᵥ*_ : ℤ ₚ -> Vec (ℤ ₚ) n -> Vec (ℤ ₚ) n
    _ᵥ*_ x = V.map (_* x)

    _*ᵢ_ : Vec (ℤ ₚ) n -> Vec (ℤ ₚ) n -> Vec (ℤ ₚ) n
    _*ᵢ_ = V.zipWith _*_

    _*ₛ_ : Vec ℕ n -> Vec (ℤ ₚ) n -> Vec (ℤ ₚ) n
    _*ₛ_ = V.zipWith _＊_

    _+ᵢ_ : Vec (ℤ ₚ) n -> Vec (ℤ ₚ) n -> Vec (ℤ ₚ) n
    _+ᵢ_ = V.zipWith _+_

    *-distribˡ-sum : ∀ x (vs : Vec (ℤ ₚ) n) -> x * sum vs ≡ sum (x *ᵥ vs)
    *-distribˡ-sum x vs@[] = begin
      x * sum vs ≡⟨ auto ⟩
      x * ₀ ≡⟨ *-zeroʳ x ⟩
      ₀ ≡⟨ auto ⟩
      sum (x *ᵥ vs) ∎
      where
      open ≡-Reasoning
    *-distribˡ-sum x vs@(v ∷ t) = begin
      x * sum vs ≡⟨ auto ⟩
      x * (v + sum t) ≡⟨ *-distribˡ-+ x v (sum t) ⟩
      x * v + x * sum t ≡⟨ cong (x * v +_) (*-distribˡ-sum x t) ⟩
      x * v + sum (x *ᵥ t) ≡⟨ auto ⟩
      sum (x *ᵥ vs) ∎
      where
      open ≡-Reasoning


    +-sum-comm : ∀ (v1 v2 : Vec (ℤ ₚ) n) -> sum v1 + sum v2 ≡ sum (v1 +ᵢ v2)
    +-sum-comm [] [] = auto
    +-sum-comm v1@(x ∷ t) v2@(y ∷ t2) = begin
      sum v1 + sum v2 ≡⟨ auto ⟩
      x + sum t + (y + sum t2) ≡⟨ +-assoc x (sum t) (y + sum t2) ⟩
      x + (sum t + (y + sum t2)) ≡⟨ cong (x +_) (sym (+-assoc (sum t) y (sum t2))) ⟩
      x + (sum t + y + sum t2) ≡⟨ cong (x +_) (cong (_+ sum t2) (+-comm (sum t) y)) ⟩
      x + (y + sum t + sum t2) ≡⟨ cong (x +_) (+-assoc y (sum t) (sum t2)) ⟩
      x + (y + (sum t + sum t2)) ≡⟨ sym (+-assoc x y (sum t + sum t2)) ⟩
      (x + y) + (sum t + sum t2) ≡⟨ cong ((x + y) +_) (+-sum-comm t t2) ⟩
      (x + y) + sum (t +ᵢ t2) ≡⟨ auto ⟩
      sum (v1 +ᵢ v2) ∎
      where
      open ≡-Reasoning

    add-adj : Vec ℕ (₁₊ n) -> Vec ℕ n
    add-adj {₀} (x ∷ v) = []
    add-adj {₁₊ n} (x ∷ x₁ ∷ v) = x ℕ.+ x₁ ∷ add-adj (x₁ ∷ v)
    
    pascal-row : ∀ (n : ℕ) -> Vec ℕ (₁₊ n)
    pascal-row ₀ = ₁ ∷ []
    pascal-row (₁₊ n) = ₁ ∷ (add-adj (pascal-row n) ∷ʳ ₁)

    x^k : (a : ℤ ₚ) (k : ℕ) -> Vec (ℤ ₚ) (₁₊ k)
    x^k a ₀ = (a ^′ ₀) ∷ []
    x^k a (₁₊ k) = (a ^′ (₁₊ k)) ∷ (x^k a k)

    x^kʳ : (a : ℤ ₚ) (k : ℕ) -> Vec (ℤ ₚ) (₁₊ k)
    x^kʳ a ₀ = [] ∷ʳ a ^′ ₀
    x^kʳ a (₁₊ k) = x^k a k ∷ʳ a ^′ (₁₊ k)


    xy^k : (a b : ℤ ₚ) (k : ℕ) -> Vec (ℤ ₚ) (₁₊ k)
    xy^k a b ₀ = (a ^′ ₀ * b ^′ ₀) ∷ []
    xy^k a b ₁ = (a ^′ ₁ * b ^′ ₀) ∷ (a ^′ ₀ * b ^′ ₁) ∷ []
    xy^k a b k@(₂₊ k-2) = (a ^′ k * b ^′ ₀) ∷ (xy^k a b k-2 ∷ʳ (a ^′ ₀ * b ^′ k))

    lemma-*ᵢ-tail : ∀ (v1 v2 : Vec (ℤ ₚ) (₁₊ n)) -> tail (v1 *ᵢ v2) ≡ tail (v1 *ᵢ v2)
    lemma-*ᵢ-tail (x ∷ v1) (x₁ ∷ v2) = auto

    head-x^kʳ : ∀ b k -> head (x^kʳ b k) ≡ ₁
    head-x^kʳ b k@₀ = auto
    head-x^kʳ b k@(₁) = begin
      head (x^kʳ b k) ≡⟨ auto ⟩
      head (x^kʳ b ₀) ≡⟨ auto ⟩
      ₁ ∎
      where
      open ≡-Reasoning
    head-x^kʳ b k@(₁₊ k-1) = begin
      head (x^kʳ b k) ≡⟨ {!!} ⟩
      head (x^kʳ b k-1) ≡⟨ {!!} ⟩
      ₁ ∎
      where
      open ≡-Reasoning
    

    lemma-x^k : ∀ (a b : ℤ ₚ) (k-1 : ℕ) -> let k = ₁₊ k-1 in
      (x^kʳ a k) *ᵢ (x^k b k) ≡ b ^′ k ∷ a *ᵥ (x^kʳ a k-1 *ᵢ x^k b k-1)
    lemma-x^k a b k-1@₀ = let k = ₁₊ k-1 in begin
      (x^kʳ a k) *ᵢ (x^k b k) ≡⟨ auto ⟩
      (₁ ∷ a ^′ ₁ ∷ []) *ᵢ (b ^′ ₁ ∷ ₁ ∷ []) ≡⟨ auto ⟩
      ₁ * b ^′ ₁ ∷ a ^′ ₁ * ₁ ∷ [] ≡⟨ cong₂ (λ xx yy → xx ∷ (yy ∷ [])) (*-identityˡ (b ^′ ₁)) (*-identityʳ (a ^′ ₁)) ⟩
      b ^′ ₁ ∷ a ^′ ₁ ∷ [] ≡⟨ cong₂ (λ xx yy → xx ∷ (yy ∷ [])) (*-identityʳ b) (*-identityʳ a) ⟩
      b ∷ a ∷ [] ≡⟨ cong₂ (λ xx yy → xx ∷ (yy ∷ [])) (sym (*-identityʳ b)) (sym (*-identityʳ a)) ⟩
      b ^′ k ∷ a *ᵥ (x^kʳ a k-1 *ᵢ x^k b k-1) ∎
      where
      open ≡-Reasoning


    lemma-x^k a b k-1 = let k = ₁₊ k-1 in begin
      (x^kʳ a k) *ᵢ (x^k b k) ≡⟨ {!auto!} ⟩
      ₁ * b ^′ k ∷ {!!} ≡⟨ {!!} ⟩
      b ^′ k ∷ a *ᵥ (x^kʳ a k-1 *ᵢ x^k b k-1) ∎
      where
      open ≡-Reasoning

    binomial-terms : ∀ (a b : ℤ ₚ) (k : ℕ) -> Vec (ℤ ₚ) (₁₊ k)
    binomial-terms a b k = pascal-row k *ₛ (x^kʳ a k) *ᵢ (x^k b k)

    lemma-binomia-terms' : ∀ (a b : ℤ ₚ) (k-1 : ℕ) -> let k = ₁₊ k-1 in
    
      binomial-terms a b k ≡ ₁ ＊ a ^′ ₀ * b ^′ k ∷ ((add-adj (pascal-row k-1) ∷ʳ ₁) *ₛ (x^kʳ a k-1) *ᵢ (x^k b k-1))
      
    lemma-binomia-terms' a b k-1 = let k = ₁₊ k-1 in {!!}


    lemma-binomia-terms : ∀ (a b : ℤ ₚ) (k-1 : ℕ) -> let k = ₁₊ k-1 in
    
      binomial-terms a b k ≡ (₀ ∷ a *ᵥ binomial-terms a b k-1) +ᵢ (b *ᵥ binomial-terms a b k-1 ∷ʳ ₀)
      
    lemma-binomia-terms a b k-1@₀ = let k = ₁₊ k-1 in begin
      binomial-terms a b k ≡⟨ auto ⟩
      pascal-row k *ₛ (x^kʳ a k) *ᵢ (x^k b k) ≡⟨ auto ⟩
      (₁ ＊ a ^′ ₀ * b ^′ k) ∷ (₁ ＊ a ^′ ₁ * b ^′ ₀ ∷ []) ≡⟨ cong₂ (\ xx yy -> xx ∷ yy ∷ []) (1＊x=x (₁ * b ^′ ₁)) (1＊x=x (a ^′ ₁ * ₁)) ⟩
      (₁ * b ^′ ₁) ∷ (a ^′ ₁ * ₁ ∷ []) ≡⟨ cong₂ (\ xx yy -> xx ∷ yy ∷ []) (*-identityˡ (b ^′ ₁)) (*-identityʳ (a ^′ ₁)) ⟩
      b ^′ ₁ ∷ a ^′ ₁ ∷ [] ≡⟨ cong₂ (λ xx yy → xx ∷ (yy ∷ [])) (*-identityʳ b) (*-identityʳ a) ⟩
      b ∷ a ∷ [] ≡⟨ sym (cong₂ (λ xx yy → xx ∷ (yy ∷ [])) (*-identityʳ b) (*-identityʳ a)) ⟩
      b * ₁ ∷ a * ₁ ∷ [] ≡⟨ sym (cong₂ (λ xx yy → xx ∷ (yy ∷ [])) (*-identityˡ (b * ₁)) (*-identityʳ (a * ₁))) ⟩
      ₁ * (b * ₁) ∷ a * ₁ * ₁ ∷ [] ≡⟨ cong₂ (λ xx yy → xx ∷ (yy ∷ [])) (trans (*-identityˡ (b * ₁)) (*-identityʳ b)) (trans (*-identityʳ (a * ₁)) (*-identityʳ a)) ⟩
      b ∷ a ∷ [] ≡⟨ cong₂ (λ xx yy → xx ∷ (yy ∷ [])) (sym (+-identityˡ b)) (sym (+-identityʳ a)) ⟩
      ₀ + b ∷ a + ₀ ∷ [] ≡⟨ auto ⟩
      (₀ ∷ a ∷ []) +ᵢ ((b ∷ []) ∷ʳ ₀) ≡⟨ cong₂ (\ xx yy -> (₀ ∷ xx ∷ []) +ᵢ ((yy ∷ []) ∷ʳ ₀)) (sym (*-identityʳ a)) (sym (*-identityʳ b)) ⟩
      (₀ ∷ (a * ₁ ∷ [])) +ᵢ ((b * ₁ ∷ []) ∷ʳ ₀) ≡⟨ auto ⟩
      (₀ ∷ a *ᵥ binomial-terms a b k-1) +ᵢ (b *ᵥ binomial-terms a b k-1 ∷ʳ ₀) ∎
      where
      open ≡-Reasoning
    lemma-binomia-terms a b k-1@(₁₊ k-2) = let k = ₁₊ k-1 in begin
      binomial-terms a b k ≡⟨ auto ⟩
      pascal-row k *ₛ (x^kʳ a k) *ᵢ (x^k b k) ≡⟨ {!auto!} ⟩
      ₁ ＊ a ^′ ₀ * b ^′ k ∷ ((add-adj (pascal-row k-1) ∷ʳ ₁) *ₛ (x^kʳ a k-1) *ᵢ (x^k b k-1)) ≡⟨ {!!} ⟩
      (₀ ∷ a *ᵥ binomial-terms a b k-1) +ᵢ (b *ᵥ binomial-terms a b k-1 ∷ʳ ₀) ∎
      where
      open ≡-Reasoning

    binomial-formula : ∀ (a b : ℤ ₚ) (k : ℕ) -> ℤ ₚ
    binomial-formula a b k = sum $ binomial-terms a b k

    binomial-theorem : ∀ (a b : ℤ ₚ) (k : ℕ) -> (a + b) ^′ k ≡ binomial-formula a b k
    binomial-theorem a b 0 = auto
    binomial-theorem a b k@(₁₊ k-1) = begin
      (a + b) ^′ k ≡⟨ auto ⟩
      (a + b) * (a + b) ^′ k-1 ≡⟨ cong ((a + b) *_) (binomial-theorem a b k-1) ⟩
      (a + b) * binomial-formula a b k-1 ≡⟨ *-distribʳ-+ (binomial-formula a b k-1) a b ⟩
      a * binomial-formula a b k-1 + b * binomial-formula a b k-1 ≡⟨ (cong₂ _+_ (*-distribˡ-sum a (binomial-terms a b k-1)) (*-distribˡ-sum b (binomial-terms a b k-1))) ⟩
      sum (a *ᵥ binomial-terms a b k-1) + sum (b *ᵥ binomial-terms a b k-1) ≡⟨ +-sum-comm (a *ᵥ binomial-terms a b k-1) (b *ᵥ binomial-terms a b k-1) ⟩
      sum (a *ᵥ binomial-terms a b k-1 +ᵢ b *ᵥ binomial-terms a b k-1) ≡⟨ {!!} ⟩
      binomial-formula a b k ∎
      where
      open ≡-Reasoning

-}
-}



{-
    open import Data.Vec as V hiding (sum)
    open import Data.Vec.Properties
    open import Data.Vec.Recursive.Properties
    open import Function
    
    sum : Vec (ℤ ₚ) n → (ℤ ₚ)
    sum = foldr _ _+_ 0ₚ

    infix 7 _*ᵥ_ _*ᵢ_ _ᵥ*_
    infix 6 _+ᵢ_
    infix 5 _*ₛ_
    
    _*ᵥ_ : ℤ ₚ -> Vec (ℤ ₚ) n -> Vec (ℤ ₚ) n
    _*ᵥ_ x = V.map (x *_)

    _ᵥ*_ : ℤ ₚ -> Vec (ℤ ₚ) n -> Vec (ℤ ₚ) n
    _ᵥ*_ x = V.map (_* x)

    _*ᵢ_ : Vec (ℤ ₚ) n -> Vec (ℤ ₚ) n -> Vec (ℤ ₚ) n
    _*ᵢ_ = V.zipWith _*_

    _*ₛ_ : Vec ℕ n -> Vec (ℤ ₚ) n -> Vec (ℤ ₚ) n
    _*ₛ_ = V.zipWith _＊_

    _+ᵢ_ : Vec (ℤ ₚ) n -> Vec (ℤ ₚ) n -> Vec (ℤ ₚ) n
    _+ᵢ_ = V.zipWith _+_

    *-distribˡ-sum : ∀ x (vs : Vec (ℤ ₚ) n) -> x * sum vs ≡ sum (x *ᵥ vs)
    *-distribˡ-sum x vs@[] = begin
      x * sum vs ≡⟨ auto ⟩
      x * ₀ ≡⟨ *-zeroʳ x ⟩
      ₀ ≡⟨ auto ⟩
      sum (x *ᵥ vs) ∎
      where
      open ≡-Reasoning
    *-distribˡ-sum x vs@(v ∷ t) = begin
      x * sum vs ≡⟨ auto ⟩
      x * (v + sum t) ≡⟨ *-distribˡ-+ x v (sum t) ⟩
      x * v + x * sum t ≡⟨ cong (x * v +_) (*-distribˡ-sum x t) ⟩
      x * v + sum (x *ᵥ t) ≡⟨ auto ⟩
      sum (x *ᵥ vs) ∎
      where
      open ≡-Reasoning


    +-sum-comm : ∀ (v1 v2 : Vec (ℤ ₚ) n) -> sum v1 + sum v2 ≡ sum (v1 +ᵢ v2)
    +-sum-comm [] [] = auto
    +-sum-comm v1@(x ∷ t) v2@(y ∷ t2) = begin
      sum v1 + sum v2 ≡⟨ auto ⟩
      x + sum t + (y + sum t2) ≡⟨ +-assoc x (sum t) (y + sum t2) ⟩
      x + (sum t + (y + sum t2)) ≡⟨ cong (x +_) (sym (+-assoc (sum t) y (sum t2))) ⟩
      x + (sum t + y + sum t2) ≡⟨ cong (x +_) (cong (_+ sum t2) (+-comm (sum t) y)) ⟩
      x + (y + sum t + sum t2) ≡⟨ cong (x +_) (+-assoc y (sum t) (sum t2)) ⟩
      x + (y + (sum t + sum t2)) ≡⟨ sym (+-assoc x y (sum t + sum t2)) ⟩
      (x + y) + (sum t + sum t2) ≡⟨ cong ((x + y) +_) (+-sum-comm t t2) ⟩
      (x + y) + sum (t +ᵢ t2) ≡⟨ auto ⟩
      sum (v1 +ᵢ v2) ∎
      where
      open ≡-Reasoning
-}
